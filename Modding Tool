import os
import re
import shutil
import traceback
import threading
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox, colorchooser, simpledialog
import sys
import queue
import json
import random
import colorsys

# =============================================================================
#  CORE LOGIC
# =============================================================================

class Vic3Logic:
    def __init__(self, log_callback):
        self.log = log_callback
        self.mod_path = ""
        self.vanilla_path = ""
        self.auto_backup_enabled = False
        self.stop_event = threading.Event()

    def set_mod_path(self, path):
        self.mod_path = path

    def set_vanilla_path(self, path):
        self.vanilla_path = path

    def format_tag_clean(self, user_input):
        cleaned = user_input.strip()
        if cleaned.lower().startswith("c:"):
            cleaned = cleaned[2:]
        return cleaned.upper()

    def format_state_clean(self, user_input):
        clean = user_input.upper().strip()
        if not clean: return ""
        if not clean.startswith("STATE_"):
            clean = f"STATE_{clean}"
        return clean

    # --- TAG VALIDATION & CREATION ---
    def tag_exists(self, tag):
        """Checks if a country tag already exists in common/country_definitions."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return False
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()
                
                if re.search(r"^\s*" + re.escape(tag) + r"\s*=", content, re.MULTILINE):
                    return True
        return False

    def scan_definitions_for_options(self):
        """Scans common/country_definitions for unique cultures, religions, tiers, and country types."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")

        cultures = set()
        religions = set()
        tiers = set()
        types = set()

        if not os.path.exists(def_path):
            return [], [], [], []

        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                # Cultures
                cul_matches = re.finditer(r"cultures\s*=\s*\{([^}]+)\}", content)
                for m in cul_matches:
                    for c in m.group(1).split():
                        cultures.add(c.strip())

                # Religions
                rel_matches = re.finditer(r"religion\s*=\s*([A-Za-z0-9_]+)", content)
                for m in rel_matches:
                    r_val = m.group(1).strip()
                    if r_val.lower() != "technically":
                        religions.add(r_val)

                # Tiers
                tier_matches = re.finditer(r"tier\s*=\s*([A-Za-z0-9_]+)", content)
                for m in tier_matches:
                    tiers.add(m.group(1).strip())

                # Country Types
                type_matches = re.finditer(r"country_type\s*=\s*([A-Za-z0-9_]+)", content)
                for m in type_matches:
                    types.add(m.group(1).strip())

        return sorted(list(cultures)), sorted(list(religions)), sorted(list(tiers)), sorted(list(types))

    def get_country_data(self, tag):
        """Attempts to find culture, religion, and capital of a tag."""
        data = { "cultures": None, "religion": None, "capital": None }
        
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return data

        clean_tag = tag.replace("c:", "").strip()
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                match = re.search(r"(^|\s)" + re.escape(clean_tag) + r"\s*=\s*\{", content, re.MULTILINE | re.IGNORECASE)
                if match:
                    start_brace = match.end() - 1
                    _, end_brace = self.find_block_content(content, start_brace)
                    
                    if end_brace:
                        block_content = content[start_brace:end_brace]
                        
                        cul_match = re.search(r"cultures\s*=\s*\{([^}]+)\}", block_content)
                        if cul_match: data["cultures"] = cul_match.group(1).strip()
                        
                        rel_match = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if rel_match: data["religion"] = rel_match.group(1).strip()

                        # Matches capital = ... or capital_state = ...
                        cap_match = re.search(r"(capital|capital_state)\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if cap_match: data["capital"] = cap_match.group(2).strip()
                        return data
        return data

    def get_religion_by_culture(self, culture):
        """Scans common/cultures to find the default religion for a given culture."""
        cult_dir = os.path.join(self.mod_path, "common/cultures")
        if not os.path.exists(cult_dir): return None

        # Matches: start of line or whitespace + culture + whitespace + = + whitespace + {
        pat = re.compile(r"(?:^|\s)" + re.escape(culture) + r"\s*=\s*\{", re.MULTILINE)

        for root, _, files in os.walk(cult_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                match = pat.search(content)
                if match:
                    # Found start of culture block. Find the block content.
                    start_brace = match.end() - 1
                    _, end_brace = self.find_block_content(content, start_brace)
                    
                    if end_brace:
                        block = content[start_brace:end_brace]
                        rel_match = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", block)
                        if rel_match:
                            return rel_match.group(1).strip()
        return None

    def get_tech_tier_from_history(self, tag):
        """Scans history/countries for tech tier."""
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        if not os.path.exists(hist_dir): return None

        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Check for country block c:TAG
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                     match = re.search(r"effect_starting_technology_tier_\d+_tech\s*=\s*yes", content)
                     if match:
                         return match.group(0)
        return None

    def get_pop_history_data(self, tag):
        """Scans history/population for wealth and literacy effects."""
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        if not os.path.exists(pop_dir): return None

        clean_tag = tag.replace("c:", "").strip()
        effects = []

        for root, _, files in os.walk(pop_dir):
            for file in files:
                if not file.endswith(".txt"): continue

                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                current_idx = 0
                while True:
                    c_start, c_end = self.get_block_range_safe(content, f"c:{clean_tag}", current_idx)
                    if c_start is None: break

                    block = content[c_start:c_end]
                    wealth = re.search(r"effect_starting_pop_wealth_[a-z_]+\s*=\s*yes", block)
                    if wealth and wealth.group(0) not in effects: effects.append(wealth.group(0))

                    literacy = re.search(r"effect_starting_pop_literacy_[a-z_]+\s*=\s*yes", block)
                    if literacy and literacy.group(0) not in effects: effects.append(literacy.group(0))

                    current_idx = c_end

        if effects:
            return "\n\t\t".join(effects)
        return None

    def get_pop_history_settings(self, tag):
        """Scans history/population for wealth and literacy settings dictionary."""
        clean_tag = tag.replace("c:", "").strip()
        settings = {"wealth": "", "literacy": ""}

        paths = []
        if self.mod_path: paths.append(os.path.join(self.mod_path, "common/history/population"))
        if self.vanilla_path: paths.append(os.path.join(self.vanilla_path, "game/common/history/population"))

        for p in paths:
             if not os.path.exists(p): continue
             for root, _, files in os.walk(p):
                for file in files:
                    if not file.endswith(".txt"): continue
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(path, 'r', encoding='utf-8') as f: content = f.read()

                    current_idx = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"c:{clean_tag}", current_idx)
                        if s is None: break

                        block = content[s:e]

                        w_match = re.search(r"(effect_starting_pop_wealth_[a-z_]+)\s*=\s*yes", block)
                        if w_match: settings["wealth"] = w_match.group(1)

                        l_match = re.search(r"(effect_starting_pop_literacy_[a-z_]+)\s*=\s*yes", block)
                        if l_match: settings["literacy"] = l_match.group(1)

                        current_idx = e

        return settings

    def save_pop_history_settings(self, tag, wealth, literacy):
        self.perform_auto_backup()
        clean_tag = tag.replace("c:", "").strip()
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        os.makedirs(pop_dir, exist_ok=True)

        target_file = None
        target_content = None

        # 1. Find existing file in mod
        for root, _, files in os.walk(pop_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: c = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: c = f.read()

                if re.search(r"c:" + re.escape(clean_tag) + r"\b", c):
                    target_file = path
                    target_content = c
                    break
            if target_file: break

        # 2. If not found, create new file
        if not target_file:
            # Check if name is known for cleaner filename
            # But prompt says: "find the file named 'tur - ottoman empire.txt' ... If the tag doesnt have a file ... simply create one"
            # We will name it "tag.txt" or try to find name
            target_file = os.path.join(pop_dir, f"{clean_tag}.txt")
            target_content = f"POPULATION = {{\n\tc:{clean_tag} ?= {{\n\t}}\n}}"
            if os.path.exists(target_file):
                 with open(target_file, 'r', encoding='utf-8-sig') as f: target_content = f.read()

        # 3. Edit content
        s, e = self.get_block_range_safe(target_content, f"c:{clean_tag}")
        if s is not None:
            block = target_content[s:e]

            # Remove existing lines
            block = re.sub(r"\s*effect_starting_pop_wealth_[a-z_]+\s*=\s*yes", "", block)
            block = re.sub(r"\s*effect_starting_pop_literacy_[a-z_]+\s*=\s*yes", "", block)

            # Add new
            additions = ""
            if wealth: additions += f"\n\t\t{wealth} = yes"
            if literacy: additions += f"\n\t\t{literacy} = yes"

            # Insert
            last_brace = block.rfind('}')
            new_block = block[:last_brace] + additions + "\n\t}"

            target_content = target_content[:s] + new_block + target_content[e:]

            with open(target_file, 'w', encoding='utf-8-sig') as f: f.write(target_content)
            self.log(f"[SAVE] Pop settings saved to {os.path.basename(target_file)}", 'success')

    def get_extended_history_data(self, tag):
        """Scans history/countries for extended data (tech, laws, politics, institutions)."""
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        if not os.path.exists(hist_dir): return None

        clean_tag = tag.replace("c:", "").strip()
        data = {
            "tech_tier": [],
            "techs_researched": [],
            "politics": [],
            "laws": [],
            "institutions": []
        }

        found_any = False

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                current_idx = 0
                while True:
                    c_start, c_end = self.get_block_range_safe(content, f"c:{clean_tag}", current_idx)
                    if c_start is None: break
                    found_any = True

                    sb, _ = self.find_block_content(content, c_start)
                    if sb is not None:
                        block_inner = content[sb+1 : c_end-1]

                        data["tech_tier"].extend(re.findall(r"effect_starting_technology_tier_\d+_tech\s*=\s*yes", block_inner))
                        data["politics"].extend(re.findall(r"effect_starting_politics_[a-z_]+\s*=\s*yes", block_inner))
                        data["techs_researched"].extend(re.findall(r"add_technology_researched\s*=\s*[a-zA-Z0-9_]+", block_inner))
                        data["laws"].extend([l.strip() for l in re.findall(r"^\s*(activate_law\s*=\s*.*)$", block_inner, re.MULTILINE)])

                        inst_pattern = re.compile(r"(set_institution_[a-zA-Z0-9_]+)\s*=\s*", re.MULTILINE)
                        cursor = 0
                        while True:
                            match = inst_pattern.search(block_inner, cursor)
                            if not match: break

                            next_char_idx = match.end()
                            while next_char_idx < len(block_inner) and block_inner[next_char_idx].isspace():
                                next_char_idx += 1

                            if next_char_idx < len(block_inner) and block_inner[next_char_idx] == '{':
                                b_start, b_end = self.find_block_content(block_inner, next_char_idx)
                                if b_start is not None:
                                    data["institutions"].append(block_inner[match.start():b_end].strip())
                                    cursor = b_end
                                else:
                                    cursor = match.end()
                            else:
                                line_end = block_inner.find('\n', match.end())
                                if line_end == -1: line_end = len(block_inner)
                                data["institutions"].append(block_inner[match.start():line_end].strip())
                                cursor = line_end
                    current_idx = c_end

        if not found_any: return None
        return data

    def get_nearest_vic3_color(self, rgb):
        colors = {
            "white": (255, 255, 255), "black": (10, 10, 10), "red": (180, 0, 0),
            "green": (0, 180, 0), "blue": (0, 0, 180), "yellow": (255, 255, 0),
            "gold": (212, 175, 55), "orange": (255, 140, 0), "pink": (255, 105, 180),
            "purple": (128, 0, 128), "brown": (139, 69, 19), "grey": (128, 128, 128),
            "dark_red": (100, 0, 0), "dark_blue": (0, 0, 100), "dark_green": (0, 80, 0),
            "light_blue": (135, 206, 235)
        }
        r, g, b = rgb
        min_dist = float('inf')
        closest_name = "white"
        for name, c_rgb in colors.items():
            dist = (r - c_rgb[0])**2 + (g - c_rgb[1])**2 + (b - c_rgb[2])**2
            if dist < min_dist:
                min_dist = dist
                closest_name = name
        return closest_name

    def create_country_files(self, tag, name, adjective, capital, gov_type, color_rgb, cultures_list, religion, tier, country_type, old_tag, wealth=None, literacy=None):
        self.perform_auto_backup()
        self.log(f"[GEN] Creating core files for {tag} ({name})...")
        r_i, g_i, b_i = int(color_rgb[0]), int(color_rgb[1]), int(color_rgb[2])
        flag_color_name = self.get_nearest_vic3_color((r_i, g_i, b_i))
        self.log(f"   [COLOR] Mapped selection {color_rgb} to flag color: '{flag_color_name}'")

        cultures_str = " ".join(cultures_list)

        # Definition
        def_dir = os.path.join(self.mod_path, "common/country_definitions")
        os.makedirs(def_dir, exist_ok=True)
        def_file = os.path.join(def_dir, f"99_auto_{tag.lower()}.txt")
        def_content = f"""{tag} = {{
    color = {{ {r_i} {g_i} {b_i} }}
    country_type = {country_type}
    tier = {tier}
    cultures = {{ {cultures_str} }}
    religion = {religion}
    capital = {capital}
}}
"""
        with open(def_file, 'w', encoding='utf-8-sig') as f: f.write(def_content)

        # Localization
        loc_dir = os.path.join(self.mod_path, "localization/english")
        os.makedirs(loc_dir, exist_ok=True)
        loc_file = os.path.join(loc_dir, f"auto_{tag.lower()}_l_english.yml")
        loc_content = f"""l_english:
 {tag}: "{name}"
 {tag}_ADJ: "{adjective}"
 {tag}_DEF: "{name}"
"""
        with open(loc_file, 'w', encoding='utf-8-sig') as f: f.write(loc_content)

        # History
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        os.makedirs(hist_dir, exist_ok=True)
        hist_file = os.path.join(hist_dir, f"{tag} - {name}.txt")

        # Extended Data Extraction
        ext_data = self.get_extended_history_data(old_tag)

        laws_block = ""
        tech_tier_str = ""
        techs_res_str = ""
        politics_str = ""
        inst_str = ""

        if ext_data:
            if ext_data["laws"]:
                laws_block = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["laws"])))
            if ext_data["tech_tier"]:
                tech_tier_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["tech_tier"])))
            if ext_data["techs_researched"]:
                techs_res_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["techs_researched"])))
            if ext_data["politics"]:
                politics_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["politics"])))
            if ext_data["institutions"]:
                inst_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["institutions"])))

        if not laws_block:
            laws_block = """
    activate_law = law_type:law_monarchy
    activate_law = law_type:law_autocracy
    activate_law = law_type:law_peasant_levies
    activate_law = law_type:law_land_tax
""" if gov_type == "monarchy" else """
    activate_law = law_type:law_presidential_republic
    activate_law = law_type:law_census_voting
    activate_law = law_type:law_national_militia
    activate_law = law_type:law_per_capita_tax
    activate_law = law_type:law_appointed_bureaucrats
"""

        if not tech_tier_str:
             tech_tier_str = "effect_starting_technology_tier_1_tech = yes"

        ig_ruler = "ig_landowners" if gov_type == "monarchy" else "ig_intelligentsia"

        hist_content = f"""COUNTRIES = {{
    c:{tag} ?= {{
        {tech_tier_str}
        set_tax_level = medium
        {laws_block}
        {politics_str}
        {techs_res_str}
        {inst_str}

        create_character = {{
            first_name = "Alexander"
            last_name = "Modman"
            birth_date = 1800.1.1
            ruler = yes
            interest_group = {ig_ruler}
        }}
    }}
}}
"""
        with open(hist_file, 'w', encoding='utf-8-sig') as f: f.write(hist_content)

        # Population History
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        os.makedirs(pop_dir, exist_ok=True)
        pop_file = os.path.join(pop_dir, f"{tag} - {name}.txt")

        if wealth or literacy:
            # Use provided settings
            pop_effects = ""
            if wealth: pop_effects += f"{wealth} = yes"
            if literacy:
                if pop_effects: pop_effects += "\n\t\t"
                pop_effects += f"{literacy} = yes"

            # Use defaults if one is missing but other is provided?
            # Or just use what is given.
            if not pop_effects: # Should not happen if wealth or literacy is true
                 pop_effects = "effect_starting_pop_wealth_medium = yes\n\t\teffect_starting_pop_literacy_medium = yes"
        else:
            # Fallback to copy from old tag
            pop_effects = self.get_pop_history_data(old_tag)
            if not pop_effects:
                 pop_effects = "effect_starting_pop_wealth_medium = yes\n\t\teffect_starting_pop_literacy_medium = yes"

        pop_content = f"""POPULATION = {{
    c:{tag} = {{
        {pop_effects}
    }}
}}
"""
        with open(pop_file, 'w', encoding='utf-8-sig') as f: f.write(pop_content)

        # Flag
        flag_dir = os.path.join(self.mod_path, "common/coat_of_arms/coat_of_arms")
        os.makedirs(flag_dir, exist_ok=True)
        flag_file = os.path.join(flag_dir, f"99_auto_{tag.lower()}.txt")
        emblem_texture = "ce_crown.dds" if gov_type == "monarchy" else "ce_star.dds"
        flag_content = f"""{tag} = {{
    pattern = "pattern_solid.tga"
    color1 = "{flag_color_name}"
    colored_emblem = {{
        texture = "{emblem_texture}"
        color1 = "gold"
        instance = {{ position = {{ 0.5 0.5 }} scale = {{ 0.5 0.5 }} }}
    }}
}}
"""
        with open(flag_file, 'w', encoding='utf-8-sig') as f: f.write(flag_content)

    def _get_location_data(self, tag, target_state):
        owned_states = self.get_all_owned_states(tag)
        final_state = None
        if target_state and target_state in owned_states:
            final_state = target_state
            self.log(f"   [LOC] Validated location: {final_state}")
        else:
            if target_state: self.log(f"   [WARN] {tag} does not own {target_state}. Falling back to capital.", 'warn')
            data = self.get_country_data(tag)
            if data["capital"]:
                final_state = data["capital"]
                self.log(f"   [LOC] Using Capital: {final_state}")
            else:
                return None, None
        
        hq_region = self.find_strategic_region(f"s:{final_state}")
        if not hq_region:
            hq_region = "sr:region_europe"
            self.log(f"   [WARN] Could not find HQ region. Defaulting to Europe.", 'warn')
        else:
            if not hq_region.startswith("sr:"):
                hq_region = f"sr:{hq_region}"
                
        return final_state, hq_region

    def create_army_file(self, tag, army_name, target_state, inf, art, cav):
        """Creates a new army history file."""
        self.perform_auto_backup()
        self.log(f"[GEN] Creating Army '{army_name}' for {tag}...")
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count per the Paradox example
        if inf > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_line_infantry
                    state_region = s:{final_state}
                    count = {inf}
                }}"""
        if art > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_cannon_artillery
                    state_region = s:{final_state}
                    count = {art}
                }}"""
        if cav > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_hussars
                    state_region = s:{final_state}
                    count = {cav}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = army_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_army_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{army_name}"
            type = army
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    def create_navy_file(self, tag, navy_name, target_state, manowar, frigate, ironclad):
        """Creates a new navy history file."""
        self.perform_auto_backup()
        self.log(f"[GEN] Creating Navy '{navy_name}' for {tag}...")
        self.log(f"   [WARN] Ensure {target_state if target_state else 'Capital'} is a COASTAL state!", 'warn')
        
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count
        if manowar > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_man_o_war
                    state_region = s:{final_state}
                    count = {manowar}
                }}"""
        if frigate > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_frigate
                    state_region = s:{final_state}
                    count = {frigate}
                }}"""
        if ironclad > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_ironclad
                    state_region = s:{final_state}
                    count = {ironclad}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = navy_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_navy_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{navy_name}"
            type = fleet
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    # --- EXISTING TRANSFER LOGIC ---
    def find_strategic_region(self, state_key):
        path = os.path.join(self.mod_path, "common/strategic_regions")
        if not os.path.exists(path): return None
        clean_key = state_key.replace("s:", "").upper()
        
        for root, _, files in os.walk(path):
            if self.stop_event.is_set(): return None
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f:
                        content = f.read()
                    blocks = content.split("region_")
                    for block in blocks[1:]:
                        if clean_key in block.upper():
                            raw_name = block.split("=")[0].strip()
                            return f"region_{raw_name}"
                except: 
                    continue
        return None

    def find_block_content(self, text, start_index):
        n = len(text)
        i = start_index
        while i < n:
            if text[i] == '{': break
            i += 1
        if i >= n: return None, None
        
        start_brace = i
        i += 1
        depth = 1
        in_string = False
        in_comment = False
        
        while i < n and depth > 0:
            char = text[i]
            if in_comment:
                if char == '\n': in_comment = False
            elif in_string:
                if char == '"' and text[i-1] != '\\': in_string = False
            else:
                if char == '#': in_comment = True
                elif char == '"': in_string = True
                elif char == '{': depth += 1
                elif char == '}': depth -= 1
            i += 1
            
        if depth == 0: return start_brace, i
        return None, None

    def get_block_range_safe(self, content, start_pattern, start_search_idx=0):
        pattern = re.compile(re.escape(start_pattern) + r"\s*(=|[\?]=)\s*\{", re.IGNORECASE)
        match = pattern.search(content, start_search_idx)
        if not match: return None, None
        
        start_brace, end_brace = self.find_block_content(content, match.end() - 1)
        if start_brace is not None:
            return match.start(), end_brace
        return None, None

    def collect_valid_scopes(self):
        valid_scopes = set()
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if not os.path.exists(mil_dir): return valid_scopes
        scope_regex = re.compile(r"save_scope_as\s*=\s*([A-Za-z0-9_]+)", re.IGNORECASE)
        for root, _, files in os.walk(mil_dir):
            if self.stop_event.is_set(): return valid_scopes
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                valid_scopes.update(scope_regex.findall(content))
        return valid_scopes

    def prune_orphaned_commanders(self, valid_scopes):
        char_dir = os.path.join(self.mod_path, "common/history/characters")
        if not os.path.exists(char_dir): return
        link_regex = re.compile(r"(commander_formation\s*=\s*scope:)([A-Za-z0-9_]+)", re.IGNORECASE)
        orphans_removed = 0
        self.log("[FIX] Checking for orphaned generals...")
        for root, _, files in os.walk(char_dir):
            if self.stop_event.is_set(): return
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                new_lines = []
                file_changed = False
                for line in content.splitlines():
                    match = link_regex.search(line)
                    if match:
                        scope_id = match.group(2)
                        if scope_id not in valid_scopes:
                            new_lines.append(f"# {line.strip()} (FIXED: Orphaned link)")
                            orphans_removed += 1
                            file_changed = True
                        else:
                            new_lines.append(line)
                    else:
                        new_lines.append(line)
                if file_changed:
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write("\n".join(new_lines))
        if orphans_removed > 0: self.log(f"[SUCCESS] Removed {orphans_removed} orphaned commander links.", 'success')

    def get_all_owned_states(self, tag):
        states_found = []
        states_dir = os.path.join(self.mod_path, "common/history/states")
        if not os.path.exists(states_dir): return []
        clean_tag = tag.replace("c:", "").strip()
        for root, _, files in os.walk(states_dir):
            if self.stop_event.is_set(): return []
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                state_matches = re.finditer(r"s:(STATE_[A-Za-z0-9_]+)\s*=", content)
                for match in state_matches:
                    state_name = match.group(1)
                    s_start, s_end = self.get_block_range_safe(content, f"s:{state_name}")
                    if s_start is not None:
                        block_content = content[s_start:s_end]
                        owner_regex = re.compile(r"country\s*=\s*c:" + re.escape(clean_tag) + r"\b", re.IGNORECASE)
                        if owner_regex.search(block_content):
                            states_found.append(state_name)
        return list(set(states_found))

    def sanitize_block_content(self, content, state_str, old_tag, new_tag, is_building_file):
        content = re.sub(r"region_state:\s*(c:)?" + re.escape(old_tag), f"region_state:{new_tag}", content, flags=re.IGNORECASE)
        content = re.sub(f"c:{re.escape(old_tag)}", f"c:{new_tag}", content, flags=re.IGNORECASE)
        if is_building_file:
            target_region_str = f'region="{state_str}"'
            content = re.sub(r'region="STATE_[A-Za-z0-9_]+"', target_region_str, content, flags=re.IGNORECASE)
        return content

    def transfer_ownership_batch(self, state_list, old_tag, new_tag):
        # Auto-backup handled by caller or usually this is part of a larger operation like Create Country
        # If used standalone via "Transfer States", we should backup.
        self.perform_auto_backup()
        folders = ["states", "pops", "buildings"]
        results = {s: [] for s in state_list}
        for folder in folders:
            target_dir = os.path.join(self.mod_path, "common/history", folder)
            if not os.path.exists(target_dir): continue
            for root, _, files in os.walk(target_dir):
                if self.stop_event.is_set(): return results
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    try:
                        with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
                    file_changed = False
                    for state in state_list:
                        s_start, s_end = self.get_block_range_safe(content, f"s:{state}")
                        if s_start is not None:
                            block_content = content[s_start:s_end]
                            new_block_content = self.sanitize_block_content(
                                block_content, state, old_tag, new_tag, is_building_file=(folder == "buildings")
                            )
                            if new_block_content != block_content:
                                content = content[:s_start] + new_block_content + content[s_end:]
                                file_changed = True
                                if folder not in results[state]: results[state].append(folder)
                    if file_changed:
                        self.log(f"   [UPDATED] {folder}/{file}")
                        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
        return results

    def clean_unit_string(self, unit_block):
        cleaned = re.sub(r"id\s*=\s*\d+", "", unit_block, flags=re.IGNORECASE)
        cleaned = "\n".join([line for line in cleaned.split('\n') if line.strip()])
        return cleaned

    def generate_immersive_name(self, region_raw, f_type):
        clean_name = region_raw.lower().replace("region_", "").replace("_", " ").title().strip()
        return f"\"{f_type.capitalize()} of {clean_name}\""

    def process_military_extraction_multi_pass(self, filepath, old_tag, new_tag, region, state_list):
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
        clean_states = [re.escape(s.replace("s:","")) for s in state_list]
        state_or_pattern = "|".join(clean_states)
        target_state_regex = re.compile(r"\b(" + state_or_pattern + r")\b", re.IGNORECASE)
        files_modified = False
        stolen_units_army = []
        stolen_units_fleet = []
        current_search_idx = 0
        processed_file_parts = []
        last_idx = 0
        while True:
            c_start, c_end = self.get_block_range_safe(content, f"c:{old_tag}", current_search_idx)
            if c_start is None:
                processed_file_parts.append(content[last_idx:])
                break
            processed_file_parts.append(content[last_idx:c_start])
            body_start_brace, body_end_brace = self.find_block_content(content, c_start)
            if body_start_brace is None:
                processed_file_parts.append(content[c_start:c_end])
                last_idx = c_end
                current_search_idx = c_end
                continue
            header = content[c_start:body_start_brace+1]
            inner_body = content[body_start_brace+1:body_end_brace-1]
            footer = "}"
            new_inner_parts = []
            cursor = 0
            while cursor < len(inner_body):
                match = re.search(r"create_military_formation\s*=\s*\{", inner_body[cursor:])
                if not match:
                    new_inner_parts.append(inner_body[cursor:])
                    break
                abs_match_start = cursor + match.start()
                new_inner_parts.append(inner_body[cursor:abs_match_start])
                brace_idx = abs_match_start + match.group().find('{')
                f_start, f_end = self.find_block_content(inner_body, brace_idx)
                if f_start is None:
                    new_inner_parts.append(inner_body[abs_match_start:])
                    break
                formation_full = inner_body[abs_match_start:f_end]
                is_army = "type" in formation_full and "army" in formation_full.lower()
                is_fleet = "type" in formation_full and "fleet" in formation_full.lower()
                if is_army or is_fleet:
                    f_header = formation_full[:f_start - abs_match_start + 1]
                    f_body = formation_full[f_start - abs_match_start + 1 : -1]
                    f_footer = "}"
                    new_f_body_parts = []
                    f_cursor = 0
                    while f_cursor < len(f_body):
                        u_match = re.search(r"combat_unit\s*=\s*\{", f_body[f_cursor:])
                        if not u_match:
                            new_f_body_parts.append(f_body[f_cursor:])
                            break
                        u_abs_start = f_cursor + u_match.start()
                        new_f_body_parts.append(f_body[f_cursor:u_abs_start])
                        u_brace_idx = u_abs_start + u_match.group().find('{')
                        u_start, u_end = self.find_block_content(f_body, u_brace_idx)
                        if u_start is None:
                            new_f_body_parts.append(f_body[u_abs_start:])
                            break
                        unit_block = f_body[u_abs_start:u_end]
                        if target_state_regex.search(unit_block):
                            self.log(f"      [PURGE] Found ghost unit in {old_tag}. Moving!")
                            clean_block = self.clean_unit_string(unit_block)
                            if is_army: stolen_units_army.append(clean_block)
                            elif is_fleet: stolen_units_fleet.append(clean_block)
                            files_modified = True
                        else:
                            new_f_body_parts.append(unit_block)
                        f_cursor = u_end
                    rebuilt_formation_body = "".join(new_f_body_parts)
                    if "combat_unit" not in rebuilt_formation_body:
                        self.log(f"      [DELETE] Formation became empty. Deleted.")
                        files_modified = True
                    else:
                        new_inner_parts.append(f_header + rebuilt_formation_body + f_footer)
                else:
                    new_inner_parts.append(formation_full)
                cursor = f_end
            processed_file_parts.append(header + "".join(new_inner_parts) + footer)
            last_idx = c_end
            current_search_idx = c_end 
        if not files_modified: return False
        new_file_content = "".join(processed_file_parts)

        def inject_new_formation(file_content, unit_buffer, f_type):
            if not unit_buffer: return file_content
            clean_region_str = region.strip()
            if not clean_region_str.startswith("sr:") and "region_" in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            elif not clean_region_str.startswith("sr:") and "region_" not in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            else:
                hq_region_val = clean_region_str
            immersive_name = self.generate_immersive_name(clean_region_str, f_type)
            block_str = f"""
\tcreate_military_formation = {{
\t\tname = {immersive_name}
\t\ttype = {f_type}
\t\thq_region = {hq_region_val}
\t\t# Transferred Units
\t\t{"\n\t\t".join(unit_buffer)}
\t}}
"""
            last_tag_pos = -1
            curr = 0
            while True:
                ns, ne = self.get_block_range_safe(file_content, f"c:{new_tag}", curr)
                if ns is None: break
                last_tag_pos = ns
                curr = ne
            if last_tag_pos != -1:
                _, end_brace = self.find_block_content(file_content, last_tag_pos)
                insert_pos = end_brace - 1
                return file_content[:insert_pos] + "\n" + block_str + "\n" + file_content[insert_pos:]
            else:
                # NEW LOGIC: Check for MILITARY_FORMATIONS wrapper to insert inside it
                mf_start, mf_end = self.get_block_range_safe(file_content, "MILITARY_FORMATIONS")
                if mf_start is not None:
                    # Insert before the last brace of the wrapper
                    insert_pos = mf_end - 1
                    return file_content[:insert_pos] + f"\n\tc:{new_tag} ?= {{\n{block_str}\n\t}}\n" + file_content[insert_pos:]
                else:
                    return file_content + f"\n\nc:{new_tag} ?= {{\n{block_str}\n}}\n"
        if stolen_units_army:
            self.log(f"      [CREATE] Creating Army for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_army, "army")
        if stolen_units_fleet:
            self.log(f"      [CREATE] Creating Fleet for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_fleet, "fleet")
        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(new_file_content)
        return True

    def clean_military_smart(self, old_tag, new_tag, region, state_list):
        # Auto-backup usually done before this in transfer flow
        if not region: return
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if os.path.exists(mil_dir):
            for root, _, files in os.walk(mil_dir):
                if self.stop_event.is_set(): return
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    self.process_military_extraction_multi_pass(filepath, old_tag, new_tag, region, state_list)

    # --- COUNTRY MODIFICATION LOGIC ---
    def load_country_localization(self, tag):
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        if not os.path.exists(loc_dir): return "", ""

        name = ""
        adj = ""

        def search_dir(directory):
            n, a = "", ""
            if not os.path.exists(directory): return "", ""
            for root, _, files in os.walk(directory):
                for file in files:
                    if not file.endswith(".yml"): continue
                    try:
                        with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                    m_name = re.search(r'^\s*' + re.escape(tag) + r':\d?\s*"(.*)"', content, re.MULTILINE | re.IGNORECASE)
                    if m_name: n = m_name.group(1)

                    m_adj = re.search(r'^\s*' + re.escape(tag) + r'_ADJ:\d?\s*"(.*)"', content, re.MULTILINE | re.IGNORECASE)
                    if m_adj: a = m_adj.group(1)
            return n, a

        n1, a1 = search_dir(loc_dir)
        n2, a2 = search_dir(os.path.join(loc_dir, "replace"))
        return (n2 if n2 else n1), (a2 if a2 else a1)

    def save_country_localization(self, tag, name, adj):
        self.perform_auto_backup()
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        rep_dir = os.path.join(loc_dir, "replace")
        os.makedirs(rep_dir, exist_ok=True)

        # Check if a replace file for this tag already exists to append/modify
        target_file = None
        for root, _, files in os.walk(rep_dir):
            for file in files:
                if not file.endswith(".yml"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                if re.search(r"^\s*" + re.escape(tag) + r":", content, re.MULTILINE):
                    target_file = path
                    break
            if target_file: break

        if not target_file:
            target_file = os.path.join(rep_dir, f"{tag.lower()}_l_english.yml")
            if not os.path.exists(target_file):
                 with open(target_file, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        try:
            with open(target_file, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_file, 'r', encoding='utf-8') as f: content = f.read()

        # Update Name
        if re.search(r"^\s*" + re.escape(tag) + r":", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r':.*', f' {tag}: "{name}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}: "{name}"\n'

        # Update Adjective
        if re.search(r"^\s*" + re.escape(tag) + r"_ADJ:", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r'_ADJ:.*', f' {tag}_ADJ: "{adj}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}_ADJ: "{adj}"\n'

        # Update Def
        if re.search(r"^\s*" + re.escape(tag) + r"_DEF:", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r'_DEF:.*', f' {tag}_DEF: "{name}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}_DEF: "{name}"\n'

        with open(target_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[SAVE] Localization saved to {target_file}", 'success')

    def load_country_definition_data(self, tag):
        def_path = os.path.join(self.mod_path, "common", "country_definitions")
        if not os.path.exists(def_path): return None, None, None
        clean_tag = tag.strip()
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                match = re.search(r"(^|\s)" + re.escape(clean_tag) + r"\s*=\s*\{", content, re.MULTILINE)
                if match:
                    start = match.end() - 1
                    _, end = self.find_block_content(content, start)
                    if end:
                        block = content[start:end]
                        c_match = re.search(r"color\s*=\s*(hsv|rgb)?\s*\{\s*([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)\s*\}", block, re.IGNORECASE)
                        rgb = (0,0,0)
                        if c_match:
                            c_type = c_match.group(1)
                            v1, v2, v3 = float(c_match.group(2)), float(c_match.group(3)), float(c_match.group(4))

                            if c_type and c_type.lower() == 'hsv':
                                h = v1 % 1.0
                                r, g, b = colorsys.hsv_to_rgb(h, v2, v3)
                                rgb = (int(r * 255), int(g * 255), int(b * 255))
                            else:
                                rgb = (int(v1), int(v2), int(v3))

                        cap_match = re.search(r"(capital|capital_state)\s*=\s*([A-Za-z0-9_]+)", block)
                        capital = cap_match.group(2) if cap_match else ""
                        return rgb, capital, path
        return None, None, None

    def save_country_definition(self, tag, rgb, capital, filepath, cultures=None, religion=None):
        self.perform_auto_backup()
        if not filepath or not os.path.exists(filepath):
            self.log("[ERROR] Definition file not found to update.", 'error')
            return
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
        match = re.search(r"(^|\s)" + re.escape(tag) + r"\s*=\s*\{", content, re.MULTILINE)
        if match:
            start = match.end() - 1
            _, end = self.find_block_content(content, start)
            if end:
                block = content[start:end]
                new_block = block
                r, g, b = rgb
                if re.search(r"color\s*=", new_block):
                    new_block = re.sub(r"color\s*=\s*\{[^}]+\}", f"color = {{ {r} {g} {b} }}", new_block)
                else:
                    new_block = new_block[:new_block.rfind('}')] + f"\n\tcolor = {{ {r} {g} {b} }}\n}}"
                if capital:
                    if re.search(r"(capital|capital_state)\s*=", new_block):
                         new_block = re.sub(r"(capital|capital_state)\s*=\s*[A-Za-z0-9_]+", f"capital = {capital}", new_block)
                    else:
                         new_block = new_block[:new_block.rfind('}')] + f"\n\tcapital = {capital}\n}}"
                if cultures:
                    # cultures is a list of strings
                    c_str = " ".join(cultures)
                    if re.search(r"cultures\s*=", new_block):
                         new_block = re.sub(r"cultures\s*=\s*\{[^}]+\}", f"cultures = {{ {c_str} }}", new_block)
                    else:
                         new_block = new_block[:new_block.rfind('}')] + f"\n\tcultures = {{ {c_str} }}\n}}"
                if religion:
                    if re.search(r"religion\s*=", new_block):
                         new_block = re.sub(r"religion\s*=\s*[A-Za-z0-9_]+", f"religion = {religion}", new_block)
                    else:
                         new_block = new_block[:new_block.rfind('}')] + f"\n\treligion = {religion}\n}}"

                content = content[:start] + new_block + content[end:]
                with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
                self.log(f"[SAVE] Updated definitions in {filepath}", 'success')

    def load_character_template(self, template_name):
        tmpl_dir = os.path.join(self.mod_path, "common", "character_templates")
        if not os.path.exists(tmpl_dir): return None
        for root, _, files in os.walk(tmpl_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Search for template = { ... }
                # Using regex to find start, then block helper
                m = re.search(r"(^|\s)" + re.escape(template_name) + r"\s*=\s*\{", content, re.IGNORECASE)
                if m:
                    start = m.end() - 1
                    _, end = self.find_block_content(content, start)
                    if end:
                        block = content[start:end]
                        data = {"first": "", "last": "", "ig": "", "ideology": "", "is_ruler": False}
                        if re.search(r"ruler\s*=\s*yes", block, re.IGNORECASE): data["is_ruler"] = True

                        fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block)
                        if fn: data["first"] = fn.group(1) if fn.group(1) else fn.group(2)

                        ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block)
                        if ln: data["last"] = ln.group(1) if ln.group(1) else ln.group(2)

                        ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', block)
                        if ig: data["ig"] = ig.group(1)

                        ideo = re.search(r'(trait|ideology)\s*=\s*(ideology_[A-Za-z0-9_]+)', block)
                        if ideo: data["ideology"] = ideo.group(2)

                        return data
        return None

    def load_country_history_details(self, tag):
        info = { "gov_type": "monarchy", "laws": [], "ruler": {"first": "", "last": "", "ig": "", "ideology": ""} }
        clean_tag = tag.replace("c:", "").strip()

        # 1. Load Laws/Gov from history/countries
        hist_dir = os.path.join(self.mod_path, "common", "history", "countries")
        if os.path.exists(hist_dir):
            for root, _, files in os.walk(hist_dir):
                for file in files:
                    if not file.endswith(".txt"): continue
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(path, 'r', encoding='utf-8') as f: content = f.read()

                    idx = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                        if not s: break
                        block = content[s:e]
                        laws = re.findall(r"activate_law\s*=\s*([A-Za-z0-9_:]+)", block)
                        info["laws"].extend(laws)

                        # Also check for inline rulers here (legacy/simple mod support)
                        char_idx = 0
                        while True:
                            m = re.search(r"create_character\s*=\s*\{", block[char_idx:], re.IGNORECASE)
                            if not m: break
                            abs_start = char_idx + m.start()
                            bs, be = self.find_block_content(block, char_idx + m.end() - 1)
                            if bs:
                                char_block = block[bs:be]
                                if re.search(r"ruler\s*=\s*yes", char_block, re.IGNORECASE):
                                    fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', char_block)
                                    ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', char_block)
                                    ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', char_block)
                                    ideo = re.search(r'trait\s*=\s*(ideology_[A-Za-z0-9_]+)', char_block)
                                    if fn: info["ruler"]["first"] = fn.group(1) if fn.group(1) else fn.group(2)
                                    if ln: info["ruler"]["last"] = ln.group(1) if ln.group(1) else ln.group(2)
                                    if ig: info["ruler"]["ig"] = ig.group(1)
                                    if ideo: info["ruler"]["ideology"] = ideo.group(1)
                                char_idx = be
                            else: break
                        idx = e

        # 2. Check history/characters for templates (Overwrites inline if found)
        char_hist_dir = os.path.join(self.mod_path, "common", "history", "characters")
        if os.path.exists(char_hist_dir):
            for root, _, files in os.walk(char_hist_dir):
                for file in files:
                    if not file.endswith(".txt"): continue
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(path, 'r', encoding='utf-8') as f: content = f.read()

                    idx = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                        if not s: break
                        block = content[s:e]

                        # Scan for create_character with templates
                        c_cursor = 0
                        while True:
                            m = re.search(r"create_character\s*=\s*\{", block[c_cursor:], re.IGNORECASE)
                            if not m: break
                            start = c_cursor + m.start()
                            bs, be = self.find_block_content(block, c_cursor + m.end() - 1)
                            if bs:
                                inner = block[bs:be]
                                tmpl_match = re.search(r"template\s*=\s*([A-Za-z0-9_.-]+)", inner, re.IGNORECASE)
                                if tmpl_match:
                                    template_name = tmpl_match.group(1)
                                    t_data = self.load_character_template(template_name)
                                    if t_data and t_data["is_ruler"]:
                                        info["ruler"]["first"] = t_data["first"]
                                        info["ruler"]["last"] = t_data["last"]
                                        info["ruler"]["ig"] = t_data["ig"]
                                        info["ruler"]["ideology"] = t_data["ideology"]
                                c_cursor = be
                            else: break
                        idx = e

        # Normalize laws
        info["laws"] = [l.replace("law_type:", "") for l in info["laws"]]

        # 3. Fallback: Check character_templates directly for "country_tag" file if no ruler found yet
        # (This handles cases where history files are hard to parse or missing, but templates exist)
        if not info["ruler"]["first"]:
            tmpl_dir = os.path.join(self.mod_path, "common", "character_templates")
            if os.path.exists(tmpl_dir):
                target_fname = f"country_{clean_tag}"
                for root, _, files in os.walk(tmpl_dir):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        # loose match for filename
                        if target_fname.lower() in file.lower() or clean_tag.lower() in file.lower():
                            path = os.path.join(root, file)
                            try:
                                with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                            except:
                                with open(path, 'r', encoding='utf-8') as f: content = f.read()

                            # Scan all top-level blocks
                            cursor = 0
                            while cursor < len(content):
                                # Find start of a block: KEY = {
                                m = re.search(r"([A-Za-z0-9_.-]+)\s*=\s*\{", content[cursor:])
                                if not m: break
                                start = cursor + m.start()
                                bs, be = self.find_block_content(content, cursor + m.end() - 1)
                                if bs:
                                    block_inner = content[bs:be]
                                    if re.search(r"ruler\s*=\s*yes", block_inner, re.IGNORECASE):
                                        # Found a ruler definition!
                                        fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block_inner)
                                        if fn: info["ruler"]["first"] = fn.group(1) if fn.group(1) else fn.group(2)

                                        ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block_inner)
                                        if ln: info["ruler"]["last"] = ln.group(1) if ln.group(1) else ln.group(2)

                                        ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', block_inner)
                                        if ig: info["ruler"]["ig"] = ig.group(1)

                                        ideo = re.search(r'(trait|ideology)\s*=\s*(ideology_[A-Za-z0-9_]+)', block_inner)
                                        if ideo: info["ruler"]["ideology"] = ideo.group(2)

                                        # Stop after finding the first ruler in the file
                                        break
                                    cursor = be
                                else:
                                    # Should not happen if well formed, but skip forward
                                    cursor = start + 1

                            if info["ruler"]["first"]: break
                    if info["ruler"]["first"]: break

        if "law_monarchy" in info["laws"]: info["gov_type"] = "monarchy"
        elif "law_presidential_republic" in info["laws"] or "law_parliamentary_republic" in info["laws"]: info["gov_type"] = "republic"
        elif "law_theocracy" in info["laws"]: info["gov_type"] = "theocracy"
        return info

    def save_country_history(self, tag, gov_type, laws, ruler_info):
        self.perform_auto_backup()
        hist_dir = os.path.join(self.mod_path, "common", "history", "countries")
        clean_tag = tag.replace("c:", "").strip()
        target_path = None
        target_content = None
        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                    target_path = path; target_content = content; break

        if not target_path: return self.log("[ERROR] No history file found.", 'error')
        s, e = self.get_block_range_safe(target_content, f"c:{clean_tag}")
        if not s: return
        block = target_content[s:e]
        new_block = block

        # Laws
        gov_law = "law_monarchy"
        if gov_type == "republic": gov_law = "law_presidential_republic"
        elif gov_type == "theocracy": gov_law = "law_theocracy"

        laws_to_set = [gov_law] + laws
        if gov_type == "republic": laws_to_set.append("law_appointed_bureaucrats")

        exclusive_laws = [
            ["law_monarchy", "law_presidential_republic", "law_parliamentary_republic", "law_theocracy", "law_council_republic"],
            ["law_interventionism", "law_laissez_faire", "law_command_economy", "law_traditionalism", "law_agrarianism"],
            ["law_free_trade", "law_protectionism", "law_isolationism", "law_mercantilism"],
            ["law_autocracy", "law_oligarchy", "law_landed_voting", "law_wealth_voting", "law_census_voting", "law_universal_suffrage", "law_anarchy", "law_single_party_state"]
        ]

        for law in laws_to_set:
            # Remove conflicting
            for group in exclusive_laws:
                if law in group:
                    for ex in group:
                        if ex != law:
                            new_block = re.sub(r"\s*activate_law\s*=\s*(law_type:)?" + re.escape(ex) + r"\b", "", new_block)

            # Add if missing
            if not re.search(r"activate_law\s*=\s*(law_type:)?" + re.escape(law), new_block):
                 new_block = new_block[:new_block.rfind('}')] + f"\n\t\tactivate_law = law_type:{law}\n\t}}"

        # Ruler
        char_idx = 0
        ruler_start = -1; ruler_end = -1
        while True:
            m = re.search(r"create_character\s*=\s*\{", new_block[char_idx:])
            if not m: break
            abs_start = char_idx + m.start()
            bs, be = self.find_block_content(new_block, char_idx + m.end() - 1)
            if bs:
                sub = new_block[bs:be]
                if "ruler = yes" in sub: ruler_start = abs_start; ruler_end = be; break
                char_idx = be
            else: break

        if ruler_start != -1:
            # Update existing inline ruler
            rb = new_block[ruler_start:ruler_end]
            if ruler_info["first"]: rb = re.sub(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', f'first_name = "{ruler_info["first"]}"', rb)
            if ruler_info["last"]: rb = re.sub(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', f'last_name = "{ruler_info["last"]}"', rb)
            if ruler_info["ig"]: rb = re.sub(r'interest_group\s*=\s*[A-Za-z0-9_]+', f'interest_group = {ruler_info["ig"]}', rb)
            if ruler_info["ideology"]:
                rb = re.sub(r'\s*trait\s*=\s*ideology_[a-z_]+', '', rb)
                rb = rb[:rb.rfind('}')] + f"\n\t\ttrait = {ruler_info['ideology']}\n\t}}"
            new_block = new_block[:ruler_start] + rb + new_block[ruler_end:]
        else:
            # Create new ruler block if none found (overrides/adds to vanilla)
            # Default birth_date needed if creating fresh
            new_ruler_block = f"""
        create_character = {{
            first_name = "{ruler_info['first']}"
            last_name = "{ruler_info['last']}"
            birth_date = 1800.1.1
            ruler = yes
            interest_group = {ruler_info['ig']}
            trait = {ruler_info['ideology']}
        }}"""
            # Insert before closing brace of country block
            new_block = new_block[:new_block.rfind('}')] + new_ruler_block + "\n\t}"

        target_content = target_content[:s] + new_block + target_content[e:]
        with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(target_content)
        self.log(f"[SAVE] History updated in {target_path}", 'success')

    # --- DIPLOMACY LOGIC ---
    # --- DIPLOMACY LOGIC ---
    SUBJECT_TYPES = ["colony", "puppet", "dominion", "protectorate", "tributary", "vassal", "personal_union"]

    def find_and_remove_subject_status(self, tag_to_free):
        """Scans all diplomacy files and removes any subject pact where tag_to_free is the target."""
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        if not os.path.exists(dip_dir): return
        clean_target = tag_to_free.replace("c:", "").strip()

        for root, _, files in os.walk(dip_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                original_content = content
                file_changed = False

                # We need to scan ALL country blocks, because any country could be the overlord
                idx = 0
                while True:
                    # Find next country block
                    match = re.search(r"c:([A-Za-z0-9_]+)\s*\??=\s*\{", content[idx:])
                    if not match: break

                    overlord_tag = match.group(1)
                    abs_start = idx + match.start()
                    s, e = self.find_block_content(content, idx + match.end() - 1)

                    if s:
                        block_body = content[s:e]

                        # Check for subject pacts targeting our tag
                        # create_diplomatic_pact = { country = c:TARGET type = TYPE }
                        new_body_parts = []
                        cursor = 0
                        block_changed = False

                        while cursor < len(block_body):
                            m = re.search(r"create_diplomatic_pact\s*=\s*\{", block_body[cursor:])
                            if not m:
                                new_body_parts.append(block_body[cursor:])
                                break

                            pact_start = cursor + m.start()
                            new_body_parts.append(block_body[cursor:pact_start])

                            bs, be = self.find_block_content(block_body, cursor + m.end() - 1)
                            if bs:
                                pact_inner = block_body[bs:be]
                                is_target = re.search(r"country\s*=\s*c:" + re.escape(clean_target) + r"\b", pact_inner)

                                type_match = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", pact_inner)
                                pact_type = type_match.group(1) if type_match else ""

                                if is_target and pact_type in self.SUBJECT_TYPES:
                                    # This is the pact to remove!
                                    self.log(f"[DIP] Freed {clean_target} from being a {pact_type} of {overlord_tag}", 'warn')
                                    block_changed = True
                                else:
                                    new_body_parts.append(block_body[pact_start:be])
                                cursor = be
                            else:
                                new_body_parts.append(block_body[pact_start:])
                                break

                        if block_changed:
                            # Reconstruct the country block
                            new_block_body = "".join(new_body_parts)
                            # Replace in content (careful with indices, content hasn't changed length yet in loop but we are rebuilding)
                            # To handle this safely in a loop, we usually do one pass or complex offset tracking.
                            # Simpler: If changed, update 'content' and restart loop or adjust offsets?
                            # Since we are iterating top-level blocks, replacing 'content' invalidates 'idx'.

                            # Strategy: Reconstruct the whole file content after processing all blocks?
                            # Or just update this block and update 'e'.

                            # Let's splice it in now
                            prefix = content[:s]
                            suffix = content[e:]
                            content = prefix + new_block_body + suffix
                            file_changed = True

                            # Update e to reflect new length
                            diff = len(new_block_body) - len(block_body)
                            e += diff

                        idx = e
                    else:
                        idx = abs_start + 1 # Should not happen if regex matched

                if file_changed:
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write(content)

    def load_diplomacy_data(self, tag):
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        info = { "subjects": [], "rivals": [], "embargos": [], "truces": [], "relations": [] }
        if not os.path.exists(dip_dir): return info
        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(dip_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                idx = 0
                while True:
                    s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                    if not s: break
                    block = content[s:e]

                    # Subjects
                    for m in re.finditer(r"create_diplomatic_pact\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        typ = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", inner)
                        if cty and typ:
                            if typ.group(1) in ["rivalry", "embargo"]: continue # Handled elsewhere usually, but check file
                            info["subjects"].append({"target": cty.group(1), "type": typ.group(1)})

                    # Rivals/Embargos (often same structure as pact)
                    # Check filename or explicit types if they are pacts
                    if "rival" in file or "embargo" in file:
                         for m in re.finditer(r"create_diplomatic_pact\s*=\s*\{([^}]+)\}", block):
                            inner = m.group(1)
                            cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                            typ = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", inner)
                            if cty and typ:
                                if typ.group(1) == "rivalry": info["rivals"].append(cty.group(1))
                                elif typ.group(1) == "embargo": info["embargos"].append(cty.group(1))

                    # Truces
                    for m in re.finditer(r"create_bidirectional_truce\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        dur = re.search(r"months\s*=\s*(\d+)", inner)
                        if cty:
                            info["truces"].append({"target": cty.group(1), "months": dur.group(1) if dur else "12"})

                    # Relations
                    for m in re.finditer(r"set_relations\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        val = re.search(r"value\s*=\s*(-?\d+)", inner)
                        if cty and val:
                            info["relations"].append({"target": cty.group(1), "value": val.group(1)})

                    idx = e
        return info

    def add_diplomatic_pact(self, tag, target, pact_type, category):
        self.perform_auto_backup()
        # category: subject, rival, embargo, truce
        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        # VALIDATION: If creating a subject, ensure no conflicts
        if category == "subject":
            # 1. Target cannot already be a subject
            self.find_and_remove_subject_status(clean_target)
            # 2. Actor (Overlord) cannot be a subject themselves
            self.find_and_remove_subject_status(clean_tag)

        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        os.makedirs(dip_dir, exist_ok=True)
        filename = "00_subject_relationships.txt"
        if category == "rival": filename = "00_rivalries.txt"
        elif category == "embargo": filename = "00_embargos.txt"
        elif category == "truce": filename = "00_truces.txt"

        filepath = os.path.join(dip_dir, filename)
        if not os.path.exists(filepath):
             with open(filepath, 'w', encoding='utf-8-sig') as f: f.write("DIPLOMACY = {\n}")

        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()

        # Build entry
        entry = ""
        if category == "truce":
             entry = f"\t\tcreate_bidirectional_truce = {{ country = c:{clean_target} months = 60 }}"
        else:
             entry = f"\t\tcreate_diplomatic_pact = {{ country = c:{clean_target} type = {pact_type} }}"

        # Insert
        s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
        if s:
            # Append to existing block
            block = content[s:e]
            new_block = block[:block.rfind('}')] + "\n" + entry + "\n\t}"
            content = content[:s] + new_block + content[e:]
        else:
            # Create new block
            # Find DIPLOMACY block
            d_s, d_e = self.get_block_range_safe(content, "DIPLOMACY")
            if d_s:
                new_block = f"\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}"
                content = content[:d_e-1] + new_block + "\n}" + content[d_e:]
            else:
                content += f"\nDIPLOMACY = {{\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}\n}}"

        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[DIP] Added {pact_type} with {clean_target} in {filename}", 'success')

    def remove_diplomatic_pact(self, tag, target, pact_type):
        self.perform_auto_backup()
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        files_to_check = ["00_subject_relationships.txt", "00_rivalries.txt", "00_embargos.txt", "00_truces.txt"]

        for fname in files_to_check:
            fpath = os.path.join(dip_dir, fname)
            if not os.path.exists(fpath): continue

            try:
                with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
            except:
                with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

            s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
            if not s: continue

            block = content[s:e]

            # Regex to match the specific pact
            # Need to match { ... country = c:TARGET ... type = TYPE } across lines
            # This is hard with regex alone.

            # Simple approach: Find block start, verify content, remove.
            # Using block finder again inside.

            new_inner_parts = []
            cursor = 0
            # Skip header "c:TAG ?= {"
            header_len = content[s:].find('{') + 1
            inner_body = block[header_len:-1]

            change_made = False

            while cursor < len(inner_body):
                m = re.search(r"(create_diplomatic_pact|create_bidirectional_truce)\s*=\s*\{", inner_body[cursor:])
                if not m:
                    new_inner_parts.append(inner_body[cursor:])
                    break

                abs_start = cursor + m.start()
                new_inner_parts.append(inner_body[cursor:abs_start])

                bs, be = self.find_block_content(inner_body, cursor + m.end() - 1)
                if bs:
                    pact_block = inner_body[bs:be]

                    # Check if this is the one to delete
                    is_target = f"c:{clean_target}" in pact_block
                    is_type = (pact_type in pact_block) if pact_type != "truce" else True # Truce doesn't have type field usually

                    if is_target and is_type:
                        change_made = True
                        # Skip this block (don't append)
                    else:
                        new_inner_parts.append(inner_body[abs_start:be])
                    cursor = be
                else:
                    new_inner_parts.append(inner_body[abs_start:])
                    break

            if change_made:
                new_block = block[:header_len] + "".join(new_inner_parts) + "}"
                content = content[:s] + new_block + content[e:]
                with open(fpath, 'w', encoding='utf-8-sig') as f: f.write(content)
                self.log(f"[DIP] Removed {pact_type} with {clean_target} from {fname}", 'success')

    def set_relations(self, tag, target, value):
        self.perform_auto_backup()
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        os.makedirs(dip_dir, exist_ok=True)
        fpath = os.path.join(dip_dir, "00_relations.txt")
        if not os.path.exists(fpath):
             with open(fpath, 'w', encoding='utf-8-sig') as f: f.write("DIPLOMACY = {\n}")

        try:
            with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        # We need to remove existing set_relations for this target first
        s, e = self.get_block_range_safe(content, f"c:{clean_tag}")

        entry = f"\t\tset_relations = {{ country = c:{clean_target} value = {value} }}"

        if s:
            block = content[s:e]
            # Remove existing relation to target
            # Regex: set_relations = { country = c:TARGET value = ... }
            block = re.sub(r"set_relations\s*=\s*\{[^}]*c:" + re.escape(clean_target) + r"\b[^}]*\}", "", block)
            # Append new
            new_block = block[:block.rfind('}')] + "\n" + entry + "\n\t}"
            content = content[:s] + new_block + content[e:]
        else:
             # Create new block
            d_s, d_e = self.get_block_range_safe(content, "DIPLOMACY")
            if d_s:
                new_block = f"\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}"
                content = content[:d_e-1] + new_block + "\n}" + content[d_e:]
            else:
                content += f"\nDIPLOMACY = {{\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}\n}}"

        with open(fpath, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[DIP] Relations set to {value} with {clean_target}", 'success')

    # --- MOD MANAGER LOGIC ---
    def copy_tree_content(self, src, dst):
        """Recursively copies content of src folder to dst folder."""
        if not os.path.exists(src):
            self.log(f"[WARN] Source path does not exist: {src}", 'warn')
            return
        os.makedirs(dst, exist_ok=True)
        for item in os.listdir(src):
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            if os.path.isdir(s):
                if not os.path.exists(d): os.makedirs(d)
                self.copy_tree_content(s, d)
            else:
                shutil.copy2(s, d)

    def create_new_mod(self, name, location):
        if not name or not location:
            self.log("[ERROR] Mod name and location required.", 'error')
            return False

        mod_root = os.path.join(location, name)
        if os.path.exists(mod_root):
            self.log(f"[ERROR] Directory already exists: {mod_root}", 'error')
            return False

        try:
            os.makedirs(mod_root)
            meta_dir = os.path.join(mod_root, ".metadata")
            os.makedirs(meta_dir)

            metadata = {
                "name" : name,
                "id" : "",
                "version" : "",
                "supported_game_version" : "",
                "short_description" : "",
                "tags" : [],
                "relationships" : [],
                "game_custom_data" : {
                    "multiplayer_synchronized" : True
                }
            }

            with open(os.path.join(meta_dir, "metadata.json"), 'w') as f:
                json.dump(metadata, f, indent=4)

            self.log(f"[SUCCESS] Created new mod structure at {mod_root}", 'success')

            self.set_mod_path(mod_root)
            return True

        except Exception as e:
            self.log(f"[ERROR] Failed to create mod: {e}", 'error')
            traceback.print_exc()
            return False

    def copy_vanilla_files(self, vanilla_path, mod_path):
        """Copies the list of necessary default files and folders from vanilla."""
        if not vanilla_path or not os.path.exists(vanilla_path):
            self.log("[ERROR] Vanilla path invalid or not set.", 'error')
            return

        # Handle 'game' subdirectory if user selected root install folder
        game_dir = os.path.join(vanilla_path, "game")
        if os.path.exists(game_dir):
            base_src = game_dir
        else:
            base_src = vanilla_path

        # List of items to copy. Tuple: (path, is_recursive)
        # Note: localization/English/countries_l_english -> localization/english/countries_l_english.yml
        # Note: common/character_templates* -> is_recursive=True

        items = [
            ("localization/english/countries_l_english.yml", False),
            ("common/character_templates", True),
            ("common/coat_of_arms", True),
            ("common/country_definitions", True),
            ("common/cultures", True),
            ("common/strategic_regions", True),
            ("common/history/buildings", True),
            ("common/history/characters", True),
            ("common/history/countries", True),
            ("common/history/diplomacy", True),
            ("common/history/military_formations", True),
            ("common/history/pops", True),
            ("common/history/population", True),
            ("common/history/states", True),
            ("common/history/trade", True),
            ("common/history/power_blocs", True),
            ("common/religions", True),
            ("common/journal_entries", True),
            ("common/laws", True),
            ("common/technology/technologies", True),
            ("common/buildings", True)
        ]

        copied_count = 0
        for rel_path, recursive in items:
            # Handle potential case sensitivity or slight path variations manually if needed
            # Assuming standard structure here.
            src = os.path.join(base_src, rel_path)
            dst = os.path.join(mod_path, rel_path)

            if not os.path.exists(src):
                # Try lower case for English path if failed
                if "English" in rel_path or "english" in rel_path:
                    alt_path = rel_path.replace("English", "english")
                    src = os.path.join(base_src, alt_path)

            if not os.path.exists(src):
                self.log(f"[WARN] Skipped missing vanilla path: {rel_path}", 'warn')
                continue

            try:
                if recursive:
                    if os.path.isdir(src):
                        self.copy_tree_content(src, dst)
                        copied_count += 1
                    else:
                        self.log(f"[WARN] Expected folder but found file: {rel_path}", 'warn')
                else:
                    # File copy
                    os.makedirs(os.path.dirname(dst), exist_ok=True)
                    shutil.copy2(src, dst)
                    copied_count += 1
            except Exception as e:
                self.log(f"[ERROR] Failed to copy {rel_path}: {e}", 'error')

        self.log(f"[SUCCESS] Copied {copied_count} items from vanilla.", 'success')

    def backup_mod(self, mod_path):
        """Creates a numbered backup of the current mod."""
        if not mod_path or not os.path.exists(mod_path):
            self.log("[ERROR] Current mod path invalid.", 'error')
            return

        parent_dir = os.path.dirname(mod_path)
        mod_dirname = os.path.basename(mod_path)

        # Scan for existing backups
        idx = 1
        while True:
            backup_name = f"{mod_dirname}_backup_{idx}"
            backup_path = os.path.join(parent_dir, backup_name)
            if not os.path.exists(backup_path):
                break
            idx += 1

        target_backup_path = os.path.join(parent_dir, f"{mod_dirname}_backup_{idx}")

        try:
            self.log(f"[BACKUP] Creating backup at {target_backup_path}...", 'info')
            shutil.copytree(mod_path, target_backup_path)
            self.log(f"[SUCCESS] Backup created: {os.path.basename(target_backup_path)}", 'success')
        except Exception as e:
            self.log(f"[ERROR] Backup failed: {e}", 'error')

    def perform_auto_backup(self):
        """Creates or overwrites the auto-backup folder if enabled."""
        if not self.auto_backup_enabled or not self.mod_path or not os.path.exists(self.mod_path):
            return

        parent_dir = os.path.dirname(self.mod_path)
        mod_dirname = os.path.basename(self.mod_path)
        backup_name = f"{mod_dirname}_autobackup"
        backup_path = os.path.join(parent_dir, backup_name)

        try:
            # We want to replace contents. efficient way: rmtree then copytree
            # Or copytree with dirs_exist_ok=True (Python 3.8+)
            if os.path.exists(backup_path):
                shutil.rmtree(backup_path)

            shutil.copytree(self.mod_path, backup_path)
            self.log(f"[AUTO-BACKUP] Updated {backup_name}", 'success')
        except Exception as e:
            self.log(f"[ERROR] Auto-backup failed: {e}", 'error')

    # --- RELIGION & CULTURE LOGIC ---
    def scan_culture_definitions(self):
        """Scans vanilla 00_cultures.txt for options."""
        if not self.vanilla_path: return {}, [], [], [], [], []

        # Try both game/common and common
        base = os.path.join(self.vanilla_path, "game", "common", "cultures")
        if not os.path.exists(base):
             base = os.path.join(self.vanilla_path, "common", "cultures")

        fpath = os.path.join(base, "00_cultures.txt")
        if not os.path.exists(fpath): return {}, [], [], [], [], []

        heritages = set()
        languages = set()
        traditions = set()
        graphics = set()
        ethnicities = set()
        culture_data = {}

        try:
            with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
             with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

        cursor = 0
        while True:
            m = re.search(r"^([a-z0-9_]+)\s*=\s*\{", content[cursor:], re.MULTILINE)
            if not m: break
            key = m.group(1)
            start = cursor + m.start()
            s, e = self.find_block_content(content, cursor + m.end() - 1)

            if s:
                block = content[s:e]
                h = re.search(r"heritage\s*=\s*([a-z0-9_]+)", block);
                if h: heritages.add(h.group(1))
                l = re.search(r"language\s*=\s*([a-z0-9_]+)", block);
                if l: languages.add(l.group(1))
                g = re.search(r"graphics\s*=\s*([a-z0-9_]+)", block);
                if g: graphics.add(g.group(1))

                tm = re.search(r"traditions\s*=\s*\{", block)
                if tm:
                    ts, te = self.find_block_content(block, tm.end()-1)
                    if ts:
                        # Use inner content to avoid adding braces to list
                        for t in block[ts+1:te-1].split():
                            t_clean = t.strip()
                            if t_clean and not t_clean.startswith("#"): traditions.add(t_clean)

                em = re.search(r"ethnicities\s*=\s*\{", block)
                if em:
                    es, ee = self.find_block_content(block, em.end()-1)
                    if es:
                        for ematch in re.finditer(r"=\s*([a-z0-9_]+)", block[es:ee]): ethnicities.add(ematch.group(1))

                names = {}
                for list_name in ["male_common_first_names", "female_common_first_names", "noble_last_names", "common_last_names", "male_regal_first_names", "female_regal_first_names"]:
                    lm = re.search(list_name + r"\s*=\s*\{", block)
                    if lm:
                        ls, le = self.find_block_content(block, lm.end()-1)
                        # Store inner content only to avoid double bracing on save
                        if ls: names[list_name] = block[ls+1:le-1].strip()
                culture_data[key] = names
                cursor = e
            else:
                cursor = start + 1

        return culture_data, sorted(list(heritages)), sorted(list(languages)), sorted(list(traditions)), sorted(list(graphics)), sorted(list(ethnicities))

    def scan_all_religions_and_heritages(self):
        paths = []
        if self.vanilla_path:
             paths.append(os.path.join(self.vanilla_path, "game", "common", "religions"))
             paths.append(os.path.join(self.vanilla_path, "common", "religions"))
        if self.mod_path:
             paths.append(os.path.join(self.mod_path, "common", "religions"))

        religions = set()
        heritages = set()

        for p in paths:
            if not os.path.exists(p): continue
            for root, _, files in os.walk(p):
                for file in files:
                    if not file.endswith(".txt"): continue
                    try:
                        with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                    cursor = 0
                    while True:
                        m = re.search(r"^([a-z0-9_]+)\s*=\s*\{", content[cursor:], re.MULTILINE)
                        if not m: break
                        key = m.group(1)
                        if key.lower() not in ["technically", "random"]: religions.add(key)

                        start = cursor + m.start()
                        s, e = self.find_block_content(content, cursor + m.end()-1)
                        if s:
                             h = re.search(r"heritage\s*=\s*([a-z0-9_]+)", content[s:e])
                             if h: heritages.add(h.group(1))
                             cursor = e
                        else:
                             cursor = start + 1
        return sorted(list(religions)), sorted(list(heritages))

    def save_new_culture(self, key, name, color, religion, heritage, language, traditions, graphics, ethnicities, name_data):
        self.perform_auto_backup()
        mod_name = os.path.basename(self.mod_path)

        # 1. Definitions
        cul_dir = os.path.join(self.mod_path, "common", "cultures")
        os.makedirs(cul_dir, exist_ok=True)
        fpath = os.path.join(cul_dir, f"{mod_name}_cultures.txt")

        # Build block
        t_str = " ".join(traditions)

        eth_str = ""
        for i, eth in enumerate(ethnicities):
            eth_str += f"\t\t10 = {eth}\n" # Default weight 10

        name_keys = ["male_common_first_names", "female_common_first_names", "noble_last_names", "common_last_names", "male_regal_first_names", "female_regal_first_names"]
        names_block = ""
        for k in name_keys:
            v = name_data.get(k, "")
            names_block += f"\t{k} = {{ {v} }}\n"

        content_block = f"""
{key} = {{
\tcolor = rgb{{ {color[0]} {color[1]} {color[2]} }}
\treligion = {religion}
\theritage = {heritage}
\tlanguage = {language}
\ttraditions = {{ {t_str} }}
\tgraphics = {graphics}
\tobsessions = {{}}
\tethnicities = {{
{eth_str}\t}}
{names_block}}}
"""
        # Append or Create
        mode = 'a' if os.path.exists(fpath) else 'w'
        try:
            with open(fpath, mode, encoding='utf-8-sig') as f:
                if mode == 'a': f.write("\n")
                f.write(content_block)
        except Exception as e:
            self.log(f"[ERROR] Failed to save culture: {e}", 'error')
            return

        # 2. Localization
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        os.makedirs(loc_dir, exist_ok=True)
        lpath = os.path.join(loc_dir, f"{mod_name}_cultures_l_english.yml")

        if not os.path.exists(lpath):
             with open(lpath, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        with open(lpath, 'a', encoding='utf-8-sig') as f:
            f.write(f' {key}:0 "{name}"\n')

        self.log(f"[SUCCESS] Saved culture {key}", 'success')

    def save_new_religion(self, key, name, color, heritage, icon_path):
        self.perform_auto_backup()
        mod_name = os.path.basename(self.mod_path)

        # 1. Definitions
        rel_dir = os.path.join(self.mod_path, "common", "religions")
        os.makedirs(rel_dir, exist_ok=True)
        fpath = os.path.join(rel_dir, f"{mod_name}_religions.txt")

        r, g, b = color[0]/255.0, color[1]/255.0, color[2]/255.0

        content_block = f"""
{key} = {{
\ticon = "{icon_path}"
\theritage = {heritage}
\tcolor = {{ {r:.2f} {g:.2f} {b:.2f} }}
}}
"""
        mode = 'a' if os.path.exists(fpath) else 'w'
        try:
            with open(fpath, mode, encoding='utf-8-sig') as f:
                if mode == 'a': f.write("\n")
                f.write(content_block)
        except Exception as e:
            self.log(f"[ERROR] Failed to save religion: {e}", 'error')
            return

        # 2. Localization
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        os.makedirs(loc_dir, exist_ok=True)
        lpath = os.path.join(loc_dir, f"{mod_name}_religions_l_english.yml")

        if not os.path.exists(lpath):
             with open(lpath, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        with open(lpath, 'a', encoding='utf-8-sig') as f:
            f.write(f' {key}:0 "{name}"\n')

        self.log(f"[SUCCESS] Saved religion {key}", 'success')

    # --- POWER BLOC LOGIC ---
    def get_all_power_blocs(self):
        """Scans history/global for existing power blocs."""
        blocs = []
        hist_dir = os.path.join(self.mod_path, "common/history/power_blocs")
        if not os.path.exists(hist_dir): return blocs

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # We look for c:TAG ?= { ... create_power_bloc = { name = XXX ... } ... }
                idx = 0
                while True:
                    m = re.search(r"c:([A-Za-z0-9_]+)\s*\??=\s*\{", content[idx:])
                    if not m: break
                    tag = m.group(1)
                    start = idx + m.start()
                    _, end = self.find_block_content(content, idx + m.end() - 1)
                    if end:
                        block = content[start:end]
                        pb_match = re.search(r"create_power_bloc\s*=\s*\{", block)
                        if pb_match:
                            # Extract name
                            pb_start = pb_match.start()
                            _, pb_end = self.find_block_content(block, pb_match.end() - 1)
                            if pb_end:
                                pb_block = block[pb_start:pb_end]
                                name_m = re.search(r"name\s*=\s*([A-Za-z0-9_]+)", pb_block)
                                name = name_m.group(1) if name_m else "Unknown"
                                blocs.append({"tag": tag, "name": name})
                        idx = end
                    else:
                        idx = start + 1
        return blocs

    PB_IDENTITIES = [
        "identity_trade_league",
        "identity_sovereign_empire",
        "identity_ideological_union",
        "identity_military_treaty_organization",
        "identity_religious",
        "identity_cultural"
    ]

    PB_EXCLUSIVE_PRINCIPLES = {
        "identity_trade_league": ["principle_internal_trade", "principle_external_trade"],
        "identity_sovereign_empire": ["principle_vassalization", "principle_exploit_members"],
        "identity_ideological_union": ["principle_ideological_truth", "principle_creative_legislature"],
        "identity_religious": ["principle_divine_economics", "principle_sacred_civics"],
        "identity_military_treaty_organization": ["principle_aggressive_coordination", "principle_defensive_cooperation"],
        "identity_cultural": ["principle_shared_canon"]
    }

    PB_GLOBAL_PRINCIPLES = [
        "principle_construction",
        "principle_foreign_investment",
        "principle_police_coordination",
        "principle_freedom_of_movement",
        "principle_food_standardization",
        "principle_advanced_research",
        "principle_colonial_offices",
        "principle_transport",
        "principle_military_industry",
        "principle_market_unification",
        "principle_companies"
    ]

    PB_PRIMARY_PRINCIPLE_OPTIONS = {
        "identity_trade_league": [
            "principle_external_trade",
            "principle_internal_trade"
        ],
        "identity_sovereign_empire": [
            "principle_vassalization",
            "principle_exploit_members"
        ],
        "identity_ideological_union": [
            "principle_creative_legislature",
            "principle_ideological_truth"
        ],
        "identity_religious": [
            "principle_divine_economics",
            "principle_sacred_civics"
        ],
        "identity_military_treaty_organization": [
            "principle_defensive_cooperation",
            "principle_aggressive_coordination"
        ],
        "identity_cultural": [
            "principle_shared_canon",
            "principle_freedom_of_movement"
        ]
    }

    def get_power_bloc_data(self, tag):
        """Parses power bloc data for a specific tag from history/global."""
        clean_tag = tag.replace("c:", "").strip()
        hist_dir = os.path.join(self.mod_path, "common/history/power_blocs")
        if not os.path.exists(hist_dir): return None

        data = {
            "name": "", "identity": "", "map_color": "", "date": "1836.1.1", "principles": [], "members": []
        }

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
                if s is not None:
                    block = content[s:e]
                    pb_match = re.search(r"create_power_bloc\s*=\s*\{", block)
                    if pb_match:
                        # Found it!
                        pb_s, pb_e = self.find_block_content(block, pb_match.end() - 1)
                        if pb_s:
                            pb_inner = block[pb_s:pb_e]

                            nm = re.search(r"name\s*=\s*([A-Za-z0-9_]+)", pb_inner)
                            if nm: data["name"] = nm.group(1)

                            im = re.search(r"identity\s*=\s*([A-Za-z0-9_]+)", pb_inner)
                            if im: data["identity"] = im.group(1)

                            dm = re.search(r"founding_date\s*=\s*([\d\.]+)", pb_inner)
                            if dm: data["date"] = dm.group(1)

                            # Map Color - capture whole value block or string
                            cm = re.search(r"map_color\s*=\s*(\{.+?\}|hsv\s*\{.+?\})", pb_inner, re.DOTALL)
                            if cm:
                                data["map_color"] = " ".join(cm.group(1).split()) # Normalize whitespace

                            # Members
                            mem_matches = re.finditer(r"member\s*=\s*([A-Za-z0-9_:]+)", pb_inner)
                            for mm in mem_matches:
                                data["members"].append(mm.group(1))

                            # Primary Principle
                            pm = re.search(r"principle\s*=\s*([A-Za-z0-9_]+)", pb_inner)
                            if pm:
                                full = pm.group(1)
                                m_lev = re.match(r"(.*)_(\d+)$", full)
                                if m_lev:
                                    data["principles"].append({"key": m_lev.group(1), "level": int(m_lev.group(2))})
                                else:
                                    data["principles"].append({"key": full, "level": 1})

                            # DLC Principles (sibling `if` block)
                            # We search for 'if = { limit = { has_dlc_feature = power_bloc_features } ... }'
                            # inside the COUNTRY block (sibling to create_power_bloc)

                            # Scan for if blocks
                            cursor = 0
                            while cursor < len(block):
                                if_m = re.search(r"\bif\s*=\s*\{", block[cursor:])
                                if not if_m: break
                                if_start = cursor + if_m.start()
                                if_s, if_e = self.find_block_content(block, cursor + if_m.end() - 1)
                                if if_s:
                                    if_inner = block[if_s:if_e]
                                    if "power_bloc_features" in if_inner:
                                        # Check inside for power_bloc = { add_principle = ... }
                                        pb_eff_m = re.search(r"power_bloc\s*=\s*\{", if_inner)
                                        if pb_eff_m:
                                            pe_s, pe_e = self.find_block_content(if_inner, pb_eff_m.end() - 1)
                                            if pe_s:
                                                eff_inner = if_inner[pe_s:pe_e]
                                                # extract all add_principle
                                                for apm in re.finditer(r"add_principle\s*=\s*([A-Za-z0-9_]+)", eff_inner):
                                                    full = apm.group(1)
                                                    m_lev = re.match(r"(.*)_(\d+)$", full)
                                                    if m_lev:
                                                        data["principles"].append({"key": m_lev.group(1), "level": int(m_lev.group(2))})
                                                    else:
                                                        data["principles"].append({"key": full, "level": 1})
                                    cursor = if_e
                                else:
                                    cursor = if_start + 1

                            # De-dupe by key (keep last? or first? usually first is primary)
                            # Actually, list of dicts isn't hashable for set().
                            # We'll just keep them all for now, UI can handle uniqueness validation.
                            return data
        return None

    def save_power_bloc_localization(self, key, value):
        self.perform_auto_backup()
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        os.makedirs(loc_dir, exist_ok=True)
        target_file = os.path.join(loc_dir, "mod_power_blocs_l_english.yml")

        if not os.path.exists(target_file):
            with open(target_file, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        try:
            with open(target_file, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_file, 'r', encoding='utf-8') as f: content = f.read()

        # Escape quotes in value
        safe_value = value.replace('"', '\\"')

        # Check if key exists
        pattern = re.compile(r'^\s*' + re.escape(key) + r':\d?\s*".*"', re.MULTILINE)
        new_line = f' {key}: "{safe_value}"'

        if pattern.search(content):
            content = pattern.sub(new_line, content)
        else:
            if not content.endswith("\n"): content += "\n"
            content += new_line + "\n"

        with open(target_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[SAVE] Power Bloc localization saved to {target_file}", 'success')

    def save_power_bloc_data(self, tag, data):
        """Saves power bloc data to history/global."""
        self.perform_auto_backup()
        hist_dir = os.path.join(self.mod_path, "common/history/power_blocs")
        os.makedirs(hist_dir, exist_ok=True)
        target_file = os.path.join(hist_dir, "00_power_blocs.txt")

        # If file doesn't exist, create it with wrapper
        if not os.path.exists(target_file):
            with open(target_file, 'w', encoding='utf-8-sig') as f: f.write("POWER_BLOCS = {\n}\n")

        try:
            with open(target_file, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_file, 'r', encoding='utf-8') as f: content = f.read()

        clean_tag = tag.replace("c:", "").strip()

        # Sanitize name for key
        raw_name = data['name']
        # Remove special chars, allow alphanumeric and spaces/underscores
        name_key = re.sub(r'[^a-z0-9_ ]', '', raw_name.lower()).strip().replace(" ", "_")
        # Collapse multiple underscores
        name_key = re.sub(r'_+', '_', name_key)

        # Update localization
        self.save_power_bloc_localization(name_key, raw_name)

        # Prepare content strings
        # FIX: Ensure the identity's core required principle is first
        pb_identity = data.get("identity", "")
        req_principles = self.PB_PRIMARY_PRINCIPLE_OPTIONS.get(pb_identity, [])

        principles_sorted = data["principles"][:]
        # Find if any principle is in req_principles
        found_idx = -1
        for i, p in enumerate(principles_sorted):
            if p["key"] in req_principles:
                found_idx = i
                break

        if found_idx > 0:
            # Move to front
            p = principles_sorted.pop(found_idx)
            principles_sorted.insert(0, p)

        princ_strs = [f"{p['key']}_{p['level']}" for p in principles_sorted]

        principle_1 = princ_strs[0] if princ_strs else ""
        extra_principles = princ_strs[1:] if len(princ_strs) > 1 else []

        map_col_str = data["map_color"]
        if not map_col_str: map_col_str = "{ 255 255 255 }"

        # Reconstruct members
        members_list = data.get("members", [])
        # User requested NOT to auto-add leader as member, so we filter it out if present
        filtered_members = [
            m for m in members_list
            if m.replace("c:", "").strip() != clean_tag
        ]

        members_str = "\n\t\t\t".join([f"member = {m}" for m in filtered_members])

        create_block = f"""
\t\tcreate_power_bloc = {{
\t\t\tname = {name_key}
\t\t\tmap_color = {map_col_str}
\t\t\tfounding_date = {data['date']}
\t\t\tidentity = {data['identity']}
\t\t\tprinciple = {principle_1}
\t\t\t{members_str}
\t\t}}"""

        extra_block = ""
        if extra_principles:
            adds = "\n\t\t\t\t".join([f"add_principle = {p}" for p in extra_principles])
            extra_block = f"""
\t\tif = {{
\t\t\tlimit = {{
\t\t\t\thas_dlc_feature = power_bloc_features
\t\t\t}}
\t\t\tpower_bloc = {{
\t\t\t\t{adds}
\t\t\t}}
\t\t}}"""

        # Locate country block
        s, e = self.get_block_range_safe(content, f"c:{clean_tag}")

        if s is not None:
            # Modify existing country block
            block = content[s:e]

            # Remove existing create_power_bloc and if-dlc blocks from within this country block
            # This is tricky with regex. Best to rebuild the block content.
            # We want to preserve other things? Usually nothing else is in c:TAG block in 00_power_blocs.txt except comments/members
            # But users might put stuff there.

            # Strategy: Replace the entire block content with our new content
            # Assuming the user only uses this file for power blocs as per vanilla structure.

            new_inner = create_block + extra_block + "\n"
            new_block = f"c:{clean_tag} ?= {{{new_inner}\t}}"

            content = content[:s] + new_block + content[e:]

        else:
            # Create new country block inside POWER_BLOCS
            # Find POWER_BLOCS wrapper
            pbs, pbe = self.get_block_range_safe(content, "POWER_BLOCS")
            if pbs is not None:
                new_entry = f"\n\tc:{clean_tag} ?= {{{create_block}{extra_block}\n\t}}"
                # Insert before closing brace
                content = content[:pbe-1] + new_entry + "\n}" + content[pbe:]
            else:
                # Wrap everything? Or append?
                content += f"\nPOWER_BLOCS = {{\n\tc:{clean_tag} ?= {{{create_block}{extra_block}\n\t}}\n}}"

        with open(target_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[SAVE] Power Bloc saved for {clean_tag}", 'success')

    def remove_power_bloc(self, tag):
        """Removes power bloc definition for a tag."""
        self.perform_auto_backup()
        hist_dir = os.path.join(self.mod_path, "common/history/power_blocs")
        if not os.path.exists(hist_dir): return
        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
                if s is not None:
                    content = content[:s] + content[e:]
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write(content)
                    self.log(f"[REMOVE] Power Bloc removed for {clean_tag}", 'success')
                    return

    # --- STATE MANAGER LOGIC ---
    def get_state_homelands(self, state_name):
        """Scans history/states for add_homeland lines."""
        # Check mod first, then vanilla
        paths = []
        if self.mod_path: paths.append(os.path.join(self.mod_path, "common/history/states"))
        if self.vanilla_path: paths.append(os.path.join(self.vanilla_path, "game/common/history/states"))

        clean_state = self.format_state_clean(state_name)
        if not clean_state: return None, []

        for p in paths:
            if not os.path.exists(p): continue
            for root, _, files in os.walk(p):
                for file in files:
                    if not file.endswith(".txt"): continue
                    fpath = os.path.join(root, file)
                    try:
                        with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

                    s, e = self.get_block_range_safe(content, f"s:{clean_state}")
                    if s is not None:
                        # Found the state block
                        block = content[s:e]
                        # Extract homelands (allow colons for cu:culture)
                        homelands = re.findall(r"add_homeland\s*=\s*([A-Za-z0-9_:]+)", block)
                        return fpath, list(set(homelands)) # unique
        return None, []

    def save_state_homelands(self, state_name, homelands_list):
        self.perform_auto_backup()
        clean_state = self.format_state_clean(state_name)

        # 1. Find existing file or determine where to create
        fpath, _ = self.get_state_homelands(clean_state)

        if not fpath:
            # Need to copy from vanilla? Or create new?
            # Creating new file for homelands requires defining s:STATE = { ... }
            # If we don't have the original file path, we check vanilla again to copy it.
            if self.vanilla_path:
                v_path = os.path.join(self.vanilla_path, "game/common/history/states")
                for root, _, files in os.walk(v_path):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        vf = os.path.join(root, file)
                        with open(vf, 'r', encoding='utf-8', errors='ignore') as f: c = f.read()
                        if f"s:{clean_state}" in c:
                            # Found in vanilla, copy to mod
                            mod_rel = os.path.relpath(vf, os.path.join(self.vanilla_path, "game"))
                            fpath = os.path.join(self.mod_path, mod_rel)
                            os.makedirs(os.path.dirname(fpath), exist_ok=True)
                            shutil.copy2(vf, fpath)
                            break

            if not fpath:
                # Still not found? Create generic
                fpath = os.path.join(self.mod_path, "common/history/states/99_mod_states.txt")
                os.makedirs(os.path.dirname(fpath), exist_ok=True)
                if not os.path.exists(fpath):
                    with open(fpath, 'w', encoding='utf-8-sig') as f: f.write("STATES = {\n}")

        # 2. Modify file
        try:
            with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

        s, e = self.get_block_range_safe(content, f"s:{clean_state}")

        new_homelands_str = "\n".join([f"\t\tadd_homeland = {h}" for h in homelands_list])

        if s is not None:
            block = content[s:e]
            # Remove existing add_homeland lines
            block = re.sub(r"\s*add_homeland\s*=\s*[A-Za-z0-9_:]+", "", block)
            # Insert new ones before closing brace
            last_brace = block.rfind('}')
            new_block = block[:last_brace] + "\n" + new_homelands_str + "\n\t}"
            content = content[:s] + new_block + content[e:]
        else:
            # Create block if new file
            new_entry = f"\n\ts:{clean_state} = {{\n{new_homelands_str}\n\t}}"
            # Append to STATES block if exists, or append to file
            ss, se = self.get_block_range_safe(content, "STATES")
            if ss is not None:
                content = content[:se-1] + new_entry + "\n}" + content[se:]
            else:
                content += f"\nSTATES = {{{new_entry}\n}}"

        with open(fpath, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[SAVE] Homelands for {clean_state} saved to {os.path.basename(fpath)}", 'success')

    def get_state_pops(self, state_name):
        clean_state = self.format_state_clean(state_name)
        if not clean_state: return []

        # Scan mod folder only? Or vanilla too? Usually we edit what's active.
        # If user wants to edit vanilla pops, we might need to copy file first.
        # But 'pops' logic is usually split.
        # For simplicity, we scan mod + vanilla, but if we edit a vanilla pop, we need to handle file copying.

        pop_dirs = []
        if self.mod_path: pop_dirs.append(os.path.join(self.mod_path, "common/history/pops"))
        if self.vanilla_path: pop_dirs.append(os.path.join(self.vanilla_path, "game/common/history/pops"))

        pops = [] # list of dicts

        for p_dir in pop_dirs:
            if not os.path.exists(p_dir): continue
            is_mod_file = self.mod_path in p_dir

            for root, _, files in os.walk(p_dir):
                for file in files:
                    if not file.endswith(".txt"): continue
                    fpath = os.path.join(root, file)
                    try:
                        with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

                    # Find s:STATE
                    # Note: Need to loop as regex findall doesn't give block contents easily for nested stuff
                    cursor = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"s:{clean_state}", cursor)
                        if s is None: break

                        state_block = content[s:e]
                        state_inner_start = content.find('{', s) + 1

                        # Find region_state:TAG inside
                        rs_cursor = 0
                        while True:
                            m_rs = re.search(r"region_state:([A-Za-z0-9_]+)\s*=\s*\{", state_block[rs_cursor:])
                            if not m_rs: break

                            tag = m_rs.group(1)
                            rs_abs_start = rs_cursor + m_rs.start()
                            rs_s, rs_e = self.find_block_content(state_block, rs_cursor + m_rs.end() - 1)

                            if rs_s:
                                rs_block = state_block[rs_s:rs_e]
                                # Find create_pop inside
                                cp_cursor = 0
                                while True:
                                    m_cp = re.search(r"create_pop\s*=\s*\{", rs_block[cp_cursor:])
                                    if not m_cp: break

                                    cp_s, cp_e = self.find_block_content(rs_block, cp_cursor + m_cp.end() - 1)
                                    if cp_s:
                                        cp_inner = rs_block[cp_s:cp_e]

                                        # Extract values
                                        cul = re.search(r"culture\s*=\s*([A-Za-z0-9_]+)", cp_inner)
                                        rel = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", cp_inner)
                                        size = re.search(r"size\s*=\s*(\d+)", cp_inner)

                                        if cul and size:
                                            # Calculate absolute file indices for the pop block start/end
                                            # This is tricky due to nesting relative offsets
                                            # File -> s:STATE (s) -> region_state (rs_s relative to s) -> create_pop (cp_s relative to rs_s)
                                            # Wait, block ranges are indices into the string passed.

                                            # s is index in 'content'
                                            # rs_s is index in 'state_block' (which starts at s) -> abs = s + rs_s
                                            # cp_s is index in 'rs_block' (which starts at s + rs_s) -> abs = s + rs_s + cp_s

                                            # Actually find_block_content returns indices relative to the text string provided.
                                            # state_block = content[s:e].
                                            # rs_s, rs_e are indices within state_block.

                                            abs_start = s + rs_s + cp_s - len("create_pop = {") # Approx? No, find_block_content gives content inside braces.
                                            # We need the whole block range including "create_pop = { }" to replace it?
                                            # Or just identifying info.

                                            # Let's verify find_block_content return values.
                                            # It returns start (opening brace) and end (closing brace + 1) index.

                                            # To update a pop, we need to uniquely identify it.
                                            # File path + index is good.

                                            # Correct offsets:
                                            # rs_start_in_state = rs_s (start of inner content)
                                            # cp_start_in_rs = cp_s (start of inner content of pop)

                                            # We want the start of "create_pop = {" line effectively.
                                            # Let's store the index of the opening brace of the pop block in the file.

                                            # s: start of state block opening brace (roughly) in content.
                                            # content[s:e] is "s:STATE = { ... }"
                                            # Actually get_block_range_safe returns match.start() (start of "s:STATE") and end brace pos.

                                            # s = start of "s:STATE"
                                            # state_block = content[s:e]

                                            # rs_match in state_block. rs_abs_start relative to state_block.
                                            # rs_s, rs_e = inner content indices relative to state_block.

                                            # cp_match in rs_block (which is state_block[rs_s:rs_e]).
                                            # cp_s, cp_e relative to rs_block.

                                            # Real file index of pop content start = s + rs_s + cp_s

                                            # Store identifying info
                                            pops.append({
                                                "file": fpath,
                                                "is_mod": is_mod_file,
                                                "region_tag": tag,
                                                "culture": cul.group(1),
                                                "religion": rel.group(1) if rel else "",
                                                "size": int(size.group(1)),
                                                # Use a simple signature to find it later instead of fragile indices?
                                                # Or regex match nth occurrence?
                                                # Indices are best if we don't modify file in between.
                                                "indices": {
                                                    "state_block_start": s,
                                                    "rs_content_start": s + rs_s,
                                                    "pop_content_start": s + rs_s + cp_s,
                                                    "pop_content_end": s + rs_s + cp_e
                                                }
                                            })

                                        cp_cursor = cp_e
                                    else:
                                        cp_cursor += 1
                                rs_cursor = rs_e
                            else:
                                rs_cursor += 1

                        cursor = e

        return pops

    def save_state_pops_total(self, state_name, new_total, pop_data_list):
        # 1. Calculate distribution
        current_total = sum(p['size'] for p in pop_data_list)
        diff = new_total - current_total
        if diff == 0: return

        count = len(pop_data_list)
        if count == 0: return

        per_pop = diff // count
        remainder = diff % count

        # Apply changes to data objects first
        for i, p in enumerate(pop_data_list):
            change = per_pop + (1 if i < remainder else 0)
            p['size'] += change
            if p['size'] < 0: p['size'] = 0 # Prevent negative

        # 2. Group by file to minimize open/close
        files_map = {}
        for p in pop_data_list:
            if p['file'] not in files_map: files_map[p['file']] = []
            files_map[p['file']].append(p)

        # 3. Process each file
        for fpath, pops in files_map.items():
            # Check if we need to copy to mod directory
            target_path = fpath
            if self.vanilla_path and fpath.startswith(self.vanilla_path):
                # Copy to mod
                mod_rel = os.path.relpath(fpath, os.path.join(self.vanilla_path, "game"))
                target_path = os.path.join(self.mod_path, mod_rel)
                os.makedirs(os.path.dirname(target_path), exist_ok=True)
                if not os.path.exists(target_path):
                    shutil.copy2(fpath, target_path)

            # Read (possibly new) file
            try:
                with open(target_path, 'r', encoding='utf-8-sig') as f: content = f.read()
            except:
                with open(target_path, 'r', encoding='utf-8') as f: content = f.read()

            # We must apply changes from bottom to top to preserve indices!
            # Sort pops by index descending
            pops.sort(key=lambda x: x['indices']['pop_content_start'], reverse=True)

            for p in pops:
                # If we moved file (vanilla -> mod), indices might be same if copied exactly.
                # However, if we are processing multiple pops in the same file, updating one shifts indices of others.
                # BUT since we sort reverse, the 'start' indices of earlier pops remain valid.

                # Re-verify/Find block
                # Since content might be different if we copied vanilla file? No, it's a copy.
                # But to be safe, let's use the indices relative to the logic we scanned.

                # Limitation: 'indices' are from the scan of 'fpath'. If 'target_path' is different (copy), content is same.
                # But if we modify the content for pop N, pop N-1's indices are fine.

                s = p['indices']['pop_content_start']
                e = p['indices']['pop_content_end']

                # Extract the exact block to ensure we match
                # (Safety check: does content[s:e] look like the pop?)
                # Actually, we just need to replace the 'size = X' line inside the block content[s:e]

                block_inner = content[s:e]
                new_inner = re.sub(r"size\s*=\s*\d+", f"size = {p['size']}", block_inner)

                content = content[:s] + new_inner + content[e:]

            with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(content)
            self.log(f"[POPS] Updated total population in {os.path.basename(target_path)}", 'success')

    def save_single_pop(self, pop_entry, new_culture, new_religion, new_size):
        # Similar logic to above but for one entry
        fpath = pop_entry['file']
        target_path = fpath

        # Copy logic
        if self.vanilla_path and fpath.startswith(self.vanilla_path):
            mod_rel = os.path.relpath(fpath, os.path.join(self.vanilla_path, "game"))
            target_path = os.path.join(self.mod_path, mod_rel)
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            if not os.path.exists(target_path):
                shutil.copy2(fpath, target_path)

        try:
            with open(target_path, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_path, 'r', encoding='utf-8') as f: content = f.read()

        s = pop_entry['indices']['pop_content_start']
        e = pop_entry['indices']['pop_content_end']

        block_inner = content[s:e]

        # Replace values
        new_inner = block_inner
        new_inner = re.sub(r"culture\s*=\s*[A-Za-z0-9_]+", f"culture = {new_culture}", new_inner)
        new_inner = re.sub(r"religion\s*=\s*[A-Za-z0-9_]+", f"religion = {new_religion}", new_inner)
        new_inner = re.sub(r"size\s*=\s*\d+", f"size = {new_size}", new_inner)

        content = content[:s] + new_inner + content[e:]

        with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[POPS] Updated single pop in {os.path.basename(target_path)}", 'success')

    # --- JOURNAL MANAGER LOGIC ---
    def _scan_folder_for_keys(self, rel_path, regex_pattern):
        """Generic scanner for simple keys in a folder structure."""
        keys = set()
        paths = []
        # Check mod first, then vanilla
        if self.mod_path: paths.append(os.path.join(self.mod_path, rel_path))
        if self.vanilla_path:
            paths.append(os.path.join(self.vanilla_path, "game", rel_path))
            paths.append(os.path.join(self.vanilla_path, rel_path))

        for p in paths:
            if not os.path.exists(p): continue
            for root, _, files in os.walk(p):
                for file in files:
                    if not file.endswith(".txt"): continue
                    try:
                        with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                    # Regex must handle potential indentation if MULTILINE is used with ^
                    matches = re.finditer(regex_pattern, content, re.MULTILINE)
                    for m in matches:
                        keys.add(m.group(1))
        return sorted(list(keys))

    def scan_technologies(self):
        return self._scan_folder_for_keys("common/technology/technologies", r"^\s*([a-z0-9_]+)\s*=\s*\{")

    def scan_laws(self):
        return self._scan_folder_for_keys("common/laws", r"^\s*(law_[a-z0-9_]+)\s*=\s*\{")

    def scan_buildings(self):
        return self._scan_folder_for_keys("common/buildings", r"^\s*(building_[a-z0-9_]+)\s*=\s*\{")

    def scan_all_tags(self):
        return self._scan_folder_for_keys("common/country_definitions", r"^\s*([A-Z][A-Z0-9_]{1,4})\s*=\s*\{")

    def add_journal_entry_to_history(self, tag, je_id):
        """Adds a journal entry to the country's history file."""
        self.perform_auto_backup()
        hist_dir = os.path.join(self.mod_path, "common", "history", "countries")
        clean_tag = tag.replace("c:", "").strip()

        target_path = None
        target_content = None

        if not os.path.exists(hist_dir):
            return # Can't add if directory doesn't exist (or empty mod)

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Look for c:TAG block
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                    target_path = path; target_content = content; break
            if target_path: break

        if not target_path:
            self.log(f"[WARN] No history file found for {clean_tag}. Journal entry not added to history.", 'warn')
            return

        # Check if already present
        if f"type = {je_id}" in target_content:
            return # Already there

        s, e = self.get_block_range_safe(target_content, f"c:{clean_tag}")
        if s is not None:
            block = target_content[s:e]
            # Insert before closing brace
            new_line = f"\n\t\tadd_journal_entry = {{ type = {je_id} }}"
            new_block = block[:block.rfind('}')] + new_line + "\n\t}"

            new_content = target_content[:s] + new_block + target_content[e:]

            with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(new_content)
            self.log(f"[HISTORY] Added {je_id} to {os.path.basename(target_path)}", 'success')

    def save_journal_entry(self, entry_data):
        self.perform_auto_backup()
        mod_name = os.path.basename(self.mod_path)

        # 1. Script File
        je_dir = os.path.join(self.mod_path, "common", "journal_entries")
        os.makedirs(je_dir, exist_ok=True)
        target_file = os.path.join(je_dir, f"{mod_name}_journals.txt")

        # Construct content
        je_id = entry_data['id']

        # Logic to extract tag for visibility
        visibility_block = ""
        target_tag = None
        for item in entry_data['activation']:
            # Check for "this = c:TAG" or "c:TAG = THIS"
            # We look for the tag in the activation triggers to set visibility
            m = re.search(r"(?:this|THIS)\s*=\s*c:([A-Za-z0-9_]+)", item, re.IGNORECASE)
            if not m:
                m = re.search(r"c:([A-Za-z0-9_]+)\s*=\s*(?:this|THIS)", item, re.IGNORECASE)

            if m:
                target_tag = m.group(1)
                break

        if target_tag:
            visibility_block = f"""
\tis_shown_when_inactive = {{
\t\texists = c:{target_tag}
\t\tthis = c:{target_tag}
\t}}
"""
            # Also add to history file
            self.add_journal_entry_to_history(target_tag, je_id)

        # Activation formatting
        possible_block = ""
        for item in entry_data['activation']:
            possible_block += f"\t\t{item}\n"

        # Completion formatting
        complete_block = ""
        for item in entry_data['completion']:
            complete_block += f"\t\t{item}\n"

        # Effect formatting
        effect_block = ""
        for item in entry_data['rewards']:
            effect_block += f"\t\t{item}\n"

        entry_content = f"""
{je_id} = {{
\tgroup = je_group_objectives
\ticon = "gfx/interface/icons/event_icons/event_default.dds"
\tcan_revolution_inherit = yes
{visibility_block}
\tpossible = {{
{possible_block}\t}}

\tcomplete = {{
{complete_block}\t}}

\ton_complete = {{
{effect_block}\t}}
}}
"""

        # Append or Create
        mode = 'a' if os.path.exists(target_file) else 'w'
        try:
            with open(target_file, mode, encoding='utf-8-sig') as f:
                if mode == 'a': f.write("\n")
                f.write(entry_content)
        except Exception as e:
            self.log(f"[ERROR] Failed to save Journal Entry: {e}", 'error')
            return

        # 2. Localization
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        os.makedirs(loc_dir, exist_ok=True)
        loc_file = os.path.join(loc_dir, f"{mod_name}_journals_l_english.yml")

        if not os.path.exists(loc_file):
             with open(loc_file, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        title = entry_data['title'].replace('"', '\\"')
        desc = entry_data['desc'].replace('"', '\\"')

        loc_content = f' {je_id}:0 "{title}"\n {je_id}_desc:0 "{desc}"\n'

        try:
            with open(loc_file, 'a', encoding='utf-8-sig') as f:
                f.write(loc_content)
        except Exception as e:
            self.log(f"[ERROR] Failed to save Localization: {e}", 'error')

        self.log(f"[SUCCESS] Journal Entry {je_id} saved to {os.path.basename(target_file)}", 'success')

    # --- BUILDING LOGIC ---
    def scan_history_building_types(self):
        """Scans history/buildings for all used building types."""
        types = set()
        paths = []
        if self.mod_path: paths.append(os.path.join(self.mod_path, "common/history/buildings"))
        if self.vanilla_path: paths.append(os.path.join(self.vanilla_path, "game/common/history/buildings"))

        for p in paths:
            if not os.path.exists(p): continue
            for root, _, files in os.walk(p):
                for file in files:
                    if not file.endswith(".txt"): continue
                    try:
                         with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                         with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                    matches = re.findall(r'building\s*=\s*"([^"]+)"', content)
                    types.update(matches)
        return sorted(list(types))

    def _scan_file_for_buildings(self, fpath, clean_state, buildings_list, is_mod):
        try:
             with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
             with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

        # Search s:STATE
        cursor = 0
        while True:
            s, e = self.get_block_range_safe(content, f"s:{clean_state}", cursor)
            if s is None: break

            state_block = content[s:e]

            # Search region_state:TAG inside state_block
            rs_cursor = 0
            while True:
                m_rs = re.search(r"region_state:([A-Za-z0-9_]+)\s*=\s*\{", state_block[rs_cursor:])
                if not m_rs: break

                tag = m_rs.group(1)
                rs_s, rs_e = self.find_block_content(state_block, rs_cursor + m_rs.end() - 1)

                if rs_s:
                    rs_inner = state_block[rs_s:rs_e]

                    # Search create_building inside region_state
                    cb_cursor = 0
                    while True:
                        m_cb = re.search(r"create_building\s*=\s*\{", rs_inner[cb_cursor:])
                        if not m_cb: break

                        cb_s, cb_e = self.find_block_content(rs_inner, cb_cursor + m_cb.end() - 1)

                        if cb_s:
                            cb_inner = rs_inner[cb_s:cb_e]

                            b_type_m = re.search(r'building\s*=\s*"([^"]+)"', cb_inner)
                            level_m = re.search(r'level\s*=\s*(\d+)', cb_inner)

                            b_type = b_type_m.group(1) if b_type_m else "Unknown"
                            level = int(level_m.group(1)) if level_m else 1

                            abs_start = s + rs_s + cb_cursor + m_cb.start()
                            abs_end = s + rs_s + cb_e

                            buildings_list.append({
                                "file": fpath,
                                "is_mod": is_mod,
                                "state": clean_state,
                                "owner": tag,
                                "type": b_type,
                                "level": level,
                                "indices": {
                                    "start": abs_start,
                                    "end": abs_end
                                }
                            })

                            cb_cursor = cb_e
                        else:
                            cb_cursor += 1
                    rs_cursor = rs_e
                else:
                    rs_cursor += 1

            cursor = e

    def scan_state_buildings(self, state_name):
        """Scans buildings in a specific state."""
        clean_state = self.format_state_clean(state_name)
        if not clean_state: return []

        buildings = []
        processed_files = set() # Relative paths in mod

        # 1. Mod
        if self.mod_path:
            mod_b = os.path.join(self.mod_path, "common/history/buildings")
            if os.path.exists(mod_b):
                for root, _, files in os.walk(mod_b):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        fpath = os.path.join(root, file)
                        rel = os.path.relpath(fpath, mod_b)
                        processed_files.add(rel)
                        self._scan_file_for_buildings(fpath, clean_state, buildings, True)

        # 2. Vanilla
        if self.vanilla_path:
            van_b = os.path.join(self.vanilla_path, "game/common/history/buildings")
            if os.path.exists(van_b):
                for root, _, files in os.walk(van_b):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        fpath = os.path.join(root, file)
                        rel = os.path.relpath(fpath, van_b)

                        if rel in processed_files: continue

                        self._scan_file_for_buildings(fpath, clean_state, buildings, False)

        return buildings

    def save_state_building(self, building_entry, new_level=None, delete=False):
        """Updates or deletes a building entry."""
        self.perform_auto_backup()
        fpath = building_entry['file']
        target_path = fpath

        # Copy to mod if vanilla
        if self.vanilla_path and fpath.startswith(self.vanilla_path):
            mod_rel = os.path.relpath(fpath, os.path.join(self.vanilla_path, "game"))
            target_path = os.path.join(self.mod_path, mod_rel)
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            if not os.path.exists(target_path):
                shutil.copy2(fpath, target_path)

        try:
            with open(target_path, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_path, 'r', encoding='utf-8') as f: content = f.read()

        s = building_entry['indices']['start']
        e = building_entry['indices']['end']

        # Verify content matches (simple check)
        # Note: if multiple modifications happen without reload, indices might drift.
        # But UI reloads after every save.

        if delete:
            # Remove the block
            content = content[:s].rstrip() + content[e:]
            self.log(f"[BUILDING] Removed {building_entry['type']} from {os.path.basename(target_path)}", 'success')
        else:
            # Update level
            block = content[s:e]
            if re.search(r"level\s*=\s*\d+", block):
                new_block = re.sub(r"level\s*=\s*\d+", f"level = {new_level}", block)
            else:
                last_brace = block.rfind('}')
                new_block = block[:last_brace] + f"\n\t\t\t\tlevel = {new_level}\n\t\t\t}}"

            content = content[:s] + new_block + content[e:]
            self.log(f"[BUILDING] Updated {building_entry['type']} to level {new_level}", 'success')

        with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(content)

    def add_state_building(self, state_name, tag, building_type, level):
        """Adds a new building to a state."""
        self.perform_auto_backup()
        clean_state = self.format_state_clean(state_name)
        clean_tag = tag.replace("c:", "").strip()

        fpath = None
        target_content = None

        # Check Mod First
        if self.mod_path:
            mod_b = os.path.join(self.mod_path, "common/history/buildings")
            if os.path.exists(mod_b):
                for root, _, files in os.walk(mod_b):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        curr_path = os.path.join(root, file)
                        try:
                            with open(curr_path, 'r', encoding='utf-8-sig') as f: c = f.read()
                        except:
                            with open(curr_path, 'r', encoding='utf-8') as f: c = f.read()

                        if f"s:{clean_state}" in c:
                            fpath = curr_path
                            target_content = c
                            break
                    if fpath: break

        # Check Vanilla (if not found in Mod)
        if not fpath and self.vanilla_path:
            van_b = os.path.join(self.vanilla_path, "game/common/history/buildings")
            if os.path.exists(van_b):
                for root, _, files in os.walk(van_b):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        curr_path = os.path.join(root, file)
                        rel = os.path.relpath(curr_path, van_b)

                        # SKIP shadowed files!
                        if self.mod_path:
                            shadow_path = os.path.join(self.mod_path, "common/history/buildings", rel)
                            if os.path.exists(shadow_path): continue

                        try:
                            with open(curr_path, 'r', encoding='utf-8-sig') as f: c = f.read()
                        except:
                            with open(curr_path, 'r', encoding='utf-8') as f: c = f.read()

                        if f"s:{clean_state}" in c:
                            fpath = curr_path
                            target_content = c
                            break
                    if fpath: break

        if fpath:
            if self.vanilla_path and fpath.startswith(self.vanilla_path):
                mod_rel = os.path.relpath(fpath, os.path.join(self.vanilla_path, "game"))
                target_path = os.path.join(self.mod_path, mod_rel)
                os.makedirs(os.path.dirname(target_path), exist_ok=True)
                if not os.path.exists(target_path):
                    shutil.copy2(fpath, target_path)
            else:
                target_path = fpath
        else:
            target_path = os.path.join(self.mod_path, "common/history/buildings/99_mod_buildings.txt")
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            if not os.path.exists(target_path):
                with open(target_path, 'w', encoding='utf-8-sig') as f: f.write("BUILDINGS = {\n}")
            target_content = "BUILDINGS = {\n}"

        # Re-read
        try:
            with open(target_path, 'r', encoding='utf-8-sig') as f: target_content = f.read()
        except:
            with open(target_path, 'r', encoding='utf-8') as f: target_content = f.read()

        new_b_block = f"""
\t\t\tcreate_building = {{
\t\t\t\tbuilding = "{building_type}"
\t\t\t\tlevel = {level}
\t\t\t\treserves = 1
\t\t\t\tactivate_production_methods = {{ }}
\t\t\t}}"""

        s, e = self.get_block_range_safe(target_content, f"s:{clean_state}")

        if s is not None:
            state_block = target_content[s:e]

            rs_cursor = 0
            found_rs = False
            rs_insert_idx = -1

            while True:
                m_rs = re.search(r"region_state:([A-Za-z0-9_]+)\s*=\s*\{", state_block[rs_cursor:])
                if not m_rs: break

                curr_tag = m_rs.group(1)
                rs_s, rs_e = self.find_block_content(state_block, rs_cursor + m_rs.end() - 1)

                if curr_tag == clean_tag:
                    found_rs = True
                    rs_insert_idx = rs_e - 1
                    break

                rs_cursor = rs_e

            if found_rs:
                new_state_block = state_block[:rs_insert_idx] + new_b_block + state_block[rs_insert_idx:]
                target_content = target_content[:s] + new_state_block + target_content[e:]
            else:
                new_rs = f"""
\t\tregion_state:{clean_tag} = {{
{new_b_block}
\t\t}}"""
                new_state_block = state_block[:state_block.rfind('}')] + new_rs + "\n\t}"
                target_content = target_content[:s] + new_state_block + target_content[e:]
        else:
            new_entry = f"\n\ts:{clean_state} = {{\n\t\tregion_state:{clean_tag} = {{\n{new_b_block}\n\t\t}}\n\t}}"
            bs, be = self.get_block_range_safe(target_content, "BUILDINGS")
            if bs is not None:
                target_content = target_content[:be-1] + new_entry + "\n}" + target_content[be:]
            else:
                target_content += f"\nBUILDINGS = {{{new_entry}\n}}"

        with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(target_content)
        self.log(f"[BUILDING] Added {building_type} to {clean_state}", 'success')

# =============================================================================
#  GUI IMPLEMENTATION
# =============================================================================

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Victoria 3 Modding Tool")
        self.geometry("850x700")
        self.configure(bg="#212121")
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self._configure_dark_theme()

        self.logic = Vic3Logic(self.log_message)
        self.log_queue = queue.Queue()
        self.is_processing = False
        self.cr_rgb = [random.randint(0,255), random.randint(0,255), random.randint(0,255)]

        self._build_ui()
        self.load_config()
        self.after(100, self.process_log_queue)

    def _configure_dark_theme(self):
        BG_COLOR = "#212121"
        FG_COLOR = "#ECEFF1"
        ACCENT_COLOR = "#00ACC1"
        SECONDARY_BG = "#323232"
        ENTRY_BG = "#424242"
        self.style.configure('.', background=BG_COLOR, foreground=FG_COLOR, font=('Segoe UI', 10))
        self.style.configure('TLabel', background=BG_COLOR, foreground=FG_COLOR)
        self.style.configure('TFrame', background=BG_COLOR)
        self.style.configure('TLabelframe', background=BG_COLOR, foreground=FG_COLOR, bordercolor=SECONDARY_BG)
        self.style.configure('TLabelframe.Label', background=BG_COLOR, foreground=ACCENT_COLOR, font=('Segoe UI', 10, 'bold'))
        self.style.configure('WhiteBorder.TFrame', background=FG_COLOR)
        self.style.configure('TButton', background=SECONDARY_BG, foreground=FG_COLOR, borderwidth=1, focuscolor=SECONDARY_BG)
        self.style.map('TButton', background=[('active', ACCENT_COLOR), ('disabled', '#2a2a2a')], foreground=[('disabled', '#666666')])
        self.style.configure('BlackText.TButton', background=SECONDARY_BG, foreground="black", borderwidth=1, focuscolor=SECONDARY_BG)
        self.style.map('BlackText.TButton', background=[('active', ACCENT_COLOR), ('disabled', '#2a2a2a')], foreground=[('disabled', '#666666')])
        self.style.configure('TEntry', fieldbackground=ENTRY_BG, foreground=FG_COLOR, bordercolor=SECONDARY_BG, lightcolor=SECONDARY_BG, darkcolor=SECONDARY_BG)
        self.style.configure('TCheckbutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TCheckbutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])
        self.style.configure('TRadiobutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TRadiobutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])

        # Notebook Tab colors - Force black text
        self.style.configure('TNotebook.Tab', foreground='black')

        # Combobox colors - Force black text for readability
        self.option_add('*TCombobox*Listbox.foreground', 'black')
        self.option_add('*TCombobox*Listbox.background', 'white')
        self.style.configure('TCombobox', foreground='black', fieldbackground='white', background='white')

        # Treeview colors - Force black text
        self.style.configure("Treeview", background="white", foreground="black", fieldbackground="white")
        self.style.map("Treeview", background=[('selected', '#00ACC1')], foreground=[('selected', 'white')])

    def load_config(self):
        try:
            if os.path.exists("config.json"):
                with open("config.json", "r") as f:
                    data = json.load(f)
                    path = data.get("mod_path", "")
                    if os.path.exists(path):
                        self.path_var.set(path)
                        self.logic.set_mod_path(path)
                        self.log_message(f"Loaded Mod Path: {path}")

                    v_path = data.get("vanilla_path", "")
                    if os.path.exists(v_path):
                        self.vanilla_path_var.set(v_path)
                        self.logic.set_vanilla_path(v_path)
                        self.log_message(f"Loaded Vanilla Path: {v_path}")
        except: pass

    def save_config(self):
        try:
            with open("config.json", "w") as f:
                json.dump({
                    "mod_path": self.path_var.get(),
                    "vanilla_path": self.vanilla_path_var.get()
                }, f)
        except: pass

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Mod Path with Custom Header
        # We create a header frame separate from the LabelFrame to ensure full width expansion
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 0)) # No bottom padding so it sits on top of the box

        # Title
        ttk.Label(header_frame, text="Global Configuration", foreground="#00ACC1", font=('Segoe UI', 10, 'bold')).pack(side=tk.LEFT)

        # Spacer (pushes everything else to the right)
        ttk.Frame(header_frame).pack(side=tk.LEFT, fill=tk.X, expand=True)

        # Buttons in the title bar - Packed to RIGHT to align them to the far right

        self.autobackup_var = tk.BooleanVar(value=self.logic.auto_backup_enabled)
        ttk.Checkbutton(header_frame, text="Auto-backup", variable=self.autobackup_var, command=self.toggle_auto_backup).pack(side=tk.RIGHT, padx=5)

        ttk.Button(header_frame, text="Backup Current Mod", command=self.start_backup).pack(side=tk.RIGHT, padx=5)
        ttk.Button(header_frame, text="Mod Manager", command=self.show_mod_manager_ui).pack(side=tk.RIGHT, padx=5)

        # Main Content Box (Fake LabelFrame to remove top gap)
        path_border_frame = ttk.Frame(main_frame, style='WhiteBorder.TFrame')
        path_border_frame.pack(fill=tk.X, pady=(0, 10))

        path_frame = ttk.Frame(path_border_frame, padding=15)
        path_frame.pack(fill=tk.BOTH, expand=True, padx=1, pady=1)

        self.path_var = tk.StringVar()
        ttk.Label(path_frame, text="Mod Directory:").pack(side=tk.LEFT, padx=(0, 5))
        ttk.Entry(path_frame, textvariable=self.path_var).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(path_frame, text="Browse...", command=self.browse_folder).pack(side=tk.LEFT, padx=5)

        self.vanilla_path_var = tk.StringVar() # Initialize but don't show

        # 2. Navigation
        nav_frame = ttk.Frame(main_frame)
        nav_frame.pack(fill=tk.X, pady=(0, 5))
        # Mod Manager button moved to header
        ttk.Button(nav_frame, text="Transfer States", command=self.show_transfer_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Country", command=self.show_create_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Military Creator", command=self.show_military_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Modify Country", command=self.show_country_mod_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Diplomacy", command=self.show_diplomacy_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        nav_frame_2 = ttk.Frame(main_frame)
        nav_frame_2.pack(fill=tk.X, pady=(0, 10))
        ttk.Button(nav_frame_2, text="Powerblock Manager", command=self.show_power_bloc_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame_2, text="Religion/Culture", command=self.show_rel_cul_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame_2, text="State Manager", command=self.show_state_manager_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame_2, text="Journal Manager", command=self.show_journal_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        # 3. Dynamic Content
        self.content_frame = ttk.Frame(main_frame)
        self.content_frame.pack(fill=tk.BOTH, expand=False, pady=5)

        # 4. Action & Log
        self.action_frame = ttk.Frame(main_frame, padding=(0, 10))
        self.action_frame.pack(fill=tk.X)
        self.run_btn = ttk.Button(self.action_frame, text="Execute", command=lambda: None)
        self.run_btn.pack(side=tk.RIGHT, padx=5)
        
        log_frame = ttk.LabelFrame(main_frame, text="Execution Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.log_area = scrolledtext.ScrolledText(log_frame, state='disabled', height=10, bg="#1e1e1e", fg="#d4d4d4", insertbackground="white", relief="flat")
        self.log_area.pack(fill=tk.BOTH, expand=True)
        self.log_area.tag_config('info', foreground='#d4d4d4')
        self.log_area.tag_config('warn', foreground='#FFA726')
        self.log_area.tag_config('error', foreground='#EF5350')
        self.log_area.tag_config('success', foreground='#66BB6A')

        self.show_transfer_ui()

    def clear_content(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()

    # --- MODE 0: MOD MANAGER ---
    def show_mod_manager_ui(self):
        self.clear_content()
        self.mode = "MOD_MANAGER"
        f = ttk.LabelFrame(self.content_frame, text="Mod Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # 1. New Mod
        new_frame = ttk.LabelFrame(f, text="Create New Mod", padding=10)
        new_frame.pack(fill=tk.X, pady=5)

        ttk.Label(new_frame, text="Mod Name:").pack(side=tk.LEFT, padx=5)
        self.mm_name = tk.StringVar()
        ttk.Entry(new_frame, textvariable=self.mm_name, width=20).pack(side=tk.LEFT, padx=5)

        ttk.Label(new_frame, text="Location (Parent Folder):").pack(side=tk.LEFT, padx=5)
        self.mm_loc = tk.StringVar()
        # Default to standard paradox mod path if possible or current mod's parent
        if self.path_var.get():
             self.mm_loc.set(os.path.dirname(self.path_var.get()))

        ttk.Entry(new_frame, textvariable=self.mm_loc, width=30).pack(side=tk.LEFT, padx=5)
        ttk.Button(new_frame, text="Browse...", command=self.browse_mod_parent).pack(side=tk.LEFT, padx=5)

        ttk.Button(new_frame, text="Create Mod", command=self.start_create_mod).pack(side=tk.RIGHT, padx=5)

        # 2. Tools - Removed per user request (Auto-copy is integrated into Create Mod)
        # Backup controls moved to header

        self.run_btn.config(text="Ready", state='disabled')

    def browse_mod_parent(self):
        folder = filedialog.askdirectory()
        if folder:
            self.mm_loc.set(folder)

    def ensure_vanilla_path(self):
        path = self.vanilla_path_var.get()
        if path and os.path.exists(path):
            return path

        messagebox.showinfo("Setup", r"Select the victoria 3/game folder, e.g: C:\Program Files (x86)\Steam\steamapps\common\Victoria 3\game")
        folder = filedialog.askdirectory(title="Select Vanilla Game Directory")
        if folder:
            self.vanilla_path_var.set(folder)
            self.logic.set_vanilla_path(folder)
            self.save_config()
            self.log_message(f"Selected Vanilla Path: {folder}")
            return folder
        return None

    def start_create_mod(self):
        name = self.mm_name.get().strip()
        loc = self.mm_loc.get().strip()
        if not name or not loc:
            messagebox.showerror("Error", "Name and Location required.")
            return

        if self.logic.create_new_mod(name, loc):
            mod_path = os.path.join(loc, name)
            self.path_var.set(mod_path)
            self.save_config()

            # Ask if user wants to copy vanilla files now
            if messagebox.askyesno("Setup", "Copy vanilla files to new mod now?"):
                 v_path = self.ensure_vanilla_path()
                 if v_path:
                    self.log_message("Starting file copy...", 'info')
                    threading.Thread(target=self.logic.copy_vanilla_files, args=(v_path, mod_path), daemon=True).start()

            messagebox.showinfo("Success", f"Mod '{name}' created and loaded.")

    def start_copy_vanilla(self):
        mod_path = self.path_var.get()
        if not mod_path:
             messagebox.showerror("Error", "Mod path not selected.")
             return

        v_path = self.ensure_vanilla_path()
        if not v_path: return

        if messagebox.askyesno("Confirm", "Copy vanilla files to current mod? This may overwrite existing files."):
            self.log_message("Starting file copy...", 'info')
            # Run in thread to avoid freezing UI
            threading.Thread(target=self.logic.copy_vanilla_files, args=(v_path, mod_path), daemon=True).start()

    def start_backup(self):
        mod_path = self.path_var.get()
        if not mod_path:
             messagebox.showerror("Error", "Mod path not selected.")
             return
        self.logic.backup_mod(mod_path)

    def toggle_auto_backup(self):
        self.logic.auto_backup_enabled = self.autobackup_var.get()
        self.log_message(f"Auto-backup {'enabled' if self.logic.auto_backup_enabled else 'disabled'}.", 'info')

    # --- MODE 1: TRANSFER STATES ---
    def show_transfer_ui(self):
        self.clear_content()
        self.mode = "TRANSFER"
        f = ttk.LabelFrame(self.content_frame, text="Transfer States Mode", padding=15)
        f.pack(fill=tk.X)
        ttk.Label(f, text="Old Owner Tag (e.g. fra):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.tr_old_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_old_tag, width=15).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="New Owner Tag (e.g. gbr):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.tr_new_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_new_tag, width=15).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="States (Space separated):").grid(row=2, column=0, sticky=tk.NW, pady=8)
        self.tr_states = tk.Text(f, height=4, width=50, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat", padx=5, pady=5)
        self.tr_states.grid(row=2, column=1, columnspan=2, sticky=tk.W, pady=8, padx=5)
        self.tr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation (Auto-detect all states)", variable=self.tr_annex).grid(row=4, column=1, sticky=tk.W, pady=5)
        self.run_btn.config(text="Execute Transfer", command=self.start_transfer)

    # --- MODE 2: CREATE COUNTRY ---
    def show_create_ui(self):
        self.clear_content()
        self.mode = "CREATE"

        all_cultures, all_religions, all_tiers, all_types = self.logic.scan_definitions_for_options()

        if not all_tiers: all_tiers = ["empire", "kingdom", "grand_principality", "principality", "city_state"]
        if not all_types: all_types = ["recognized", "unrecognized", "colonial"]

        f = ttk.LabelFrame(self.content_frame, text="Create Country Mode", padding=15)
        f.pack(fill=tk.X)

        # Row 0
        ttk.Label(f, text="New Country Tag (3 chars):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.cr_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Country Name:").grid(row=0, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_name = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_name, width=25).grid(row=0, column=3, sticky=tk.W, pady=5)

        # Row 1
        ttk.Label(f, text="Adjective:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.cr_adj = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_adj, width=25).grid(row=1, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Taken From (Old Tag):").grid(row=1, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_old_owner = tk.StringVar()
        e_old = ttk.Entry(f, textvariable=self.cr_old_owner, width=10)
        e_old.grid(row=1, column=3, sticky=tk.W, pady=5)
        e_old.bind("<FocusOut>", self.on_old_owner_change)
        
        # Row 2
        ttk.Label(f, text="Capital State (e.g. aquitaine):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.cr_capital = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_capital, width=25).grid(row=2, column=1, sticky=tk.W, pady=5)
        
        self.cr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation", variable=self.cr_annex, command=self.toggle_annex_ui).grid(row=2, column=2, columnspan=2, sticky=tk.W, padx=10)

        # Row 3
        ttk.Label(f, text="Tier:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.cr_tier = tk.StringVar(value="principality")
        ttk.Combobox(f, textvariable=self.cr_tier, values=all_tiers, state="readonly").grid(row=3, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Type:").grid(row=3, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_type = tk.StringVar(value="recognized")
        ttk.Combobox(f, textvariable=self.cr_type, values=all_types, state="readonly").grid(row=3, column=3, sticky=tk.W, pady=5)

        # Row 4
        ttk.Label(f, text="Gov Type:").grid(row=4, column=0, sticky=tk.W, pady=5)
        self.cr_gov = tk.StringVar(value="monarchy")
        f_gov = ttk.Frame(f); f_gov.grid(row=4, column=1, sticky=tk.W)
        ttk.Radiobutton(f_gov, text="Monarchy", variable=self.cr_gov, value="monarchy").pack(side=tk.LEFT)
        ttk.Radiobutton(f_gov, text="Republic", variable=self.cr_gov, value="republic").pack(side=tk.LEFT)

        ttk.Button(f, text="Pick Color", command=self.pick_color).grid(row=4, column=2, sticky=tk.W, padx=10)
        self.color_preview = tk.Label(f, text="     ", bg=self._rgb_to_hex(self.cr_rgb), relief="solid", borderwidth=1)
        self.color_preview.grid(row=4, column=3, sticky=tk.W)

        # Row 5: Cultures
        self.all_cultures_data = all_cultures
        f_cult = ttk.LabelFrame(f, text="Cultures (Defaults to old tag's default culture)", padding=5)
        f_cult.grid(row=5, column=0, columnspan=2, sticky=tk.NSEW, pady=5)

        self.cr_cult_search = tk.StringVar()
        self.cb_cultures = ttk.Combobox(f_cult, textvariable=self.cr_cult_search, values=all_cultures)
        self.cb_cultures.pack(fill=tk.X)
        self.cb_cultures.bind("<<ComboboxSelected>>", self.add_culture_from_combo)
        self.cb_cultures.bind("<KeyRelease>", self.filter_culture_options)

        self.lb_cultures = tk.Listbox(f_cult, height=4, bg="#424242", fg="#ECEFF1", selectmode=tk.SINGLE)
        self.lb_cultures.pack(fill=tk.BOTH, expand=True, pady=2)

        ttk.Button(f_cult, text="Remove Selected", command=self.remove_culture).pack(fill=tk.X)
        self.selected_cultures = []

        # Row 5: Religion
        f_rel = ttk.LabelFrame(f, text="Religion (Defaults to old tag's default religion)", padding=5)
        f_rel.grid(row=5, column=2, columnspan=2, sticky=tk.NSEW, pady=5, padx=5)

        canvas = tk.Canvas(f_rel, bg="#212121", height=100)
        scrollbar = ttk.Scrollbar(f_rel, orient="vertical", command=canvas.yview)
        self.scrollable_rel_frame = ttk.Frame(canvas)

        self.scrollable_rel_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=self.scrollable_rel_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.cr_religion = tk.StringVar()
        for r in all_religions:
            ttk.Radiobutton(self.scrollable_rel_frame, text=r, variable=self.cr_religion, value=r).pack(anchor=tk.W)

        # Row 6
        self.lbl_others = ttk.Label(f, text="Other States (Space sep.):\n(Must be states owned by the old tag)")
        self.lbl_others.grid(row=6, column=0, sticky=tk.NW, pady=5)
        self.cr_others = tk.Text(f, height=3, width=40, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat")
        self.cr_others.grid(row=6, column=1, columnspan=3, sticky=tk.W, pady=5)

        # Row 7: Population Settings
        pop_frame = ttk.LabelFrame(f, text="Population Settings (Defaults to old tag's by default)", padding=5)
        pop_frame.grid(row=7, column=0, columnspan=4, sticky=tk.NSEW, pady=5)

        ttk.Label(pop_frame, text="Starting Wealth:").grid(row=0, column=0, sticky=tk.W)
        self.cr_pop_wealth = tk.StringVar()
        w_opts = [
            "effect_starting_pop_wealth_low",
            "effect_starting_pop_wealth_medium",
            "effect_starting_pop_wealth_high",
            "effect_starting_pop_wealth_very_high"
        ]
        ttk.Combobox(pop_frame, textvariable=self.cr_pop_wealth, values=w_opts, state="readonly", width=35).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(pop_frame, text="Starting Literacy:").grid(row=0, column=2, sticky=tk.W, padx=(10,0))
        self.cr_pop_lit = tk.StringVar()
        l_opts = [
            "effect_starting_pop_literacy_baseline",
            "effect_starting_pop_literacy_very_low",
            "effect_starting_pop_literacy_low",
            "effect_starting_pop_literacy_middling",
            "effect_starting_pop_literacy_high",
            "effect_starting_pop_literacy_very_high"
        ]
        ttk.Combobox(pop_frame, textvariable=self.cr_pop_lit, values=l_opts, state="readonly", width=35).grid(row=0, column=3, sticky=tk.W, padx=5)

        self.run_btn.config(text="Create & Transfer", command=self.start_create)

    def toggle_annex_ui(self):
        if self.cr_annex.get():
            self.lbl_others.grid_remove()
            self.cr_others.grid_remove()
        else:
            self.lbl_others.grid()
            self.cr_others.grid()

    def on_old_owner_change(self, event):
        # User requested to NOT populate the UI boxes automatically to keep them blank.
        # The background logic in start_create will handle defaults if these remain empty.
        pass
    
    def filter_culture_options(self, event):
        typed = self.cr_cult_search.get().strip().lower()
        if not typed:
            self.cb_cultures['values'] = self.all_cultures_data
        else:
            filtered = [c for c in self.all_cultures_data if c.lower().startswith(typed)]
            self.cb_cultures['values'] = filtered

            # Optional: Open the dropdown if there are matches (can be intrusive, but user requested 'visible')
            # if filtered:
            #     self.cb_cultures.event_generate('<Down>')

    def add_culture_from_combo(self, event):
        val = self.cr_cult_search.get()
        self.add_culture(val)
        self.cr_cult_search.set("")
        self.cb_cultures['values'] = self.all_cultures_data

    def add_culture(self, culture):
        if culture and culture not in self.selected_cultures:
            self.selected_cultures.append(culture)
            self.lb_cultures.insert(tk.END, culture)

    def remove_culture(self):
        sel = self.lb_cultures.curselection()
        if sel:
            idx = sel[0]
            val = self.lb_cultures.get(idx)
            self.selected_cultures.remove(val)
            self.lb_cultures.delete(idx)

    # --- MODE 3: MILITARY CREATOR ---
    def show_military_ui(self):
        self.clear_content()
        self.mode = "MILITARY"

        f = ttk.LabelFrame(self.content_frame, text="Create Military Formation", padding=15)
        f.pack(fill=tk.X)

        # Basic Info
        ttk.Label(f, text="Country Tag:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.mil_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.mil_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Formation Name:").grid(row=0, column=2, sticky=tk.W, pady=5)
        self.mil_name = tk.StringVar(value="First Army")
        ttk.Entry(f, textvariable=self.mil_name, width=20).grid(row=0, column=3, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Target State:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.mil_state = tk.StringVar()
        ttk.Entry(f, textvariable=self.mil_state, width=20).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)

        self.mil_loc_lbl = ttk.Label(f, text="(Defaults to Capital if empty/invalid)")
        self.mil_loc_lbl.grid(row=1, column=2, columnspan=2, sticky=tk.W)

        # Type Selection
        ttk.Label(f, text="Formation Type:").grid(row=2, column=0, sticky=tk.W, pady=10)
        self.mil_type = tk.StringVar(value="army")
        tf = ttk.Frame(f)
        tf.grid(row=2, column=1, columnspan=3, sticky=tk.W, pady=10)
        ttk.Radiobutton(tf, text="Army", variable=self.mil_type, value="army", command=self.update_mil_inputs).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Radiobutton(tf, text="Navy", variable=self.mil_type, value="navy", command=self.update_mil_inputs).pack(side=tk.LEFT)

        # Units Frame
        self.mil_unit_frame = ttk.LabelFrame(f, text="Composition", padding=10)
        self.mil_unit_frame.grid(row=3, column=0, columnspan=4, sticky=tk.W+tk.E, pady=10)

        # Initialize inputs
        self.update_mil_inputs()

        self.run_btn.config(text="Create Formation", command=self.start_create_military)

    def update_mil_inputs(self):
        # Clear existing widgets in unit frame
        for widget in self.mil_unit_frame.winfo_children():
            widget.destroy()

        m_type = self.mil_type.get()
        
        if m_type == "army":
            self.mil_name.set("First Army" if "Fleet" in self.mil_name.get() else self.mil_name.get())
            self.mil_loc_lbl.config(text="(Defaults to Capital if empty/invalid)", foreground="#ECEFF1")

            ttk.Label(self.mil_unit_frame, text="Infantry:").grid(row=0, column=0, padx=5)
            self.mil_u1 = tk.IntVar(value=10)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u1, width=5).grid(row=0, column=1, padx=5)

            ttk.Label(self.mil_unit_frame, text="Artillery:").grid(row=0, column=2, padx=5)
            self.mil_u2 = tk.IntVar(value=0)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u2, width=5).grid(row=0, column=3, padx=5)

            ttk.Label(self.mil_unit_frame, text="Cavalry:").grid(row=0, column=4, padx=5)
            self.mil_u3 = tk.IntVar(value=0)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u3, width=5).grid(row=0, column=5, padx=5)

        else:
            self.mil_name.set("First Fleet" if "Army" in self.mil_name.get() else self.mil_name.get())
            self.mil_loc_lbl.config(text="(Warning: Must be Coastal or Game Crash!)", foreground="#EF5350")

            ttk.Label(self.mil_unit_frame, text="Man-of-War:").grid(row=0, column=0, padx=5)
            self.mil_u1 = tk.IntVar(value=5)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u1, width=5).grid(row=0, column=1, padx=5)

            ttk.Label(self.mil_unit_frame, text="Frigate:").grid(row=0, column=2, padx=5)
            self.mil_u2 = tk.IntVar(value=10)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u2, width=5).grid(row=0, column=3, padx=5)

            ttk.Label(self.mil_unit_frame, text="Ironclad:").grid(row=0, column=4, padx=5)
            self.mil_u3 = tk.IntVar(value=0)
            ttk.Entry(self.mil_unit_frame, textvariable=self.mil_u3, width=5).grid(row=0, column=5, padx=5)

    def start_create_military(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")

        tag = self.logic.format_tag_clean(self.mil_tag.get())
        name = self.mil_name.get().strip()
        state = self.logic.format_state_clean(self.mil_state.get())
        m_type = self.mil_type.get()

        if not tag: return messagebox.showerror("Error", "Tag is required.")
        if not name: name = "Army" if m_type == "army" else "Fleet"

        try:
            u1 = int(self.mil_u1.get())
            u2 = int(self.mil_u2.get())
            u3 = int(self.mil_u3.get())
        except:
             return messagebox.showerror("Error", "Unit counts must be integers.")

        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')

        if m_type == "army":
             threading.Thread(target=self.run_army_logic, args=(tag, name, state, u1, u2, u3), daemon=True).start()
        else:
             threading.Thread(target=self.run_navy_logic, args=(tag, name, state, u1, u2, u3), daemon=True).start()

    def _rgb_to_hex(self, rgb):
        return f'#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}'

    def pick_color(self):
        init_color = self._rgb_to_hex(self.cr_rgb)
        color = colorchooser.askcolor(color=init_color, title="Choose Country Color")
        if color[0]:
            self.cr_rgb = [int(x) for x in color[0]]
            self.color_preview.config(bg=color[1])

    # --- MODE 5: COUNTRY MODIFICATION ---
    def show_country_mod_ui(self):
        self.clear_content()
        self.mode = "MOD_COUNTRY"
        f = ttk.LabelFrame(self.content_frame, text="Modify Country", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # Tag Input & Load
        top_frame = ttk.Frame(f)
        top_frame.pack(fill=tk.X, pady=5)
        ttk.Label(top_frame, text="Country Tag:").pack(side=tk.LEFT)
        self.mc_tag = tk.StringVar()
        ttk.Entry(top_frame, textvariable=self.mc_tag, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(top_frame, text="Load Data", command=self.load_country_mod_data).pack(side=tk.LEFT, padx=5)

        # Identity
        id_frame = ttk.LabelFrame(f, text="Country Identity", padding=5)
        id_frame.pack(fill=tk.X, pady=5)

        ttk.Label(id_frame, text="Name:").grid(row=0, column=0, sticky=tk.W)
        self.mc_name = tk.StringVar()
        ttk.Entry(id_frame, textvariable=self.mc_name, width=30).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(id_frame, text="Adjective:").grid(row=0, column=2, sticky=tk.W)
        self.mc_adj = tk.StringVar()
        ttk.Entry(id_frame, textvariable=self.mc_adj, width=30).grid(row=0, column=3, sticky=tk.W, padx=5)

        ttk.Button(id_frame, text="Color Picker", command=self.pick_color_mod).grid(row=0, column=4, padx=5)
        self.mc_rgb = [255, 255, 255]
        self.mc_color_prev = tk.Label(id_frame, text="     ", bg="#FFFFFF", relief="solid", borderwidth=1)
        self.mc_color_prev.grid(row=0, column=5)

        # Cultural & Religious Identity
        cr_frame = ttk.LabelFrame(f, text="Culture & Religion", padding=5)
        cr_frame.pack(fill=tk.X, pady=5)

        ttk.Label(cr_frame, text="Primary Cultures (Space sep):").grid(row=0, column=0, sticky=tk.W)
        self.mc_cultures = tk.StringVar()
        ttk.Entry(cr_frame, textvariable=self.mc_cultures, width=40).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(cr_frame, text="State Religion:").grid(row=0, column=2, sticky=tk.W, padx=(10,0))
        self.mc_religion = tk.StringVar()
        # Will populate this on load usually, or init
        self.mc_religion_cb = ttk.Combobox(cr_frame, textvariable=self.mc_religion, state="normal", width=20)
        self.mc_religion_cb.grid(row=0, column=3, sticky=tk.W, padx=5)

        # Internal Politics
        pol_frame = ttk.LabelFrame(f, text="Internal Politics", padding=5)
        pol_frame.pack(fill=tk.X, pady=5)

        ttk.Label(pol_frame, text="Government:").grid(row=0, column=0, sticky=tk.W)
        self.mc_gov = tk.StringVar(value="monarchy")
        gf = ttk.Frame(pol_frame)
        gf.grid(row=0, column=1, columnspan=3, sticky=tk.W)
        ttk.Radiobutton(gf, text="Monarchy", variable=self.mc_gov, value="monarchy").pack(side=tk.LEFT)
        ttk.Radiobutton(gf, text="Republic", variable=self.mc_gov, value="republic").pack(side=tk.LEFT)
        ttk.Radiobutton(gf, text="Theocracy", variable=self.mc_gov, value="theocracy").pack(side=tk.LEFT)

        ttk.Label(pol_frame, text="Economic System:").grid(row=1, column=0, sticky=tk.W)
        self.mc_law_eco = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_eco, values=["law_interventionism", "law_laissez_faire", "law_command_economy", "law_traditionalism", "law_agrarianism"], state="readonly").grid(row=1, column=1, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Trade Policy:").grid(row=1, column=2, sticky=tk.W)
        self.mc_law_trade = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_trade, values=["law_free_trade", "law_protectionism", "law_isolationism", "law_mercantilism"], state="readonly").grid(row=1, column=3, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Power Structure:").grid(row=2, column=0, sticky=tk.W)
        self.mc_law_power = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_power, values=["law_autocracy", "law_oligarchy", "law_landed_voting", "law_wealth_voting", "law_census_voting", "law_universal_suffrage", "law_anarchy", "law_single_party_state"], state="readonly").grid(row=2, column=1, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Capital State:").grid(row=2, column=2, sticky=tk.W)
        self.mc_capital = tk.StringVar()
        ttk.Entry(pol_frame, textvariable=self.mc_capital, width=20).grid(row=2, column=3, sticky=tk.W, padx=5)

        # Ruler Designer
        rul_frame = ttk.LabelFrame(f, text="Ruler Designer", padding=5)
        rul_frame.pack(fill=tk.X, pady=5)

        ttk.Label(rul_frame, text="First Name:").grid(row=0, column=0, sticky=tk.W)
        self.mc_r_first = tk.StringVar()
        ttk.Entry(rul_frame, textvariable=self.mc_r_first).grid(row=0, column=1, padx=5)

        ttk.Label(rul_frame, text="Last Name:").grid(row=0, column=2, sticky=tk.W)
        self.mc_r_last = tk.StringVar()
        ttk.Entry(rul_frame, textvariable=self.mc_r_last).grid(row=0, column=3, padx=5)

        ttk.Label(rul_frame, text="Interest Group:").grid(row=1, column=0, sticky=tk.W)
        self.mc_r_ig = tk.StringVar()
        igs = ["ig_landowners", "ig_industrialists", "ig_intelligentsia", "ig_armed_forces", "ig_devout", "ig_petty_bourgeoisie", "ig_trade_unions", "ig_rural_folk"]
        ttk.Combobox(rul_frame, textvariable=self.mc_r_ig, values=igs, state="readonly").grid(row=1, column=1, padx=5)

        ttk.Label(rul_frame, text="Ideology:").grid(row=1, column=2, sticky=tk.W)
        self.mc_r_ideo = tk.StringVar()
        ideos = ["ideology_traditionalist", "ideology_slaver", "ideology_royalist", "ideology_theocrat", "ideology_liberal", "ideology_market_liberal", "ideology_protectionist", "ideology_abolitionist", "ideology_radical", "ideology_republican", "ideology_democrat", "ideology_jingoist", "ideology_pacifist", "ideology_moderate"]
        ttk.Combobox(rul_frame, textvariable=self.mc_r_ideo, values=ideos, state="readonly").grid(row=1, column=3, padx=5)

        # Population Settings
        pop_frame = ttk.LabelFrame(f, text="Population Settings", padding=5)
        pop_frame.pack(fill=tk.X, pady=5)

        ttk.Label(pop_frame, text="Starting Wealth:").grid(row=0, column=0, sticky=tk.W)
        self.mc_pop_wealth = tk.StringVar()
        w_opts = [
            "effect_starting_pop_wealth_low",
            "effect_starting_pop_wealth_medium",
            "effect_starting_pop_wealth_high",
            "effect_starting_pop_wealth_very_high"
        ]
        ttk.Combobox(pop_frame, textvariable=self.mc_pop_wealth, values=w_opts, state="readonly", width=35).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(pop_frame, text="Starting Literacy:").grid(row=0, column=2, sticky=tk.W, padx=(10,0))
        self.mc_pop_lit = tk.StringVar()
        l_opts = [
            "effect_starting_pop_literacy_baseline",
            "effect_starting_pop_literacy_very_low",
            "effect_starting_pop_literacy_low",
            "effect_starting_pop_literacy_middling",
            "effect_starting_pop_literacy_high",
            "effect_starting_pop_literacy_very_high"
        ]
        ttk.Combobox(pop_frame, textvariable=self.mc_pop_lit, values=l_opts, state="readonly", width=35).grid(row=0, column=3, sticky=tk.W, padx=5)

        # Copy from tag
        ttk.Label(pop_frame, text="Copy From Tag:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.mc_pop_copy_tag = tk.StringVar()
        ttk.Entry(pop_frame, textvariable=self.mc_pop_copy_tag, width=10).grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)
        ttk.Button(pop_frame, text="Copy Settings", command=self.copy_pop_settings).grid(row=1, column=2, sticky=tk.W, padx=5, pady=5)

        self.run_btn.config(text="Save Changes", command=self.save_country_mod_changes)

    def load_country_mod_data(self):
        tag = self.logic.format_tag_clean(self.mc_tag.get())
        if not tag: return messagebox.showerror("Error", "Enter a tag.")

        # Identity
        name, adj = self.logic.load_country_localization(tag)
        self.mc_name.set(name)
        self.mc_adj.set(adj)

        # Get extended definition data (includes cultures, religion)
        def_data = self.logic.get_country_data(tag)
        if def_data["cultures"]: self.mc_cultures.set(def_data["cultures"])
        if def_data["religion"]: self.mc_religion.set(def_data["religion"])

        # Populate religion options dynamically
        _, rels, _, _ = self.logic.scan_definitions_for_options()
        # Also include any scanned from files
        r_scanned, _ = self.logic.scan_all_religions_and_heritages()
        all_rels = sorted(list(set(rels + r_scanned)))
        self.mc_religion_cb['values'] = all_rels

        rgb, cap, _ = self.logic.load_country_definition_data(tag)
        if rgb:
            self.mc_rgb = list(rgb)
            self.mc_color_prev.config(bg=self._rgb_to_hex(rgb))
        if cap:
            self.mc_capital.set(cap)

        # History
        hist = self.logic.load_country_history_details(tag)
        self.mc_gov.set(hist["gov_type"])

        # Populate laws if found
        for l in hist["laws"]:
            if "interventionism" in l or "laissez" in l or "command" in l or "traditionalism" in l or "agrarianism" in l: self.mc_law_eco.set("law_" + l if not l.startswith("law_") else l)
            if "free_trade" in l or "protectionism" in l or "isolationism" in l or "mercantilism" in l: self.mc_law_trade.set("law_" + l if not l.startswith("law_") else l)
            if "autocracy" in l or "voting" in l or "anarchy" in l or "oligarchy" in l or "party" in l: self.mc_law_power.set("law_" + l if not l.startswith("law_") else l)

        self.mc_r_first.set(hist["ruler"]["first"])
        self.mc_r_last.set(hist["ruler"]["last"])
        self.mc_r_ig.set(hist["ruler"]["ig"])
        self.mc_r_ideo.set(hist["ruler"]["ideology"])

        # Population
        pop_settings = self.logic.get_pop_history_settings(tag)
        self.mc_pop_wealth.set(pop_settings["wealth"])
        self.mc_pop_lit.set(pop_settings["literacy"])

        self.log_message(f"Loaded data for {tag}", 'success')

    def copy_pop_settings(self):
        src_tag = self.logic.format_tag_clean(self.mc_pop_copy_tag.get())
        if not src_tag: return

        settings = self.logic.get_pop_history_settings(src_tag)
        if settings["wealth"]: self.mc_pop_wealth.set(settings["wealth"])
        if settings["literacy"]: self.mc_pop_lit.set(settings["literacy"])

        self.log_message(f"Copied pop settings from {src_tag}", 'info')

    def save_country_mod_changes(self):
        tag = self.logic.format_tag_clean(self.mc_tag.get())
        if not tag: return

        # Save Loc
        self.logic.save_country_localization(tag, self.mc_name.get(), self.mc_adj.get())

        # Save Def
        _, _, path = self.logic.load_country_definition_data(tag) # Get path
        clean_cap = self.logic.format_state_clean(self.mc_capital.get())

        culs = self.mc_cultures.get().strip().split()
        rel = self.mc_religion.get().strip()

        self.logic.save_country_definition(tag, self.mc_rgb, clean_cap, path, cultures=culs, religion=rel)

        # Save History
        laws = []
        if self.mc_law_eco.get(): laws.append(self.mc_law_eco.get())
        if self.mc_law_trade.get(): laws.append(self.mc_law_trade.get())
        if self.mc_law_power.get(): laws.append(self.mc_law_power.get())

        ruler = {
            "first": self.mc_r_first.get(),
            "last": self.mc_r_last.get(),
            "ig": self.mc_r_ig.get(),
            "ideology": self.mc_r_ideo.get()
        }

        self.logic.save_country_history(tag, self.mc_gov.get(), laws, ruler)

        # Save Pop Settings
        self.logic.save_pop_history_settings(tag, self.mc_pop_wealth.get(), self.mc_pop_lit.get())

        messagebox.showinfo("Success", "Country modifications saved.")

    def pick_color_mod(self):
        init_color = self._rgb_to_hex(self.mc_rgb)
        color = colorchooser.askcolor(color=init_color, title="Choose Country Color")
        if color[0]:
            self.mc_rgb = [int(x) for x in color[0]]
            self.mc_color_prev.config(bg=color[1])

    # --- MODE 6: DIPLOMACY MANAGER ---
    def show_diplomacy_ui(self):
        self.clear_content()
        self.mode = "DIPLOMACY"
        f = ttk.LabelFrame(self.content_frame, text="Diplomacy Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # Tag & Load
        top_frame = ttk.Frame(f)
        top_frame.pack(fill=tk.X, pady=5)
        ttk.Label(top_frame, text="Country Tag:").pack(side=tk.LEFT)
        self.dip_tag = tk.StringVar()
        ttk.Entry(top_frame, textvariable=self.dip_tag, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(top_frame, text="Load Data", command=self.load_diplomacy_ui_data).pack(side=tk.LEFT, padx=5)

        # Lists
        list_frame = ttk.Frame(f)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # Subjects
        sf = ttk.LabelFrame(list_frame, text="Subject Relationships", padding=5)
        sf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0,5))
        self.lb_subjects = tk.Listbox(sf, height=8, bg="#424242", fg="#ECEFF1")
        self.lb_subjects.pack(fill=tk.BOTH, expand=True)
        ttk.Button(sf, text="Remove Selected", command=lambda: self.remove_dip_item("subject")).pack(fill=tk.X)

        # Hostiles
        hf = ttk.LabelFrame(list_frame, text="Hostile / Truces", padding=5)
        hf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5,0))
        self.lb_hostiles = tk.Listbox(hf, height=8, bg="#424242", fg="#ECEFF1")
        self.lb_hostiles.pack(fill=tk.BOTH, expand=True)
        ttk.Button(hf, text="Remove Selected", command=lambda: self.remove_dip_item("hostile")).pack(fill=tk.X)

        # Add New
        add_frame = ttk.LabelFrame(f, text="Add New Relationship", padding=5)
        add_frame.pack(fill=tk.X, pady=5)

        ttk.Label(add_frame, text="Target Tag:").grid(row=0, column=0, sticky=tk.W)
        self.dip_target = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.dip_target, width=10).grid(row=0, column=1, sticky=tk.W, padx=5)

        self.dip_cat = tk.StringVar(value="subject")
        ttk.Radiobutton(add_frame, text="Subject", variable=self.dip_cat, value="subject", command=self.update_dip_type_options).grid(row=0, column=2)
        ttk.Radiobutton(add_frame, text="Hostile/Truce", variable=self.dip_cat, value="hostile", command=self.update_dip_type_options).grid(row=0, column=3)

        self.dip_type_opts = self.logic.SUBJECT_TYPES
        self.dip_type = tk.StringVar()
        self.cb_dip_type = ttk.Combobox(add_frame, textvariable=self.dip_type, values=self.dip_type_opts, state="readonly")
        self.cb_dip_type.grid(row=0, column=4, padx=5)
        self.cb_dip_type.current(0)

        ttk.Button(add_frame, text="Create", command=self.create_diplomacy_pact).grid(row=0, column=5, padx=5)

        # Relations Value
        rel_frame = ttk.LabelFrame(f, text="Set Relations", padding=5)
        rel_frame.pack(fill=tk.X, pady=5)

        ttk.Label(rel_frame, text="Target Tag:").grid(row=0, column=0)
        self.dip_rel_target = tk.StringVar()
        ttk.Entry(rel_frame, textvariable=self.dip_rel_target, width=10).grid(row=0, column=1, padx=5)

        ttk.Label(rel_frame, text="Value (-100 to 100):").grid(row=0, column=2)
        self.dip_rel_val = tk.IntVar(value=0)
        ttk.Entry(rel_frame, textvariable=self.dip_rel_val, width=5).grid(row=0, column=3, padx=5)

        ttk.Button(rel_frame, text="Set Relation", command=self.set_relation_val).grid(row=0, column=4, padx=5)

        self.run_btn.config(text="Refresh Data", command=self.load_diplomacy_ui_data)

    def update_dip_type_options(self):
        cat = self.dip_cat.get()
        if cat == "subject":
            self.dip_type_opts = self.logic.SUBJECT_TYPES
        else:
            self.dip_type_opts = ["rivalry", "embargo", "truce"]
        self.cb_dip_type['values'] = self.dip_type_opts
        self.cb_dip_type.current(0)

    def load_diplomacy_ui_data(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        if not tag: return messagebox.showerror("Error", "Enter a tag.")

        data = self.logic.load_diplomacy_data(tag)

        self.lb_subjects.delete(0, tk.END)
        for s in data["subjects"]:
            self.lb_subjects.insert(tk.END, f"{s['target']} ({s['type']})")

        self.lb_hostiles.delete(0, tk.END)
        for r in data["rivals"]: self.lb_hostiles.insert(tk.END, f"{r} (Rival)")
        for e in data["embargos"]: self.lb_hostiles.insert(tk.END, f"{e} (Embargo)")
        for t in data["truces"]: self.lb_hostiles.insert(tk.END, f"{t['target']} (Truce: {t['months']}m)")

        self.log_message(f"Loaded diplomacy for {tag}", 'success')

    def create_diplomacy_pact(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        target = self.logic.format_tag_clean(self.dip_target.get())
        dtype = self.dip_type.get()
        cat = self.dip_cat.get() # subject or hostile

        if not tag or not target: return messagebox.showerror("Error", "Tags required.")

        real_cat = "subject"
        if cat == "hostile":
            if dtype == "rivalry": real_cat = "rival"
            elif dtype == "embargo": real_cat = "embargo"
            elif dtype == "truce": real_cat = "truce"

        self.logic.add_diplomatic_pact(tag, target, dtype, real_cat)
        self.load_diplomacy_ui_data()

    def remove_dip_item(self, list_type):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        if not tag: return

        sel = None
        if list_type == "subject":
            sel = self.lb_subjects.curselection()
        else:
            sel = self.lb_hostiles.curselection()

        if not sel: return

        text = self.lb_subjects.get(sel[0]) if list_type == "subject" else self.lb_hostiles.get(sel[0])
        # Parse text: "TARGET (TYPE)" or "TARGET (Truce: 12m)"
        target = text.split()[0]
        dtype = ""
        if "Rival" in text: dtype = "rivalry"
        elif "Embargo" in text: dtype = "embargo"
        elif "Truce" in text: dtype = "truce"
        else:
            # Subject type
            dtype = text.split('(')[1].replace(')', '')

        self.logic.remove_diplomatic_pact(tag, target, dtype)
        self.load_diplomacy_ui_data()

    def set_relation_val(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        target = self.logic.format_tag_clean(self.dip_rel_target.get())
        try:
            val = self.dip_rel_val.get()
        except: return

        if not tag or not target: return

        self.logic.set_relations(tag, target, val)
        self.log_message(f"Set relations {tag}<->{target} to {val}")

    # --- MODE 7: POWERBLOCK MANAGER ---
    def show_power_bloc_ui(self):
        self.clear_content()
        self.mode = "POWERBLOC"
        f = ttk.LabelFrame(self.content_frame, text="Powerblock Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # 1. Selector (Tag or Existing Bloc)
        sel_frame = ttk.Frame(f)
        sel_frame.pack(fill=tk.X, pady=5)

        ttk.Label(sel_frame, text="Target Tag:").pack(side=tk.LEFT)
        self.pb_tag = tk.StringVar()
        e_tag = ttk.Entry(sel_frame, textvariable=self.pb_tag, width=10)
        e_tag.pack(side=tk.LEFT, padx=5)
        e_tag.bind("<FocusOut>", lambda e: self.load_pb_data_by_tag())

        ttk.Label(sel_frame, text="OR Select Bloc:").pack(side=tk.LEFT, padx=(15, 5))
        self.pb_select_var = tk.StringVar()
        self.cb_pb_select = ttk.Combobox(sel_frame, textvariable=self.pb_select_var, state="readonly", width=30)
        self.cb_pb_select.pack(side=tk.LEFT, padx=5)
        self.cb_pb_select.bind("<<ComboboxSelected>>", self.on_pb_select)

        ttk.Button(sel_frame, text="Refresh List", command=self.refresh_pb_list).pack(side=tk.LEFT, padx=5)

        # 2. Details Form
        det_frame = ttk.LabelFrame(f, text="Bloc Details", padding=10)
        det_frame.pack(fill=tk.X, pady=5)

        # Name
        ttk.Label(det_frame, text="Name (Key):").grid(row=0, column=0, sticky=tk.W)
        self.pb_name = tk.StringVar()
        ttk.Entry(det_frame, textvariable=self.pb_name, width=25).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)

        # Identity
        ttk.Label(det_frame, text="Identity:").grid(row=0, column=2, sticky=tk.W, padx=(10,0))
        self.pb_identity = tk.StringVar()
        self.cb_pb_identity = ttk.Combobox(det_frame, textvariable=self.pb_identity, state="readonly", width=30)
        self.cb_pb_identity.grid(row=0, column=3, sticky=tk.W, padx=5, pady=2)
        self.cb_pb_identity.bind("<<ComboboxSelected>>", self.refresh_principle_options)

        # Color
        ttk.Label(det_frame, text="Color:").grid(row=1, column=0, sticky=tk.W)
        self.pb_color = tk.StringVar()
        self.pb_color_preview = tk.Label(det_frame, text="     ", bg="#FFFFFF", relief="solid", borderwidth=1, width=10)
        self.pb_color_preview.grid(row=1, column=1, sticky=tk.W, padx=5, pady=2)
        ttk.Button(det_frame, text="Pick Color", command=self.pick_pb_color).grid(row=1, column=2, padx=2)

        # Founding Date
        ttk.Label(det_frame, text="Founding Date:").grid(row=2, column=0, sticky=tk.W)
        self.pb_date = tk.StringVar(value="1836.1.1")
        ttk.Entry(det_frame, textvariable=self.pb_date, width=15).grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)

        # Tag Leader (Info)
        ttk.Label(det_frame, text="Leader Tag:").grid(row=2, column=2, sticky=tk.W, padx=(10,0))
        self.pb_leader_var = tk.StringVar()
        ttk.Entry(det_frame, textvariable=self.pb_leader_var, width=10).grid(row=2, column=3, sticky=tk.W, padx=5)

        # 3. Main Body (Principles + Members)
        main_body = ttk.Frame(f)
        main_body.pack(fill=tk.BOTH, expand=True, pady=5)

        # Left: Principles
        princ_frame = ttk.LabelFrame(main_body, text="Principles", padding=10)
        princ_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))

        self.pb_tree = ttk.Treeview(princ_frame, columns=("key", "level"), show="headings", height=6)
        self.pb_tree.heading("key", text="Principle Key"); self.pb_tree.heading("level", text="Level")
        self.pb_tree.column("key", width=200); self.pb_tree.column("level", width=50, anchor="center")
        self.pb_tree.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        p_ctrl = ttk.Frame(princ_frame)
        p_ctrl.pack(fill=tk.X)
        ttk.Label(p_ctrl, text="Add:").pack(side=tk.LEFT)
        self.pb_princ_add_var = tk.StringVar()
        self.cb_pb_princ_add = ttk.Combobox(p_ctrl, textvariable=self.pb_princ_add_var, state="readonly", width=25)
        self.cb_pb_princ_add.pack(side=tk.LEFT, padx=5)
        self.pb_princ_level = tk.StringVar(value="1")
        ttk.Combobox(p_ctrl, textvariable=self.pb_princ_level, values=["1", "2", "3"], state="readonly", width=3).pack(side=tk.LEFT)
        ttk.Button(p_ctrl, text="+", width=3, command=self.add_pb_principle).pack(side=tk.LEFT, padx=5)
        ttk.Button(p_ctrl, text="Remove", width=7, command=self.remove_pb_principle).pack(side=tk.RIGHT)

        # Right: Members
        memb_frame = ttk.LabelFrame(main_body, text="Members (Subjects are automatically made members)", padding=10)
        memb_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))

        self.lb_members = tk.Listbox(memb_frame, height=6, bg="white", fg="black")
        self.lb_members.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        m_ctrl = ttk.Frame(memb_frame)
        m_ctrl.pack(fill=tk.X)
        ttk.Label(m_ctrl, text="Add Tag:").pack(side=tk.LEFT)
        self.pb_member_add_var = tk.StringVar()
        ttk.Entry(m_ctrl, textvariable=self.pb_member_add_var, width=8).pack(side=tk.LEFT, padx=5)
        ttk.Button(m_ctrl, text="+", width=3, command=self.add_pb_member).pack(side=tk.LEFT)
        ttk.Button(m_ctrl, text="Remove", width=7, command=self.remove_pb_member).pack(side=tk.RIGHT)

        # 4. Actions
        action_bar = ttk.Frame(f)
        action_bar.pack(fill=tk.X, pady=10)

        ttk.Button(action_bar, text="Create / Modify", command=self.save_power_bloc).pack(side=tk.RIGHT, padx=5)
        ttk.Button(action_bar, text="Remove Power Bloc", command=self.delete_power_bloc).pack(side=tk.RIGHT, padx=5)

        # Init
        self.refresh_pb_list()
        self.load_pb_definitions()

    def refresh_pb_list(self):
        blocs = self.logic.get_all_power_blocs()
        self.pb_list_data = blocs
        values = [f"{b['name']} ({b['tag']})" for b in blocs]
        self.cb_pb_select['values'] = values

    def load_pb_definitions(self):
        # Format identities for display
        self.identity_key_map = {}
        self.identity_display_map = {}
        display_values = []

        for key in self.logic.PB_IDENTITIES:
            # identity_trade_league -> Trade League
            clean = key.replace("identity_", "").replace("_", " ").title()
            self.identity_key_map[clean] = key
            self.identity_display_map[key] = clean
            display_values.append(clean)

        self.cb_pb_identity['values'] = display_values

    def refresh_principle_options(self, event=None):
        current_display = self.pb_identity.get()
        # Map back to raw key
        current_id = getattr(self, 'identity_key_map', {}).get(current_display, current_display)

        options = list(self.logic.PB_GLOBAL_PRINCIPLES)

        if current_id in self.logic.PB_EXCLUSIVE_PRINCIPLES:
            options.extend(self.logic.PB_EXCLUSIVE_PRINCIPLES[current_id])

        options = sorted(options)

        # Create map and display list
        self.principle_key_map = {}
        display_values = []
        for key in options:
            clean = key.replace("principle_", "").replace("_", " ").title()
            self.principle_key_map[clean] = key
            display_values.append(clean)

        self.cb_pb_princ_add['values'] = display_values

        # Validate and remove incompatible principles
        exclusive_map = self.logic.PB_EXCLUSIVE_PRINCIPLES
        items_to_remove = []

        for item in self.pb_tree.get_children():
            vals = self.pb_tree.item(item)['values']
            if not vals: continue
            key = vals[0]

            # Check Redundancy
            if current_id == "identity_trade_league" and key == "principle_market_unification":
                items_to_remove.append(item)
                continue

            # Check Exclusive
            is_exclusive = False
            allowed = False
            for ident, p_list in exclusive_map.items():
                if key in p_list:
                    is_exclusive = True
                    if ident == current_id:
                        allowed = True

            if is_exclusive and not allowed:
                items_to_remove.append(item)

        for item in items_to_remove:
            self.pb_tree.delete(item)

    def on_pb_select(self, event):
        idx = self.cb_pb_select.current()
        if idx >= 0:
            tag = self.pb_list_data[idx]['tag']
            self.pb_tag.set(tag)
            self.load_pb_data_by_tag()

    def load_pb_data_by_tag(self):
        tag = self.logic.format_tag_clean(self.pb_tag.get())
        if not tag: return

        self.pb_leader_var.set(tag)

        data = self.logic.get_power_bloc_data(tag)
        # Clear Tree
        for item in self.pb_tree.get_children():
            self.pb_tree.delete(item)

        if data:
            self.pb_name.set(data['name'])
            # Map raw key to display name
            raw_ident = data['identity']
            self.pb_identity.set(getattr(self, 'identity_display_map', {}).get(raw_ident, raw_ident))
            self.pb_color.set(data['map_color'])

            # Parse color for preview
            try:
                vals = re.findall(r"[\d\.]+", data['map_color'])
                if len(vals) >= 3:
                    # Vic3 often uses 0-1 float or 0-255 int or hsv
                    # Simple heuristic: if any > 1, assume int. Else float.
                    # Wait, hsv uses float usually. { 0.99 0.7 0.9 }
                    v1, v2, v3 = float(vals[0]), float(vals[1]), float(vals[2])
                    if "hsv" in data['map_color'].lower():
                        # hsv to rgb conversion is complex, for now let's just skip or default white if hsv
                        # Tkinter doesn't do HSV easily.
                        # If user used Pick Color, we saved as { r g b } ints.
                        # If loading vanilla file, it might be hsv.
                        # Just show white if complex.
                        self.pb_color_preview.config(bg="#FFFFFF")
                    else:
                        if v1 <= 1.0 and v2 <= 1.0 and v3 <= 1.0:
                            v1, v2, v3 = int(v1*255), int(v2*255), int(v3*255)
                        else:
                            v1, v2, v3 = int(v1), int(v2), int(v3)
                        hex_col = f'#{v1:02x}{v2:02x}{v3:02x}'
                        self.pb_color_preview.config(bg=hex_col)
            except:
                self.pb_color_preview.config(bg="#FFFFFF")

            self.pb_date.set(data['date'])
            self.pb_current_members = data.get("members", [])

            for p in data['principles']:
                self.pb_tree.insert("", tk.END, values=(p["key"], p["level"]))

            self.refresh_principle_options()
            self.refresh_members_list()
            self.log_message(f"Loaded Power Bloc for {tag}", 'success')
        else:
            self.pb_name.set("")
            self.pb_identity.set("")
            self.pb_color.set("")
            self.pb_color_preview.config(bg="#FFFFFF")
            self.pb_date.set("1836.1.1")
            self.pb_current_members = []
            self.refresh_members_list()
            self.refresh_principle_options()
            self.log_message(f"No existing Power Bloc for {tag}. Ready to create.", 'info')

    def refresh_members_list(self):
        self.lb_members.delete(0, tk.END)
        for m in self.pb_current_members:
            self.lb_members.insert(tk.END, m)

    def add_pb_member(self):
        val = self.logic.format_tag_clean(self.pb_member_add_var.get())
        if val:
            full_val = f"c:{val}" if not val.startswith("c:") else val
            if full_val not in self.pb_current_members:
                self.pb_current_members.append(full_val)
                self.refresh_members_list()
                self.pb_member_add_var.set("")

    def remove_pb_member(self):
        sel = self.lb_members.curselection()
        if sel:
            idx = sel[0]
            val = self.lb_members.get(idx)
            if val in self.pb_current_members:
                self.pb_current_members.remove(val)
                self.refresh_members_list()

    def pick_pb_color(self):
        color = colorchooser.askcolor(title="Choose Map Color")
        if color[0]:
            r, g, b = int(color[0][0]), int(color[0][1]), int(color[0][2])
            self.pb_color.set(f"{{ {r} {g} {b} }}")
            self.pb_color_preview.config(bg=color[1])

    def add_pb_principle(self):
        display = self.pb_princ_add_var.get()
        # Look up key from display map, or use as is if not found (fallback)
        key = getattr(self, 'principle_key_map', {}).get(display, display)

        try:
            level = int(self.pb_princ_level.get())
        except: level = 1

        if not key: return

        current_display = self.pb_identity.get()
        current_id = getattr(self, 'identity_key_map', {}).get(current_display, current_display)

        # VALIDATION RULES

        # 1. Identity Lock
        exclusive_map = self.logic.PB_EXCLUSIVE_PRINCIPLES
        is_exclusive = False
        allowed_for_current = False

        for ident, p_list in exclusive_map.items():
            if key in p_list:
                is_exclusive = True
                if ident == current_id:
                    allowed_for_current = True

        if is_exclusive and not allowed_for_current:
            return messagebox.showerror("Validation Error", f"Principle '{key}' is not allowed for identity '{current_id}'.")

        # 2. Uniqueness
        for item in self.pb_tree.get_children():
            vals = self.pb_tree.item(item)['values']
            if vals[0] == key:
                return messagebox.showerror("Validation Error", f"Principle '{key}' is already added.")

        # 3. Trade League Redundancy
        if current_id == "identity_trade_league" and key == "principle_market_unification":
            return messagebox.showerror("Validation Error", "Trade Leagues automatically function as a Customs Union; this principle is redundant.")

        # Add to Tree
        self.pb_tree.insert("", tk.END, values=(key, level))

    def remove_pb_principle(self):
        sel = self.pb_tree.selection()
        if sel:
            self.pb_tree.delete(sel[0])

    def save_power_bloc(self):
        # Original tag loaded/selected
        orig_tag = self.logic.format_tag_clean(self.pb_tag.get())

        # New tag from leader field
        new_tag = self.logic.format_tag_clean(self.pb_leader_var.get())

        if not new_tag: return messagebox.showerror("Error", "Leader Tag required.")

        name = self.pb_name.get().strip()
        display_identity = self.pb_identity.get().strip()
        identity = getattr(self, 'identity_key_map', {}).get(display_identity, display_identity)
        color = self.pb_color.get().strip()
        date = self.pb_date.get().strip()

        principles = []
        for item in self.pb_tree.get_children():
            vals = self.pb_tree.item(item)['values']
            principles.append({"key": vals[0], "level": int(vals[1])})

        if not name or not identity: return messagebox.showerror("Error", "Name and Identity required.")

        # Check Primary Principle Requirement
        req_principles = self.logic.PB_PRIMARY_PRINCIPLE_OPTIONS.get(identity, [])
        has_req = False
        for p in principles:
            if p["key"] in req_principles:
                has_req = True
                break

        if req_principles and not has_req:
             # Create nice string for warning
             req_names = [p.replace("principle_", "").replace("_", " ").title() for p in req_principles]
             msg = f"The identity '{identity}' requires at least one of these principles:\n" + "\n".join(req_names)
             messagebox.showwarning("Validation Error", msg)
             return

        if not hasattr(self, 'pb_current_members'):
             self.pb_current_members = []

        data = {
            "name": name,
            "identity": identity,
            "map_color": color,
            "date": date,
            "principles": principles,
            "members": self.pb_current_members
        }

        # If tag changed, remove old and save new
        if orig_tag and orig_tag != new_tag:
            if messagebox.askyesno("Confirm", f"Move Power Bloc from {orig_tag} to {new_tag}?"):
                self.logic.remove_power_bloc(orig_tag)
                self.pb_tag.set(new_tag) # Update current tag

        self.logic.save_power_bloc_data(new_tag, data)
        self.refresh_pb_list()
        messagebox.showinfo("Success", f"Power Bloc saved for {new_tag}.")

    def delete_power_bloc(self):
        tag = self.logic.format_tag_clean(self.pb_tag.get())
        if not tag: return

        if messagebox.askyesno("Confirm", f"Remove Power Bloc for {tag}?"):
            self.logic.remove_power_bloc(tag)
            self.refresh_pb_list()
            self.load_pb_data_by_tag()

    def refresh_all_dropdowns(self):
        """Re-scans data and updates dropdowns across the application."""
        # 1. Religions & Cultures
        c_opts, _, _, _, _, _ = self.logic.scan_culture_definitions()
        all_culs = sorted(list(c_opts.keys()))

        _, r_opts = self.logic.scan_all_religions_and_heritages()
        r_all, _ = self.logic.scan_all_religions_and_heritages()
        _, def_rels, _, _ = self.logic.scan_definitions_for_options()
        all_rels = sorted(list(set(r_all + def_rels)))

        # State Manager Dropdowns
        if hasattr(self, 'cb_homeland_add'): self.cb_homeland_add['values'] = all_culs
        if hasattr(self, 'cb_pop_cul'): self.cb_pop_cul['values'] = all_culs
        if hasattr(self, 'cb_pop_rel'): self.cb_pop_rel['values'] = all_rels

        # Culture/Religion Creator Dropdowns
        if hasattr(self, 'rc_c_rel'):
             # Update scanning for just keys if needed, but r_keys var was local.
             # scan_all_religions returns keys, heritages
             keys, _ = self.logic.scan_all_religions_and_heritages()
             self.rc_c_rel['values'] = keys

        # Create Country Dropdowns if needed
        if hasattr(self, 'cb_cultures'):
             # Create country uses scan_definitions_for_options mostly, but could benefit from new ones
             # Re-run scan_definitions_for_options
             all_c, _, _, _ = self.logic.scan_definitions_for_options()
             # We should probably merge scanned cultures from definitions AND files if creating new ones
             # For now, let's just stick to the requested scope
             pass

        self.log_message("Dropdowns refreshed with latest data.", 'info')

    # --- SHARED FUNCTIONS ---
    def browse_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.path_var.set(folder)
            self.logic.set_mod_path(folder)
            self.save_config()
            self.log_message(f"Selected Mod Path: {folder}")

    def browse_vanilla_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.vanilla_path_var.set(folder)
            self.logic.set_vanilla_path(folder)
            self.save_config()
            self.log_message(f"Selected Vanilla Path: {folder}")

    def log_message(self, message, level='info'):
        self.log_queue.put((message, level))

    def process_log_queue(self):
        while not self.log_queue.empty():
            msg, level = self.log_queue.get()
            self.log_area.config(state='normal')
            self.log_area.insert(tk.END, msg.strip() + "\n", level)
            self.log_area.see(tk.END)
            self.log_area.config(state='disabled')
        self.after(100, self.process_log_queue)

    def start_transfer(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        old = self.logic.format_tag_clean(self.tr_old_tag.get())
        new = self.logic.format_tag_clean(self.tr_new_tag.get())
        annex = self.tr_annex.get()
        raw_st = self.tr_states.get("1.0", tk.END)
        if not old or not new: return messagebox.showerror("Error", "Tags required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_transfer_logic, args=(old, new, annex, raw_st), daemon=True).start()

    def start_create(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.cr_tag.get())
        name = self.cr_name.get().strip()
        adj = self.cr_adj.get().strip()
        old_owner = self.logic.format_tag_clean(self.cr_old_owner.get())
        capital = self.logic.format_state_clean(self.cr_capital.get())
        others_raw = self.cr_others.get("1.0", tk.END)
        gov = self.cr_gov.get()
        rgb = self.cr_rgb
        is_annex = self.cr_annex.get()

        tier = self.cr_tier.get()
        country_type = self.cr_type.get()
        cultures = self.selected_cultures
        religion = self.cr_religion.get()

        pop_wealth = self.cr_pop_wealth.get()
        pop_lit = self.cr_pop_lit.get()

        if not tag or not name or not old_owner: return messagebox.showerror("Error", "Tag, Name, and Old Owner are required.")
        if not is_annex and not capital: return messagebox.showerror("Error", "Capital State ID required unless Full Annexation.")
        if len(tag) != 3: return messagebox.showerror("Error", "Tag must be exactly 3 characters.")

        # Pre-fetch old owner data to minimize redundant calls
        data = self.logic.get_country_data(old_owner)

        # If cultures were not manually selected, default to old owner's data
        if not cultures:
            if data["cultures"]:
                cultures = data["cultures"].split()

        # If religion is not manually selected, check old owner, then check culture
        if not religion:
            if data["religion"]:
                religion = data["religion"]
            else:
                # Attempt to find religion from the primary culture
                found_rel = None
                if cultures:
                    prim_culture = cultures[0]
                    self.log_message(f"[INFO] Religion missing. searching in culture '{prim_culture}'...", 'info')
                    found_rel = self.logic.get_religion_by_culture(prim_culture)
                
                if found_rel:
                    religion = found_rel
                    self.log_message(f"[INFO] Found religion '{religion}' from culture '{prim_culture}'.", 'success')
                else:
                    self.log_message(f"[WARN] Religion not found for {old_owner} or culture. Defaulting to 'catholic'.", 'warn')
                    religion = "catholic"

        if not cultures: return messagebox.showerror("Error", "At least one culture required.")
        # Religion check removed, effectively allowing the process to continue even if religion wasn't found (defaulted to catholic)

        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_create_logic, args=(tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type, pop_wealth, pop_lit), daemon=True).start()

    # --- LOGIC THREADS ---
    def run_transfer_logic(self, old_tag, new_tag, is_annex, raw_states):
        try:
            self.log_message(f"--- Processing Transfer: {old_tag} -> {new_tag} ---", 'info')
            states_clean = []
            if is_annex:
                self.log_message(f"[INFO] Detecting states owned by {old_tag}...", 'info')
                states_clean = self.logic.get_all_owned_states(old_tag)
                if not states_clean:
                    self.log_message(f"[WARN] No states found for {old_tag}.", 'warn')
                    return
            else:
                states_clean = [self.logic.format_state_clean(s) for s in raw_states.split() if s.strip()]
                if not states_clean: return self.log_message("[ERROR] No states provided.", 'error')
            self.execute_transfer_core(states_clean, old_tag, new_tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_create_logic(self, tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type, pop_wealth, pop_lit):
        try:
            self.log_message(f"--- Creating Country: {tag} ({name}) ---", 'info')
            if self.logic.tag_exists(tag):
                self.log_message(f"[ERROR] Tag {tag} already exists in common/country_definitions!", 'error')
                return

            # (Old owner data logic is now partly in UI for prepopulation, but we still need capital logic if annexing)
            data = self.logic.get_country_data(old_owner)
            
            all_states = []
            if is_annex:
                self.log_message(f"[INFO] Full Annexation selected. Detecting all states for {old_owner}...", 'info')
                found_states = self.logic.get_all_owned_states(old_owner)
                if not found_states:
                    self.log_message(f"[WARN] No states found for {old_owner} to annex.", 'warn')
                    return
                all_states = found_states
                
                # If capital input is blank, use old owner's capital
                if not capital:
                    if data["capital"]:
                        capital = data["capital"]
                        self.log_message(f"[INFO] Auto-detected capital: {capital}", 'info')
                    elif all_states:
                        capital = all_states[0] # Fallback to first found state
                        self.log_message(f"[WARN] Capital undefined in old owner. Using first state: {capital}", 'warn')
                    else:
                        self.log_message("[ERROR] Cannot determine capital state.", 'error')
                        return
            else:
                others = [self.logic.format_state_clean(s) for s in others_raw.split() if s.strip()]
                all_states = [capital] + others

            self.logic.create_country_files(tag, name, adj, capital, gov, rgb, cultures, religion, tier, country_type, old_owner, pop_wealth, pop_lit)
            
            self.log_message("--- Transferring Land & Units ---", 'info')
            self.execute_transfer_core(all_states, old_owner, tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_army_logic(self, tag, name, state, inf, art, cav):
        try:
            self.log_message(f"--- Creating Army Template for {tag} ---", 'info')
            self.logic.create_army_file(tag, name, state, inf, art, cav)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_navy_logic(self, tag, name, state, man, frig, iron):
        try:
            self.log_message(f"--- Creating Navy Template for {tag} ---", 'info')
            self.logic.create_navy_file(tag, name, state, man, frig, iron)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def execute_transfer_core(self, states_clean, old_tag, new_tag):
        self.log_message("--- Processing Map Data ---")
        self.logic.transfer_ownership_batch(states_clean, old_tag, new_tag)
        regions_to_process = {}
        for state in states_clean:
            reg = self.logic.find_strategic_region(f"s:{state}")
            if reg:
                if reg not in regions_to_process: regions_to_process[reg] = []
                regions_to_process[reg].append(state)
        self.log_message("--- Processing Military Formations ---")
        for reg, states in regions_to_process.items():
            self.log_message(f" -> Scanning region: {reg}")
            self.logic.clean_military_smart(old_tag, new_tag, reg, states)
        self.log_message("--- Validating Character Links ---")
        valid_scopes = self.logic.collect_valid_scopes()
        self.logic.prune_orphaned_commanders(valid_scopes)
        self.log_message("Done.", 'success')

    # --- MODE 8: RELIGION & CULTURE ---
    def show_rel_cul_ui(self):
        self.clear_content()
        self.mode = "REL_CUL"
        f = ttk.LabelFrame(self.content_frame, text="Religion & Culture Creator", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        tabs = ttk.Notebook(f)
        tabs.pack(fill=tk.BOTH, expand=True, pady=5)

        tab_cult = ttk.Frame(tabs)
        tab_rel = ttk.Frame(tabs)
        tabs.add(tab_cult, text="Create Culture")
        tabs.add(tab_rel, text="Create Religion")

        # --- Create Culture UI ---
        # Scan data
        c_data, c_heritages, c_langs, c_trads, c_graphics, c_eths = self.logic.scan_culture_definitions()
        # Scan religions for dropdown
        r_keys, r_heritages = self.logic.scan_all_religions_and_heritages()

        # Store data for use
        self.cult_scan_data = c_data

        # Build maps for clean display
        self.heritage_map = {h.replace("heritage_", "").replace("_", " ").title(): h for h in c_heritages}
        self.lang_map = {l.replace("language_", "").replace("_", " ").title(): l for l in c_langs}
        self.trad_map = {t.replace("tradition_", "").replace("_", " ").title(): t for t in c_trads}

        # Form
        cf = ttk.Frame(tab_cult, padding=10)
        cf.pack(fill=tk.BOTH, expand=True)

        ttk.Label(cf, text="Internal Key (e.g. new_culture):").grid(row=0, column=0, sticky=tk.W)
        self.rc_c_key = tk.StringVar()
        ttk.Entry(cf, textvariable=self.rc_c_key, width=20).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Label(cf, text="Localization Name:").grid(row=0, column=2, sticky=tk.W)
        self.rc_c_name = tk.StringVar()
        ttk.Entry(cf, textvariable=self.rc_c_name, width=20).grid(row=0, column=3, sticky=tk.W, padx=5, pady=2)

        ttk.Label(cf, text="Color:").grid(row=1, column=0, sticky=tk.W)
        self.rc_c_rgb = [255, 255, 255]
        self.rc_c_color_prev = tk.Label(cf, text="     ", bg="#FFFFFF", relief="solid", borderwidth=1)
        self.rc_c_color_prev.grid(row=1, column=1, sticky=tk.W, padx=5)
        ttk.Button(cf, text="Pick", command=self.pick_cult_color).grid(row=1, column=2, sticky=tk.W)

        # Dropdowns
        ttk.Label(cf, text="Religion:").grid(row=2, column=0, sticky=tk.W)
        self.rc_c_rel = tk.StringVar()
        ttk.Combobox(cf, textvariable=self.rc_c_rel, values=r_keys, state="readonly").grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Label(cf, text="Heritage:").grid(row=2, column=2, sticky=tk.W)
        self.rc_c_her = tk.StringVar()
        ttk.Combobox(cf, textvariable=self.rc_c_her, values=sorted(list(self.heritage_map.keys())), state="readonly").grid(row=2, column=3, sticky=tk.W, padx=5, pady=2)

        ttk.Label(cf, text="Language:").grid(row=3, column=0, sticky=tk.W)
        self.rc_c_lang = tk.StringVar()
        ttk.Combobox(cf, textvariable=self.rc_c_lang, values=sorted(list(self.lang_map.keys())), state="readonly").grid(row=3, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Label(cf, text="Graphics:").grid(row=3, column=2, sticky=tk.W)
        self.rc_c_graph = tk.StringVar()
        ttk.Combobox(cf, textvariable=self.rc_c_graph, values=c_graphics, state="readonly").grid(row=3, column=3, sticky=tk.W, padx=5, pady=2)

        # Names Source
        ttk.Label(cf, text="Copy Names From (Existing Culture):").grid(row=4, column=0, sticky=tk.W, pady=(10, 2))
        self.rc_c_namesrc = tk.StringVar()
        ttk.Combobox(cf, textvariable=self.rc_c_namesrc, values=sorted(list(c_data.keys())), state="readonly").grid(row=4, column=1, sticky=tk.W, padx=5)

        # Traditions & Ethnicities (Lists)
        list_frame = ttk.Frame(cf)
        list_frame.grid(row=5, column=0, columnspan=4, sticky=tk.NSEW, pady=10)

        # Traditions
        tf = ttk.LabelFrame(list_frame, text="Traditions", padding=5)
        tf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        self.rc_c_trad_list = tk.Listbox(tf, height=6, bg="white", fg="black", selectmode=tk.MULTIPLE, exportselection=False)
        self.rc_c_trad_list.pack(fill=tk.BOTH, expand=True)
        for t in sorted(list(self.trad_map.keys())): self.rc_c_trad_list.insert(tk.END, t)

        # Ethnicities
        ef = ttk.LabelFrame(list_frame, text="Ethnicities", padding=5)
        ef.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))
        self.rc_c_eth_list = tk.Listbox(ef, height=6, bg="white", fg="black", selectmode=tk.MULTIPLE, exportselection=False)
        self.rc_c_eth_list.pack(fill=tk.BOTH, expand=True)
        for e in c_eths: self.rc_c_eth_list.insert(tk.END, e)

        ttk.Button(cf, text="Save New Culture", command=self.save_new_culture_ui).grid(row=6, column=3, sticky=tk.E, pady=10)

        # --- Create Religion UI ---
        rf = ttk.Frame(tab_rel, padding=10)
        rf.pack(fill=tk.BOTH, expand=True)

        ttk.Label(rf, text="Internal Key (e.g. protestant):").grid(row=0, column=0, sticky=tk.W)
        self.rc_r_key = tk.StringVar()
        ttk.Entry(rf, textvariable=self.rc_r_key, width=20).grid(row=0, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Label(rf, text="Localization Name:").grid(row=0, column=2, sticky=tk.W)
        self.rc_r_name = tk.StringVar()
        ttk.Entry(rf, textvariable=self.rc_r_name, width=20).grid(row=0, column=3, sticky=tk.W, padx=5, pady=2)

        ttk.Label(rf, text="Color:").grid(row=1, column=0, sticky=tk.W)
        self.rc_r_rgb = [255, 255, 255]
        self.rc_r_color_prev = tk.Label(rf, text="     ", bg="#FFFFFF", relief="solid", borderwidth=1)
        self.rc_r_color_prev.grid(row=1, column=1, sticky=tk.W, padx=5)
        ttk.Button(rf, text="Pick", command=self.pick_rel_color).grid(row=1, column=2, sticky=tk.W)

        ttk.Label(rf, text="Heritage:").grid(row=2, column=0, sticky=tk.W)
        self.rc_r_her = tk.StringVar()
        ttk.Combobox(rf, textvariable=self.rc_r_her, values=r_heritages, state="readonly").grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Label(rf, text="Icon Path:").grid(row=3, column=0, sticky=tk.W)
        self.rc_r_icon = tk.StringVar(value="gfx/interface/icons/religion_icons/protestant.dds")
        ttk.Entry(rf, textvariable=self.rc_r_icon, width=40).grid(row=3, column=1, columnspan=3, sticky=tk.W, padx=5, pady=2)

        ttk.Button(rf, text="Save New Religion", command=self.save_new_religion_ui).grid(row=4, column=3, sticky=tk.E, pady=10)

        self.run_btn.config(text="Ready", state="disabled")

    def pick_cult_color(self):
        color = colorchooser.askcolor(title="Culture Color")
        if color[0]:
            self.rc_c_rgb = [int(x) for x in color[0]]
            self.rc_c_color_prev.config(bg=color[1])

    def pick_rel_color(self):
        color = colorchooser.askcolor(title="Religion Color")
        if color[0]:
            self.rc_r_rgb = [int(x) for x in color[0]]
            self.rc_r_color_prev.config(bg=color[1])

    def save_new_culture_ui(self):
        key = self.rc_c_key.get().strip()
        name = self.rc_c_name.get().strip()
        if not key or not name: return messagebox.showerror("Error", "Key and Name required.")

        if not self.rc_c_rel.get(): return messagebox.showerror("Error", "Religion required.")
        if not self.rc_c_her.get(): return messagebox.showerror("Error", "Heritage required.")
        if not self.rc_c_lang.get(): return messagebox.showerror("Error", "Language required.")
        if not self.rc_c_graph.get(): return messagebox.showerror("Error", "Graphics required.")

        # Map values back from display names
        display_her = self.rc_c_her.get()
        raw_her = self.heritage_map.get(display_her, display_her)

        display_lang = self.rc_c_lang.get()
        raw_lang = self.lang_map.get(display_lang, display_lang)

        # Get list selections and map back
        trads = []
        for i in self.rc_c_trad_list.curselection():
            display_t = self.rc_c_trad_list.get(i)
            trads.append(self.trad_map.get(display_t, display_t))

        eths = [self.rc_c_eth_list.get(i) for i in self.rc_c_eth_list.curselection()]

        # Names
        name_src = self.rc_c_namesrc.get()
        name_data = {}
        if name_src and name_src in self.cult_scan_data:
             name_data = self.cult_scan_data[name_src]

        self.logic.save_new_culture(
             key, name, self.rc_c_rgb,
             self.rc_c_rel.get(), raw_her, raw_lang,
             trads, self.rc_c_graph.get(), eths, name_data
        )
        self.refresh_all_dropdowns()
        messagebox.showinfo("Success", f"Culture {key} saved.")

    def save_new_religion_ui(self):
        key = self.rc_r_key.get().strip()
        name = self.rc_r_name.get().strip()
        if not key or not name: return messagebox.showerror("Error", "Key and Name required.")

        if not self.rc_r_her.get(): return messagebox.showerror("Error", "Heritage required.")

        self.logic.save_new_religion(
             key, name, self.rc_r_rgb, self.rc_r_her.get(), self.rc_r_icon.get()
        )
        self.refresh_all_dropdowns()
        messagebox.showinfo("Success", f"Religion {key} saved.")

    # --- MODE 9: JOURNAL MANAGER ---
    def show_journal_ui(self):
        self.clear_content()
        self.mode = "JOURNAL_MANAGER"
        f = ttk.LabelFrame(self.content_frame, text="Journal Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # Columns
        col1 = ttk.Frame(f)
        col1.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        col2 = ttk.Frame(f)
        col2.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        col3 = ttk.Frame(f)
        col3.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        # --- Column 1: Settings ---
        ttk.Label(col1, text="Settings", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W, pady=5)

        ttk.Label(col1, text="ID (e.g. je_unite_tribes):").pack(anchor=tk.W)
        self.je_id = tk.StringVar()
        ttk.Entry(col1, textvariable=self.je_id).pack(fill=tk.X, pady=2)

        ttk.Label(col1, text="Title:").pack(anchor=tk.W)
        self.je_title = tk.StringVar()
        ttk.Entry(col1, textvariable=self.je_title).pack(fill=tk.X, pady=2)

        ttk.Label(col1, text="Description:").pack(anchor=tk.W)
        self.je_desc = tk.Text(col1, height=5, width=30, bg="#424242", fg="#ECEFF1", relief="flat")
        self.je_desc.pack(fill=tk.X, pady=2)

        ttk.Label(col1, text="Icon: event_default.dds").pack(anchor=tk.W, pady=10)

        # --- Column 2: Triggers ---
        ttk.Label(col2, text="Triggers", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W, pady=5)

        # Activation
        ttk.Label(col2, text="Activation (Possible):").pack(anchor=tk.W)
        self.lb_je_activation = tk.Listbox(col2, height=6, bg="#424242", fg="#ECEFF1")
        self.lb_je_activation.pack(fill=tk.X, pady=2)

        act_ctrl = ttk.Frame(col2)
        act_ctrl.pack(fill=tk.X)
        self.je_act_type = tk.StringVar()
        self.cb_je_act = ttk.Combobox(act_ctrl, textvariable=self.je_act_type, state="readonly", width=15)
        self.cb_je_act.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(act_ctrl, text="+", width=3, command=lambda: self.add_je_item("activation")).pack(side=tk.LEFT)
        ttk.Button(act_ctrl, text="-", width=3, command=lambda: self.remove_je_item("activation")).pack(side=tk.LEFT)

        # Completion
        ttk.Label(col2, text="Completion (Complete):").pack(anchor=tk.W, pady=(10, 0))
        self.lb_je_completion = tk.Listbox(col2, height=6, bg="#424242", fg="#ECEFF1")
        self.lb_je_completion.pack(fill=tk.X, pady=2)

        comp_ctrl = ttk.Frame(col2)
        comp_ctrl.pack(fill=tk.X)
        self.je_comp_type = tk.StringVar()
        self.cb_je_comp = ttk.Combobox(comp_ctrl, textvariable=self.je_comp_type, state="readonly", width=15)
        self.cb_je_comp.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(comp_ctrl, text="+", width=3, command=lambda: self.add_je_item("completion")).pack(side=tk.LEFT)
        ttk.Button(comp_ctrl, text="-", width=3, command=lambda: self.remove_je_item("completion")).pack(side=tk.LEFT)

        # --- Column 3: Rewards ---
        ttk.Label(col3, text="Rewards (On Complete)", font=('Segoe UI', 10, 'bold')).pack(anchor=tk.W, pady=5)

        self.lb_je_rewards = tk.Listbox(col3, height=15, bg="#424242", fg="#ECEFF1")
        self.lb_je_rewards.pack(fill=tk.X, pady=2)

        rew_ctrl = ttk.Frame(col3)
        rew_ctrl.pack(fill=tk.X)
        self.je_rew_type = tk.StringVar()
        self.cb_je_rew = ttk.Combobox(rew_ctrl, textvariable=self.je_rew_type, state="readonly", width=15)
        self.cb_je_rew.pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Button(rew_ctrl, text="+", width=3, command=lambda: self.add_je_item("reward")).pack(side=tk.LEFT)
        ttk.Button(rew_ctrl, text="-", width=3, command=lambda: self.remove_je_item("reward")).pack(side=tk.LEFT)

        # Populate Options
        self.je_act_opts = ["Is Country (Tag)", "Primary Culture", "Has Technology", "Has Law", "Is Great Power", "Is At War", "GDP Check"]
        self.je_comp_opts = ["Own State Region", "Building Count", "Literacy Rate", "Gold Reserves", "Battalion Count"]
        self.je_rew_opts = ["Add Treasury", "Add Prestige", "Add Loyalists", "Add Radicals", "Trigger Event", "Add Modifier"]

        self.cb_je_act['values'] = self.je_act_opts
        self.cb_je_act.current(0)
        self.cb_je_comp['values'] = self.je_comp_opts
        self.cb_je_comp.current(0)
        self.cb_je_rew['values'] = self.je_rew_opts
        self.cb_je_rew.current(0)

        self.run_btn.config(text="Save Journal Entry", command=self.save_journal_entry_ui)

    def add_je_item(self, list_type):
        # Dialog for input
        val = None
        sel_type = ""

        if list_type == "activation":
            sel_type = self.je_act_type.get()
            if sel_type == "Is Country (Tag)":
                tags = self.logic.scan_all_tags()
                val = self.ask_popup_input("Select Tag", tags)
                if val: val = f"this = c:{val.upper()}"
            elif sel_type == "Primary Culture":
                c_opts, _, _, _, _, _ = self.logic.scan_culture_definitions()
                all_culs = sorted(list(c_opts.keys()))
                val = self.ask_popup_input("Select Culture", all_culs)
                if val: val = f"country_has_primary_culture = cu:{val}"
            elif sel_type == "Has Technology":
                techs = self.logic.scan_technologies()
                val = self.ask_popup_input("Select Technology", techs)
                if val: val = f"has_technology = {val}"
            elif sel_type == "Has Law":
                laws = self.logic.scan_laws()
                val = self.ask_popup_input("Select Law", laws)
                if val: val = f"has_law = {val}"
            elif sel_type == "Is Great Power":
                val = "is_great_power = yes"
            elif sel_type == "Is At War":
                val = "is_at_war = yes"
            elif sel_type == "GDP Check":
                num = simpledialog.askfloat("Input", "GDP Value:")
                if num: val = f"gdp > {int(num)}"

        elif list_type == "completion":
            sel_type = self.je_comp_type.get()
            if sel_type == "Own State Region":
                # Assuming state scanning logic is generic or we have a list of states
                # Using hardcoded or existing scan? logic.format_state_clean implies input string
                # Let's ask for string or offer list if we can easily get all states (Vic3Logic doesn't have scan_all_states yet but Transfer uses input)
                # Let's stick to text input for state for now or scan file names in history/states?
                # Actually, logic.get_state_homelands uses scan.
                # Let's ask for simple text input for simplicity
                st = simpledialog.askstring("Input", "State Name (e.g. california):")
                if st: val = f"owns_entire_state_region = STATE_{st.upper()}"
            elif sel_type == "Building Count":
                bldgs = self.logic.scan_buildings()
                b = self.ask_popup_input("Select Building", bldgs)
                lvl = simpledialog.askinteger("Input", "Level >=")
                if b and lvl: val = f"scope:country = {{ has_building_level = {{ building = {b} level >= {lvl} }} }}"
            elif sel_type == "Literacy Rate":
                r = simpledialog.askfloat("Input", "Rate (0.0 - 1.0):")
                if r: val = f"literacy_rate >= {r}"
            elif sel_type == "Gold Reserves":
                num = simpledialog.askinteger("Input", "Amount:")
                if num: val = f"gold_reserves >= {num}"
            elif sel_type == "Battalion Count":
                num = simpledialog.askinteger("Input", "Count:")
                if num: val = f"army_size >= {num}"

        elif list_type == "reward":
            sel_type = self.je_rew_type.get()
            if sel_type == "Add Treasury":
                num = simpledialog.askinteger("Input", "Amount:")
                if num: val = f"add_treasury = {num}"
            elif sel_type == "Add Prestige":
                num = simpledialog.askinteger("Input", "Amount:")
                if num: val = f"add_prestige = {num}"
            elif sel_type == "Add Loyalists":
                r = simpledialog.askfloat("Input", "Value (0.0 - 1.0):")
                if r: val = f"add_loyalists = {{ value = {r} }}"
            elif sel_type == "Add Radicals":
                r = simpledialog.askfloat("Input", "Value (0.0 - 1.0):")
                if r: val = f"add_radicals = {{ value = {r} }}"
            elif sel_type == "Trigger Event":
                evt = simpledialog.askstring("Input", "Event ID:")
                if evt: val = f"trigger_event = {evt}"
            elif sel_type == "Add Modifier":
                name = simpledialog.askstring("Input", "Modifier Name:")
                dur = simpledialog.askinteger("Input", "Months:")
                if name and dur: val = f"add_modifier = {{ name = {name} months = {dur} }}"

        if val:
            if list_type == "activation": self.lb_je_activation.insert(tk.END, val)
            elif list_type == "completion": self.lb_je_completion.insert(tk.END, val)
            elif list_type == "reward": self.lb_je_rewards.insert(tk.END, val)

    def remove_je_item(self, list_type):
        lb = None
        if list_type == "activation": lb = self.lb_je_activation
        elif list_type == "completion": lb = self.lb_je_completion
        elif list_type == "reward": lb = self.lb_je_rewards

        sel = lb.curselection()
        if sel: lb.delete(sel[0])

    def ask_popup_input(self, title, options):
        # A simple dialog to select from list
        # Since simpledialog doesn't support Combobox, we build a custom toplevel

        result = [None]

        win = tk.Toplevel(self)
        win.title(title)
        win.geometry("300x100")
        win.transient(self)
        win.grab_set()

        # Center on parent
        x = self.winfo_rootx() + 50
        y = self.winfo_rooty() + 50
        win.geometry(f"+{x}+{y}")

        cb = ttk.Combobox(win, values=options, state="normal") # Allow typing for filter
        cb.pack(pady=10, padx=10, fill=tk.X)
        cb.focus_set()

        def on_ok():
            result[0] = cb.get()
            win.destroy()

        ttk.Button(win, text="OK", command=on_ok).pack()
        self.wait_window(win)
        return result[0]

    def save_journal_entry_ui(self):
        if not self.je_id.get(): return messagebox.showerror("Error", "ID required.")
        if not self.je_title.get(): return messagebox.showerror("Error", "Title required.")

        data = {
            "id": self.je_id.get().strip(),
            "title": self.je_title.get().strip(),
            "desc": self.je_desc.get("1.0", tk.END).strip(),
            "activation": self.lb_je_activation.get(0, tk.END),
            "completion": self.lb_je_completion.get(0, tk.END),
            "rewards": self.lb_je_rewards.get(0, tk.END)
        }

        self.logic.save_journal_entry(data)
        messagebox.showinfo("Success", f"Journal Entry {data['id']} saved.")

    # --- MODE 10: STATE MANAGER (Index shifted) ---
    def show_state_manager_ui(self):
        self.clear_content()
        self.mode = "STATE_MANAGER"
        f = ttk.LabelFrame(self.content_frame, text="State Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # 1. State Selector
        sel_frame = ttk.Frame(f)
        sel_frame.pack(fill=tk.X, pady=5)
        ttk.Label(sel_frame, text="State Name (e.g. texas):").pack(side=tk.LEFT)
        self.sm_state_name = tk.StringVar()
        e_st = ttk.Entry(sel_frame, textvariable=self.sm_state_name, width=20)
        e_st.pack(side=tk.LEFT, padx=5)
        e_st.bind("<Return>", lambda e: self.load_state_manager_data())
        ttk.Button(sel_frame, text="Load State Data", command=self.load_state_manager_data).pack(side=tk.LEFT, padx=5)

        # 2. Homelands & Buildings
        hb_container = ttk.Frame(f)
        hb_container.pack(fill=tk.BOTH, expand=True, pady=5)

        # --- Homelands (Left) ---
        h_frame = ttk.LabelFrame(hb_container, text="Homelands", padding=10)
        h_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))

        self.lb_homelands = tk.Listbox(h_frame, height=6, bg="#424242", fg="#ECEFF1")
        self.lb_homelands.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0,5))

        h_ctrl = ttk.Frame(h_frame)
        h_ctrl.pack(side=tk.LEFT, fill=tk.Y)

        self.sm_homeland_add = tk.StringVar()
        self.cb_homeland_add = ttk.Combobox(h_ctrl, textvariable=self.sm_homeland_add, width=15)
        # Will populate on scan
        self.cb_homeland_add.pack(pady=2)

        ttk.Button(h_ctrl, text="Add", command=self.add_state_homeland).pack(fill=tk.X, pady=2)
        ttk.Button(h_ctrl, text="Remove", command=self.remove_state_homeland).pack(fill=tk.X, pady=2)
        ttk.Button(h_ctrl, text="Save", command=self.save_state_homelands_ui).pack(fill=tk.X, pady=(10, 2))

        # --- Buildings (Right) ---
        b_frame = ttk.LabelFrame(hb_container, text="Buildings", padding=10)
        b_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))

        self.lb_buildings = tk.Listbox(b_frame, height=6, bg="#424242", fg="#ECEFF1", exportselection=False)
        self.lb_buildings.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0,5))
        self.lb_buildings.bind('<<ListboxSelect>>', self.on_building_select)

        b_ctrl = ttk.Frame(b_frame)
        b_ctrl.pack(side=tk.LEFT, fill=tk.Y)

        self.sm_building_add = tk.StringVar()
        self.cb_building_add = ttk.Combobox(b_ctrl, textvariable=self.sm_building_add, width=15, state="readonly")
        self.cb_building_add.pack(pady=2)

        self.sm_building_level = tk.StringVar(value="1")
        ttk.Entry(b_ctrl, textvariable=self.sm_building_level, width=5).pack(pady=2)

        ttk.Button(b_ctrl, text="Add", command=self.add_state_building_ui).pack(fill=tk.X, pady=2)
        ttk.Button(b_ctrl, text="Remove", command=self.remove_state_building_ui).pack(fill=tk.X, pady=2)
        ttk.Button(b_ctrl, text="Update Lvl", command=self.update_state_building_level_ui).pack(fill=tk.X, pady=2)

        # 3. Population
        p_frame = ttk.LabelFrame(f, text="Population", padding=10)
        p_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # Total
        tot_frame = ttk.Frame(p_frame)
        tot_frame.pack(fill=tk.X, pady=5)
        ttk.Label(tot_frame, text="Total State Population:").pack(side=tk.LEFT)
        self.sm_total_pop = tk.StringVar()
        ttk.Entry(tot_frame, textvariable=self.sm_total_pop, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(tot_frame, text="Update Total (Distribute)", command=self.update_state_total_pop).pack(side=tk.LEFT, padx=5)

        # Individual Edit
        ind_frame = ttk.LabelFrame(p_frame, text="Edit Individual Pop Block", padding=5)
        ind_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        ttk.Label(ind_frame, text="Select Pop Block:").grid(row=0, column=0, sticky=tk.W)
        self.sm_pop_select = tk.StringVar()
        self.cb_pop_select = ttk.Combobox(ind_frame, textvariable=self.sm_pop_select, state="readonly", width=60)
        self.cb_pop_select.grid(row=0, column=1, columnspan=3, sticky=tk.W, padx=5, pady=2)
        self.cb_pop_select.bind("<<ComboboxSelected>>", self.on_state_pop_select)

        ttk.Label(ind_frame, text="Culture:").grid(row=1, column=0, sticky=tk.W)
        self.sm_pop_cul = tk.StringVar()
        self.cb_pop_cul = ttk.Combobox(ind_frame, textvariable=self.sm_pop_cul, width=20)
        self.cb_pop_cul.grid(row=1, column=1, sticky=tk.W, padx=5)

        ttk.Label(ind_frame, text="Religion:").grid(row=1, column=2, sticky=tk.W)
        self.sm_pop_rel = tk.StringVar()
        self.cb_pop_rel = ttk.Combobox(ind_frame, textvariable=self.sm_pop_rel, width=20)
        self.cb_pop_rel.grid(row=1, column=3, sticky=tk.W, padx=5)

        ttk.Label(ind_frame, text="Size:").grid(row=2, column=0, sticky=tk.W)
        self.sm_pop_size = tk.StringVar()
        ttk.Entry(ind_frame, textvariable=self.sm_pop_size, width=15).grid(row=2, column=1, sticky=tk.W, padx=5, pady=2)

        ttk.Button(ind_frame, text="Update This Pop", command=self.save_single_pop_ui).grid(row=2, column=3, sticky=tk.E, pady=2)

        # Init options
        c_opts, _, _, _, _, _ = self.logic.scan_culture_definitions()
        all_culs = sorted(list(c_opts.keys()))
        self.cb_homeland_add['values'] = all_culs
        self.cb_pop_cul['values'] = all_culs

        _, r_opts = self.logic.scan_all_religions_and_heritages()
        # Need religions not heritages
        r_all, _ = self.logic.scan_all_religions_and_heritages()
        # scan_definitions_for_options also gives used religions
        _, def_rels, _, _ = self.logic.scan_definitions_for_options()
        self.cb_pop_rel['values'] = sorted(list(set(r_all + def_rels)))

        self.current_state_homelands = []
        self.current_state_buildings = []
        self.current_state_pops = []

        # Populate building types
        self.cb_building_add['values'] = self.logic.scan_history_building_types()

        self.run_btn.config(text="Reload Data", command=self.load_state_manager_data)

    def load_state_manager_data(self):
        state = self.sm_state_name.get().strip()
        if not state: return

        # Homelands
        _, homelands = self.logic.get_state_homelands(state)
        self.current_state_homelands = homelands
        self.refresh_homelands_list()

        # Buildings
        buildings = self.logic.scan_state_buildings(state)
        self.current_state_buildings = buildings
        self.refresh_buildings_list()

        # Pops
        pops = self.logic.get_state_pops(state)
        self.current_state_pops = pops

        total = sum(p['size'] for p in pops)
        self.sm_total_pop.set(str(total))

        # Populate selector
        pop_list = []
        for i, p in enumerate(pops):
            # "size, religion, culture, region_state:TAG"
            s = f"{p['size']}, {p['religion']}, {p['culture']}, region_state:{p['region_tag']}"
            pop_list.append(s)
        self.cb_pop_select['values'] = pop_list
        if pop_list:
            self.cb_pop_select.current(0)
            self.on_state_pop_select()
        else:
            self.sm_pop_cul.set("")
            self.sm_pop_rel.set("")
            self.sm_pop_size.set("")

        self.log_message(f"Loaded data for {state}", 'success')

    def refresh_homelands_list(self):
        self.lb_homelands.delete(0, tk.END)
        for h in self.current_state_homelands:
            # Display without prefix for readability, but keep internal list intact
            display_val = h.replace("cu:", "").replace("c:", "")
            self.lb_homelands.insert(tk.END, display_val)

    def add_state_homeland(self):
        val = self.sm_homeland_add.get().strip()
        if val:
            # Check if it needs prefix (it's a culture)
            # We assume the dropdown values are cultures
            prefixed_val = f"cu:{val}" if not val.startswith("cu:") and not val.startswith("c:") else val

            if prefixed_val not in self.current_state_homelands:
                self.current_state_homelands.append(prefixed_val)
                self.refresh_homelands_list()

    def remove_state_homeland(self):
        sel = self.lb_homelands.curselection()
        if sel:
            display_val = self.lb_homelands.get(sel[0])
            # We need to find the matching entry in the internal list
            # Try reconstructing likely prefixes or search
            to_remove = None
            if display_val in self.current_state_homelands:
                to_remove = display_val
            elif f"cu:{display_val}" in self.current_state_homelands:
                to_remove = f"cu:{display_val}"
            elif f"c:{display_val}" in self.current_state_homelands:
                to_remove = f"c:{display_val}"

            if to_remove:
                self.current_state_homelands.remove(to_remove)
                self.refresh_homelands_list()

    def save_state_homelands_ui(self):
        state = self.sm_state_name.get().strip()
        if not state: return
        self.logic.save_state_homelands(state, self.current_state_homelands)
        messagebox.showinfo("Success", "Homelands saved.")

    def refresh_buildings_list(self):
        self.lb_buildings.delete(0, tk.END)
        for b in self.current_state_buildings:
            display_val = f"{b['type']} - Lvl {b['level']} ({b['owner']})"
            self.lb_buildings.insert(tk.END, display_val)

    def on_building_select(self, event=None):
        sel = self.lb_buildings.curselection()
        if sel:
            idx = sel[0]
            if idx < len(self.current_state_buildings):
                b = self.current_state_buildings[idx]
                self.sm_building_level.set(str(b['level']))

    def add_state_building_ui(self):
        state = self.sm_state_name.get().strip()
        if not state: return messagebox.showerror("Error", "Load a state first.")

        b_type = self.sm_building_add.get().strip()
        if not b_type: return

        try:
            lvl = int(self.sm_building_level.get())
        except: return messagebox.showerror("Error", "Level must be integer.")

        # Need owner. Default to first owner found in state?
        # Or maybe the currently selected building's owner?
        # Or simple input dialog?
        # User prompt didn't specify how to select owner for NEW building.
        # "drop down menu showing all building types... and set its level."
        # Usually buildings are added to a specific tag's region_state.
        # Let's prompt for tag, defaulting to the first tag seen in current buildings or pops.

        default_tag = ""
        if self.current_state_buildings:
            default_tag = self.current_state_buildings[0]['owner']
        elif self.current_state_pops:
            default_tag = self.current_state_pops[0]['region_tag']

        owner = simpledialog.askstring("Input", "Owner Tag (e.g. FRA):", initialvalue=default_tag)
        if not owner: return

        clean_owner = self.logic.format_tag_clean(owner)
        self.logic.add_state_building(state, clean_owner, b_type, lvl)
        self.load_state_manager_data() # Refresh

    def remove_state_building_ui(self):
        sel = self.lb_buildings.curselection()
        if not sel: return

        idx = sel[0]
        if idx < len(self.current_state_buildings):
            b = self.current_state_buildings[idx]
            if messagebox.askyesno("Confirm", f"Remove {b['type']} owned by {b['owner']}?"):
                self.logic.save_state_building(b, delete=True)
                self.load_state_manager_data()

    def update_state_building_level_ui(self):
        sel = self.lb_buildings.curselection()
        if not sel: return

        idx = sel[0]
        if idx < len(self.current_state_buildings):
            b = self.current_state_buildings[idx]
            try:
                new_lvl = int(self.sm_building_level.get())
            except: return messagebox.showerror("Error", "Level must be integer.")

            self.logic.save_state_building(b, new_level=new_lvl)
            self.load_state_manager_data()

    def on_state_pop_select(self, event=None):
        idx = self.cb_pop_select.current()
        if idx >= 0 and idx < len(self.current_state_pops):
            p = self.current_state_pops[idx]
            self.sm_pop_cul.set(p['culture'])
            self.sm_pop_rel.set(p['religion'])
            self.sm_pop_size.set(p['size'])

    def update_state_total_pop(self):
        state = self.sm_state_name.get().strip()
        if not state or not self.current_state_pops: return

        try:
            new_total = int(self.sm_total_pop.get())
        except: return messagebox.showerror("Error", "Invalid number")

        self.logic.save_state_pops_total(state, new_total, self.current_state_pops)
        messagebox.showinfo("Success", "Total population updated.")
        self.load_state_manager_data() # Refresh to verify

    def save_single_pop_ui(self):
        idx = self.cb_pop_select.current()
        if idx < 0 or idx >= len(self.current_state_pops): return

        p = self.current_state_pops[idx]

        new_c = self.sm_pop_cul.get().strip()
        new_r = self.sm_pop_rel.get().strip()
        try:
            new_s = int(self.sm_pop_size.get())
        except: return messagebox.showerror("Error", "Invalid size")

        if not new_c or not new_r: return

        self.logic.save_single_pop(p, new_c, new_r, new_s)
        messagebox.showinfo("Success", "Pop block updated.")
        self.load_state_manager_data() # Refresh

if __name__ == "__main__":
    app = App()
    app.mainloop()
