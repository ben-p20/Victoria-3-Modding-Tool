import os
import re
import traceback
import threading
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox, colorchooser
import sys
import queue
import json
import random

# =============================================================================
#  CORE LOGIC
# =============================================================================

class Vic3Logic:
    def __init__(self, log_callback):
        self.log = log_callback
        self.mod_path = ""
        self.stop_event = threading.Event()

    def set_mod_path(self, path):
        self.mod_path = path

    def format_tag_clean(self, user_input):
        return user_input.upper().strip()

    def format_state_clean(self, user_input):
        clean = user_input.upper().strip()
        if not clean: return ""
        if not clean.startswith("STATE_"):
            clean = f"STATE_{clean}"
        return clean

    # --- TAG VALIDATION & CREATION ---
    def tag_exists(self, tag):
        """Checks if a country tag already exists in common/country_definitions."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return False
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()
                
                if re.search(r"^\s*" + re.escape(tag) + r"\s*=", content, re.MULTILINE):
                    return True
        return False

    def scan_definitions_for_options(self):
        """Scans common/country_definitions for unique cultures, religions, tiers, and country types."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")

        cultures = set()
        religions = set()
        tiers = set()
        types = set()

        if not os.path.exists(def_path):
            return [], [], [], []

        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                # Cultures
                cul_matches = re.finditer(r"cultures\s*=\s*\{([^}]+)\}", content)
                for m in cul_matches:
                    for c in m.group(1).split():
                        cultures.add(c.strip())

                # Religions
                rel_matches = re.finditer(r"religion\s*=\s*([A-Za-z0-9_]+)", content)
                for m in rel_matches:
                    r_val = m.group(1).strip()
                    if r_val.lower() != "technically":
                        religions.add(r_val)

                # Tiers
                tier_matches = re.finditer(r"tier\s*=\s*([A-Za-z0-9_]+)", content)
                for m in tier_matches:
                    tiers.add(m.group(1).strip())

                # Country Types
                type_matches = re.finditer(r"country_type\s*=\s*([A-Za-z0-9_]+)", content)
                for m in type_matches:
                    types.add(m.group(1).strip())

        return sorted(list(cultures)), sorted(list(religions)), sorted(list(tiers)), sorted(list(types))

    def get_country_data(self, tag):
        """Attempts to find culture, religion, and capital of a tag."""
        data = { "cultures": None, "religion": None, "capital": None }
        
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return data

        clean_tag = tag.replace("c:", "").strip()
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                match = re.search(r"(^|\s)" + re.escape(clean_tag) + r"\s*=\s*\{", content, re.MULTILINE | re.IGNORECASE)
                if match:
                    start_brace = match.end() - 1
                    _, end_brace = self.find_block_content(content, start_brace)
                    
                    if end_brace:
                        block_content = content[start_brace:end_brace]
                        
                        cul_match = re.search(r"cultures\s*=\s*\{([^}]+)\}", block_content)
                        if cul_match: data["cultures"] = cul_match.group(1).strip()
                        
                        rel_match = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if rel_match: data["religion"] = rel_match.group(1).strip()

                        # Matches capital = ... or capital_state = ...
                        cap_match = re.search(r"(capital|capital_state)\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if cap_match: data["capital"] = cap_match.group(2).strip()
                        return data
        return data

    def get_tech_tier_from_history(self, tag):
        """Scans history/countries for tech tier."""
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        if not os.path.exists(hist_dir): return None

        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Check for country block c:TAG
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                     match = re.search(r"effect_starting_technology_tier_\d+_tech\s*=\s*yes", content)
                     if match:
                         return match.group(0)
        return None

    def get_pop_history_data(self, tag):
        """Scans history/population for wealth and literacy effects."""
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        if not os.path.exists(pop_dir): return None

        clean_tag = tag.replace("c:", "").strip()
        effects = []

        for root, _, files in os.walk(pop_dir):
            for file in files:
                if not file.endswith(".txt"): continue

                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                    c_start, c_end = self.get_block_range_safe(content, f"c:{clean_tag}")
                    if c_start is not None:
                        block = content[c_start:c_end]
                        wealth = re.search(r"effect_starting_pop_wealth_[a-z_]+\s*=\s*yes", block)
                        if wealth: effects.append(wealth.group(0))

                        literacy = re.search(r"effect_starting_pop_literacy_[a-z_]+\s*=\s*yes", block)
                        if literacy: effects.append(literacy.group(0))

                        if effects:
                            return "\n\t\t".join(effects)
        return None

    def get_nearest_vic3_color(self, rgb):
        colors = {
            "white": (255, 255, 255), "black": (10, 10, 10), "red": (180, 0, 0),
            "green": (0, 180, 0), "blue": (0, 0, 180), "yellow": (255, 255, 0),
            "gold": (212, 175, 55), "orange": (255, 140, 0), "pink": (255, 105, 180),
            "purple": (128, 0, 128), "brown": (139, 69, 19), "grey": (128, 128, 128),
            "dark_red": (100, 0, 0), "dark_blue": (0, 0, 100), "dark_green": (0, 80, 0),
            "light_blue": (135, 206, 235)
        }
        r, g, b = rgb
        min_dist = float('inf')
        closest_name = "white"
        for name, c_rgb in colors.items():
            dist = (r - c_rgb[0])**2 + (g - c_rgb[1])**2 + (b - c_rgb[2])**2
            if dist < min_dist:
                min_dist = dist
                closest_name = name
        return closest_name

    def create_country_files(self, tag, name, adjective, capital, gov_type, color_rgb, cultures_list, religion, tier, country_type, old_tag):
        self.log(f"[GEN] Creating core files for {tag} ({name})...")
        r_i, g_i, b_i = int(color_rgb[0]), int(color_rgb[1]), int(color_rgb[2])
        flag_color_name = self.get_nearest_vic3_color((r_i, g_i, b_i))
        self.log(f"   [COLOR] Mapped selection {color_rgb} to flag color: '{flag_color_name}'")

        cultures_str = " ".join(cultures_list)

        # Definition
        def_dir = os.path.join(self.mod_path, "common/country_definitions")
        os.makedirs(def_dir, exist_ok=True)
        def_file = os.path.join(def_dir, f"99_auto_{tag.lower()}.txt")
        def_content = f"""{tag} = {{
    color = {{ {r_i} {g_i} {b_i} }}
    country_type = {country_type}
    tier = {tier}
    cultures = {{ {cultures_str} }}
    religion = {religion}
    capital = {capital}
}}
"""
        with open(def_file, 'w', encoding='utf-8-sig') as f: f.write(def_content)

        # Localization
        loc_dir = os.path.join(self.mod_path, "localization/english")
        os.makedirs(loc_dir, exist_ok=True)
        loc_file = os.path.join(loc_dir, f"auto_{tag.lower()}_l_english.yml")
        loc_content = f"""l_english:
 {tag}: "{name}"
 {tag}_ADJ: "{adjective}"
 {tag}_DEF: "{name}"
"""
        with open(loc_file, 'w', encoding='utf-8-sig') as f: f.write(loc_content)

        # History
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        os.makedirs(hist_dir, exist_ok=True)
        hist_file = os.path.join(hist_dir, f"{tag} - {name}.txt")
        laws = """
    activate_law = law_monarchy
    activate_law = law_autocracy
    activate_law = law_peasant_levies
    activate_law = law_land_tax
""" if gov_type == "monarchy" else """
    activate_law = law_presidential_republic
    activate_law = law_census_voting
    activate_law = law_national_militia
    activate_law = law_per_capita_tax
"""
        ig_ruler = "ig_landowners" if gov_type == "monarchy" else "ig_intelligentsia"

        tech_tier = self.get_tech_tier_from_history(old_tag)
        if not tech_tier: tech_tier = "effect_starting_technology_tier_1_tech = yes"

        hist_content = f"""c:{tag} = {{
    {tech_tier}
    set_tax_level = medium
    {laws}
    create_character = {{
        first_name = "Alexander" 
        last_name = "Modman"
        birth_date = 1800.1.1
        ruler = yes
        interest_group = {ig_ruler}
    }}
}}
"""
        with open(hist_file, 'w', encoding='utf-8-sig') as f: f.write(hist_content)

        # Population History
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        os.makedirs(pop_dir, exist_ok=True)
        pop_file = os.path.join(pop_dir, f"{tag} - {name}.txt")

        pop_effects = self.get_pop_history_data(old_tag)
        if not pop_effects:
             pop_effects = "effect_starting_pop_wealth_medium = yes\n\t\teffect_starting_pop_literacy_medium = yes"

        pop_content = f"""POPULATION = {{
    c:{tag} = {{
        {pop_effects}
    }}
}}
"""
        with open(pop_file, 'w', encoding='utf-8-sig') as f: f.write(pop_content)

        # Flag
        flag_dir = os.path.join(self.mod_path, "common/coat_of_arms/coat_of_arms")
        os.makedirs(flag_dir, exist_ok=True)
        flag_file = os.path.join(flag_dir, f"99_auto_{tag.lower()}.txt")
        emblem_texture = "ce_crown.dds" if gov_type == "monarchy" else "ce_star.dds"
        flag_content = f"""{tag} = {{
    pattern = "pattern_solid.tga"
    color1 = "{flag_color_name}"
    colored_emblem = {{
        texture = "{emblem_texture}"
        color1 = "gold"
        instance = {{ position = {{ 0.5 0.5 }} scale = {{ 0.5 0.5 }} }}
    }}
}}
"""
        with open(flag_file, 'w', encoding='utf-8-sig') as f: f.write(flag_content)

    def _get_location_data(self, tag, target_state):
        owned_states = self.get_all_owned_states(tag)
        final_state = None
        if target_state and target_state in owned_states:
            final_state = target_state
            self.log(f"   [LOC] Validated location: {final_state}")
        else:
            if target_state: self.log(f"   [WARN] {tag} does not own {target_state}. Falling back to capital.", 'warn')
            data = self.get_country_data(tag)
            if data["capital"]:
                final_state = data["capital"]
                self.log(f"   [LOC] Using Capital: {final_state}")
            else:
                return None, None
        
        hq_region = self.find_strategic_region(f"s:{final_state}")
        if not hq_region:
            hq_region = "sr:region_europe"
            self.log(f"   [WARN] Could not find HQ region. Defaulting to Europe.", 'warn')
        else:
            if not hq_region.startswith("sr:"):
                hq_region = f"sr:{hq_region}"
                
        return final_state, hq_region

    def create_army_file(self, tag, army_name, target_state, inf, art, cav):
        """Creates a new army history file."""
        self.log(f"[GEN] Creating Army '{army_name}' for {tag}...")
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count per the Paradox example
        if inf > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_line_infantry
                    state_region = s:{final_state}
                    count = {inf}
                }}"""
        if art > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_cannon_artillery
                    state_region = s:{final_state}
                    count = {art}
                }}"""
        if cav > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_hussars
                    state_region = s:{final_state}
                    count = {cav}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = army_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_army_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{army_name}"
            type = army
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    def create_navy_file(self, tag, navy_name, target_state, manowar, frigate, ironclad):
        """Creates a new navy history file."""
        self.log(f"[GEN] Creating Navy '{navy_name}' for {tag}...")
        self.log(f"   [WARN] Ensure {target_state if target_state else 'Capital'} is a COASTAL state!", 'warn')
        
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count
        if manowar > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_man_o_war
                    state_region = s:{final_state}
                    count = {manowar}
                }}"""
        if frigate > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_frigate
                    state_region = s:{final_state}
                    count = {frigate}
                }}"""
        if ironclad > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_ironclad
                    state_region = s:{final_state}
                    count = {ironclad}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = navy_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_navy_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{navy_name}"
            type = fleet
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    # --- EXISTING TRANSFER LOGIC ---
    def find_strategic_region(self, state_key):
        path = os.path.join(self.mod_path, "common/strategic_regions")
        if not os.path.exists(path): return None
        clean_key = state_key.replace("s:", "").upper()
        
        for root, _, files in os.walk(path):
            if self.stop_event.is_set(): return None
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f:
                        content = f.read()
                    blocks = content.split("region_")
                    for block in blocks[1:]:
                        if clean_key in block.upper():
                            raw_name = block.split("=")[0].strip()
                            return f"region_{raw_name}"
                except: 
                    continue
        return None

    def find_block_content(self, text, start_index):
        n = len(text)
        i = start_index
        while i < n:
            if text[i] == '{': break
            i += 1
        if i >= n: return None, None
        
        start_brace = i
        i += 1
        depth = 1
        in_string = False
        in_comment = False
        
        while i < n and depth > 0:
            char = text[i]
            if in_comment:
                if char == '\n': in_comment = False
            elif in_string:
                if char == '"' and text[i-1] != '\\': in_string = False
            else:
                if char == '#': in_comment = True
                elif char == '"': in_string = True
                elif char == '{': depth += 1
                elif char == '}': depth -= 1
            i += 1
            
        if depth == 0: return start_brace, i
        return None, None

    def get_block_range_safe(self, content, start_pattern, start_search_idx=0):
        pattern = re.compile(re.escape(start_pattern) + r"\s*(=|[\?]=)\s*\{", re.IGNORECASE)
        match = pattern.search(content, start_search_idx)
        if not match: return None, None
        
        start_brace, end_brace = self.find_block_content(content, match.end() - 1)
        if start_brace is not None:
            return match.start(), end_brace
        return None, None

    def collect_valid_scopes(self):
        valid_scopes = set()
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if not os.path.exists(mil_dir): return valid_scopes
        scope_regex = re.compile(r"save_scope_as\s*=\s*([A-Za-z0-9_]+)", re.IGNORECASE)
        for root, _, files in os.walk(mil_dir):
            if self.stop_event.is_set(): return valid_scopes
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                valid_scopes.update(scope_regex.findall(content))
        return valid_scopes

    def prune_orphaned_commanders(self, valid_scopes):
        char_dir = os.path.join(self.mod_path, "common/history/characters")
        if not os.path.exists(char_dir): return
        link_regex = re.compile(r"(commander_formation\s*=\s*scope:)([A-Za-z0-9_]+)", re.IGNORECASE)
        orphans_removed = 0
        self.log("[FIX] Checking for orphaned generals...")
        for root, _, files in os.walk(char_dir):
            if self.stop_event.is_set(): return
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                new_lines = []
                file_changed = False
                for line in content.splitlines():
                    match = link_regex.search(line)
                    if match:
                        scope_id = match.group(2)
                        if scope_id not in valid_scopes:
                            new_lines.append(f"# {line.strip()} (FIXED: Orphaned link)")
                            orphans_removed += 1
                            file_changed = True
                        else:
                            new_lines.append(line)
                    else:
                        new_lines.append(line)
                if file_changed:
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write("\n".join(new_lines))
        if orphans_removed > 0: self.log(f"[SUCCESS] Removed {orphans_removed} orphaned commander links.", 'success')

    def get_all_owned_states(self, tag):
        states_found = []
        states_dir = os.path.join(self.mod_path, "common/history/states")
        if not os.path.exists(states_dir): return []
        clean_tag = tag.replace("c:", "").strip()
        for root, _, files in os.walk(states_dir):
            if self.stop_event.is_set(): return []
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                state_matches = re.finditer(r"s:(STATE_[A-Za-z0-9_]+)\s*=", content)
                for match in state_matches:
                    state_name = match.group(1)
                    s_start, s_end = self.get_block_range_safe(content, f"s:{state_name}")
                    if s_start is not None:
                        block_content = content[s_start:s_end]
                        owner_regex = re.compile(r"country\s*=\s*c:" + re.escape(clean_tag) + r"\b", re.IGNORECASE)
                        if owner_regex.search(block_content):
                            states_found.append(state_name)
        return list(set(states_found))

    def sanitize_block_content(self, content, state_str, old_tag, new_tag, is_building_file):
        content = re.sub(r"region_state:\s*(c:)?" + re.escape(old_tag), f"region_state:{new_tag}", content, flags=re.IGNORECASE)
        content = re.sub(f"c:{re.escape(old_tag)}", f"c:{new_tag}", content, flags=re.IGNORECASE)
        if is_building_file:
            target_region_str = f'region="{state_str}"'
            content = re.sub(r'region="STATE_[A-Za-z0-9_]+"', target_region_str, content, flags=re.IGNORECASE)
        return content

    def transfer_ownership_batch(self, state_list, old_tag, new_tag):
        folders = ["states", "pops", "buildings"]
        results = {s: [] for s in state_list}
        for folder in folders:
            target_dir = os.path.join(self.mod_path, "common/history", folder)
            if not os.path.exists(target_dir): continue
            for root, _, files in os.walk(target_dir):
                if self.stop_event.is_set(): return results
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    try:
                        with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
                    file_changed = False
                    for state in state_list:
                        s_start, s_end = self.get_block_range_safe(content, f"s:{state}")
                        if s_start is not None:
                            block_content = content[s_start:s_end]
                            new_block_content = self.sanitize_block_content(
                                block_content, state, old_tag, new_tag, is_building_file=(folder == "buildings")
                            )
                            if new_block_content != block_content:
                                content = content[:s_start] + new_block_content + content[s_end:]
                                file_changed = True
                                if folder not in results[state]: results[state].append(folder)
                    if file_changed:
                        self.log(f"   [UPDATED] {folder}/{file}")
                        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
        return results

    def clean_unit_string(self, unit_block):
        cleaned = re.sub(r"id\s*=\s*\d+", "", unit_block, flags=re.IGNORECASE)
        cleaned = "\n".join([line for line in cleaned.split('\n') if line.strip()])
        return cleaned

    def generate_immersive_name(self, region_raw, f_type):
        clean_name = region_raw.lower().replace("region_", "").replace("_", " ").title().strip()
        return f"\"{f_type.capitalize()} of {clean_name}\""

    def process_military_extraction_multi_pass(self, filepath, old_tag, new_tag, region, state_list):
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
        clean_states = [re.escape(s.replace("s:","")) for s in state_list]
        state_or_pattern = "|".join(clean_states)
        target_state_regex = re.compile(r"\b(" + state_or_pattern + r")\b", re.IGNORECASE)
        files_modified = False
        stolen_units_army = []
        stolen_units_fleet = []
        current_search_idx = 0
        processed_file_parts = []
        last_idx = 0
        while True:
            c_start, c_end = self.get_block_range_safe(content, f"c:{old_tag}", current_search_idx)
            if c_start is None:
                processed_file_parts.append(content[last_idx:])
                break
            processed_file_parts.append(content[last_idx:c_start])
            body_start_brace, body_end_brace = self.find_block_content(content, c_start)
            if body_start_brace is None:
                processed_file_parts.append(content[c_start:c_end])
                last_idx = c_end
                current_search_idx = c_end
                continue
            header = content[c_start:body_start_brace+1]
            inner_body = content[body_start_brace+1:body_end_brace-1]
            footer = "}"
            new_inner_parts = []
            cursor = 0
            while cursor < len(inner_body):
                match = re.search(r"create_military_formation\s*=\s*\{", inner_body[cursor:])
                if not match:
                    new_inner_parts.append(inner_body[cursor:])
                    break
                abs_match_start = cursor + match.start()
                new_inner_parts.append(inner_body[cursor:abs_match_start])
                brace_idx = abs_match_start + match.group().find('{')
                f_start, f_end = self.find_block_content(inner_body, brace_idx)
                if f_start is None:
                    new_inner_parts.append(inner_body[abs_match_start:])
                    break
                formation_full = inner_body[abs_match_start:f_end]
                is_army = "type" in formation_full and "army" in formation_full.lower()
                is_fleet = "type" in formation_full and "fleet" in formation_full.lower()
                if is_army or is_fleet:
                    f_header = formation_full[:f_start - abs_match_start + 1]
                    f_body = formation_full[f_start - abs_match_start + 1 : -1]
                    f_footer = "}"
                    new_f_body_parts = []
                    f_cursor = 0
                    while f_cursor < len(f_body):
                        u_match = re.search(r"combat_unit\s*=\s*\{", f_body[f_cursor:])
                        if not u_match:
                            new_f_body_parts.append(f_body[f_cursor:])
                            break
                        u_abs_start = f_cursor + u_match.start()
                        new_f_body_parts.append(f_body[f_cursor:u_abs_start])
                        u_brace_idx = u_abs_start + u_match.group().find('{')
                        u_start, u_end = self.find_block_content(f_body, u_brace_idx)
                        if u_start is None:
                            new_f_body_parts.append(f_body[u_abs_start:])
                            break
                        unit_block = f_body[u_abs_start:u_end]
                        if target_state_regex.search(unit_block):
                            self.log(f"      [PURGE] Found ghost unit in {old_tag}. Moving!")
                            clean_block = self.clean_unit_string(unit_block)
                            if is_army: stolen_units_army.append(clean_block)
                            elif is_fleet: stolen_units_fleet.append(clean_block)
                            files_modified = True
                        else:
                            new_f_body_parts.append(unit_block)
                        f_cursor = u_end
                    rebuilt_formation_body = "".join(new_f_body_parts)
                    if "combat_unit" not in rebuilt_formation_body:
                        self.log(f"      [DELETE] Formation became empty. Deleted.")
                        files_modified = True
                    else:
                        new_inner_parts.append(f_header + rebuilt_formation_body + f_footer)
                else:
                    new_inner_parts.append(formation_full)
                cursor = f_end
            processed_file_parts.append(header + "".join(new_inner_parts) + footer)
            last_idx = c_end
            current_search_idx = c_end 
        if not files_modified: return False
        new_file_content = "".join(processed_file_parts)

        def inject_new_formation(file_content, unit_buffer, f_type):
            if not unit_buffer: return file_content
            clean_region_str = region.strip()
            if not clean_region_str.startswith("sr:") and "region_" in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            elif not clean_region_str.startswith("sr:") and "region_" not in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            else:
                hq_region_val = clean_region_str
            immersive_name = self.generate_immersive_name(clean_region_str, f_type)
            block_str = f"""
\tcreate_military_formation = {{
\t\tname = {immersive_name}
\t\ttype = {f_type}
\t\thq_region = {hq_region_val}
\t\t# Transferred Units
\t\t{"\n\t\t".join(unit_buffer)}
\t}}
"""
            last_tag_pos = -1
            curr = 0
            while True:
                ns, ne = self.get_block_range_safe(file_content, f"c:{new_tag}", curr)
                if ns is None: break
                last_tag_pos = ns
                curr = ne
            if last_tag_pos != -1:
                _, end_brace = self.find_block_content(file_content, last_tag_pos)
                insert_pos = end_brace - 1
                return file_content[:insert_pos] + "\n" + block_str + "\n" + file_content[insert_pos:]
            else:
                # NEW LOGIC: Check for MILITARY_FORMATIONS wrapper to insert inside it
                mf_start, mf_end = self.get_block_range_safe(file_content, "MILITARY_FORMATIONS")
                if mf_start is not None:
                    # Insert before the last brace of the wrapper
                    insert_pos = mf_end - 1
                    return file_content[:insert_pos] + f"\n\tc:{new_tag} ?= {{\n{block_str}\n\t}}\n" + file_content[insert_pos:]
                else:
                    return file_content + f"\n\nc:{new_tag} ?= {{\n{block_str}\n}}\n"
        if stolen_units_army:
            self.log(f"      [CREATE] Creating Army for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_army, "army")
        if stolen_units_fleet:
            self.log(f"      [CREATE] Creating Fleet for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_fleet, "fleet")
        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(new_file_content)
        return True

    def clean_military_smart(self, old_tag, new_tag, region, state_list):
        if not region: return
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if os.path.exists(mil_dir):
            for root, _, files in os.walk(mil_dir):
                if self.stop_event.is_set(): return
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    self.process_military_extraction_multi_pass(filepath, old_tag, new_tag, region, state_list)

# =============================================================================
#  GUI IMPLEMENTATION
# =============================================================================

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Victoria 3 Modding Tool")
        self.geometry("850x700")
        self.configure(bg="#212121")
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self._configure_dark_theme()

        self.logic = Vic3Logic(self.log_message)
        self.log_queue = queue.Queue()
        self.is_processing = False
        self.cr_rgb = [random.randint(0,255), random.randint(0,255), random.randint(0,255)]

        self._build_ui()
        self.load_config()
        self.after(100, self.process_log_queue)

    def _configure_dark_theme(self):
        BG_COLOR = "#212121"
        FG_COLOR = "#ECEFF1"
        ACCENT_COLOR = "#00ACC1"
        SECONDARY_BG = "#323232"
        ENTRY_BG = "#424242"
        self.style.configure('.', background=BG_COLOR, foreground=FG_COLOR, font=('Segoe UI', 10))
        self.style.configure('TLabel', background=BG_COLOR, foreground=FG_COLOR)
        self.style.configure('TFrame', background=BG_COLOR)
        self.style.configure('TLabelframe', background=BG_COLOR, foreground=FG_COLOR, bordercolor=SECONDARY_BG)
        self.style.configure('TLabelframe.Label', background=BG_COLOR, foreground=ACCENT_COLOR, font=('Segoe UI', 10, 'bold'))
        self.style.configure('TButton', background=SECONDARY_BG, foreground=FG_COLOR, borderwidth=1, focuscolor=SECONDARY_BG)
        self.style.map('TButton', background=[('active', ACCENT_COLOR), ('disabled', '#2a2a2a')], foreground=[('disabled', '#666666')])
        self.style.configure('TEntry', fieldbackground=ENTRY_BG, foreground=FG_COLOR, bordercolor=SECONDARY_BG, lightcolor=SECONDARY_BG, darkcolor=SECONDARY_BG)
        self.style.configure('TCheckbutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TCheckbutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])
        self.style.configure('TRadiobutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TRadiobutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])

        # Combobox colors - Force black text for readability
        self.option_add('*TCombobox*Listbox.foreground', 'black')
        self.option_add('*TCombobox*Listbox.background', 'white')
        self.style.configure('TCombobox', foreground='black', fieldbackground='white', background='white')

    def load_config(self):
        try:
            if os.path.exists("config.json"):
                with open("config.json", "r") as f:
                    data = json.load(f)
                    path = data.get("mod_path", "")
                    if os.path.exists(path):
                        self.path_var.set(path)
                        self.logic.set_mod_path(path)
                        self.log_message(f"Loaded Mod Path: {path}")
        except: pass

    def save_config(self):
        try:
            with open("config.json", "w") as f:
                json.dump({"mod_path": self.path_var.get()}, f)
        except: pass

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Mod Path
        path_frame = ttk.LabelFrame(main_frame, text="Global Configuration", padding=15)
        path_frame.pack(fill=tk.X, pady=(0, 10))
        self.path_var = tk.StringVar()
        ttk.Label(path_frame, text="Mod Directory:").pack(side=tk.LEFT, padx=(0, 5))
        ttk.Entry(path_frame, textvariable=self.path_var, width=60).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(path_frame, text="Browse...", command=self.browse_folder).pack(side=tk.LEFT, padx=5)

        # 2. Navigation
        nav_frame = ttk.Frame(main_frame)
        nav_frame.pack(fill=tk.X, pady=(0, 10))
        ttk.Button(nav_frame, text="Transfer States", command=self.show_transfer_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Country", command=self.show_create_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Army", command=self.show_army_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Navy", command=self.show_navy_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        # 3. Dynamic Content
        self.content_frame = ttk.Frame(main_frame)
        self.content_frame.pack(fill=tk.BOTH, expand=False, pady=5)

        # 4. Action & Log
        self.action_frame = ttk.Frame(main_frame, padding=(0, 10))
        self.action_frame.pack(fill=tk.X)
        self.run_btn = ttk.Button(self.action_frame, text="Execute", command=lambda: None)
        self.run_btn.pack(side=tk.RIGHT, padx=5)
        
        log_frame = ttk.LabelFrame(main_frame, text="Execution Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.log_area = scrolledtext.ScrolledText(log_frame, state='disabled', height=10, bg="#1e1e1e", fg="#d4d4d4", insertbackground="white", relief="flat")
        self.log_area.pack(fill=tk.BOTH, expand=True)
        self.log_area.tag_config('info', foreground='#d4d4d4')
        self.log_area.tag_config('warn', foreground='#FFA726')
        self.log_area.tag_config('error', foreground='#EF5350')
        self.log_area.tag_config('success', foreground='#66BB6A')

        self.show_transfer_ui()

    def clear_content(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()

    # --- MODE 1: TRANSFER STATES ---
    def show_transfer_ui(self):
        self.clear_content()
        self.mode = "TRANSFER"
        f = ttk.LabelFrame(self.content_frame, text="Transfer States Mode", padding=15)
        f.pack(fill=tk.X)
        ttk.Label(f, text="Old Owner Tag (e.g. fra):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.tr_old_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_old_tag, width=15).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="New Owner Tag (e.g. gbr):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.tr_new_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_new_tag, width=15).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="States (Space separated):").grid(row=2, column=0, sticky=tk.NW, pady=8)
        self.tr_states = tk.Text(f, height=4, width=50, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat", padx=5, pady=5)
        self.tr_states.grid(row=2, column=1, columnspan=2, sticky=tk.W, pady=8, padx=5)
        self.tr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation (Auto-detect all states)", variable=self.tr_annex).grid(row=4, column=1, sticky=tk.W, pady=5)
        self.run_btn.config(text="Execute Transfer", command=self.start_transfer)

    # --- MODE 2: CREATE COUNTRY ---
    def show_create_ui(self):
        self.clear_content()
        self.mode = "CREATE"

        all_cultures, all_religions, all_tiers, all_types = self.logic.scan_definitions_for_options()

        if not all_tiers: all_tiers = ["empire", "kingdom", "grand_principality", "principality", "city_state"]
        if not all_types: all_types = ["recognized", "unrecognized", "colonial"]

        f = ttk.LabelFrame(self.content_frame, text="Create Country Mode", padding=15)
        f.pack(fill=tk.X)

        # Row 0
        ttk.Label(f, text="New Country Tag (3 chars):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.cr_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Country Name:").grid(row=0, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_name = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_name, width=25).grid(row=0, column=3, sticky=tk.W, pady=5)

        # Row 1
        ttk.Label(f, text="Adjective:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.cr_adj = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_adj, width=25).grid(row=1, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Taken From (Old Tag):").grid(row=1, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_old_owner = tk.StringVar()
        e_old = ttk.Entry(f, textvariable=self.cr_old_owner, width=10)
        e_old.grid(row=1, column=3, sticky=tk.W, pady=5)
        e_old.bind("<FocusOut>", self.on_old_owner_change)
        
        # Row 2
        ttk.Label(f, text="Capital State (e.g. aquitaine):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.cr_capital = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_capital, width=25).grid(row=2, column=1, sticky=tk.W, pady=5)
        
        self.cr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation", variable=self.cr_annex, command=self.toggle_annex_ui).grid(row=2, column=2, columnspan=2, sticky=tk.W, padx=10)

        # Row 3
        ttk.Label(f, text="Tier:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.cr_tier = tk.StringVar(value="principality")
        ttk.Combobox(f, textvariable=self.cr_tier, values=all_tiers, state="readonly").grid(row=3, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Type:").grid(row=3, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_type = tk.StringVar(value="recognized")
        ttk.Combobox(f, textvariable=self.cr_type, values=all_types, state="readonly").grid(row=3, column=3, sticky=tk.W, pady=5)

        # Row 4
        ttk.Label(f, text="Gov Type:").grid(row=4, column=0, sticky=tk.W, pady=5)
        self.cr_gov = tk.StringVar(value="monarchy")
        f_gov = ttk.Frame(f); f_gov.grid(row=4, column=1, sticky=tk.W)
        ttk.Radiobutton(f_gov, text="Monarchy", variable=self.cr_gov, value="monarchy").pack(side=tk.LEFT)
        ttk.Radiobutton(f_gov, text="Republic", variable=self.cr_gov, value="republic").pack(side=tk.LEFT)

        ttk.Button(f, text="Pick Color", command=self.pick_color).grid(row=4, column=2, sticky=tk.W, padx=10)
        self.color_preview = tk.Label(f, text="     ", bg=self._rgb_to_hex(self.cr_rgb), relief="solid", borderwidth=1)
        self.color_preview.grid(row=4, column=3, sticky=tk.W)

        # Row 5: Cultures
        self.all_cultures_data = all_cultures
        f_cult = ttk.LabelFrame(f, text="Cultures (Defaults to old tag's default culture)", padding=5)
        f_cult.grid(row=5, column=0, columnspan=2, sticky=tk.NSEW, pady=5)

        self.cr_cult_search = tk.StringVar()
        self.cb_cultures = ttk.Combobox(f_cult, textvariable=self.cr_cult_search, values=all_cultures)
        self.cb_cultures.pack(fill=tk.X)
        self.cb_cultures.bind("<<ComboboxSelected>>", self.add_culture_from_combo)
        self.cb_cultures.bind("<KeyRelease>", self.filter_culture_options)

        self.lb_cultures = tk.Listbox(f_cult, height=4, bg="#424242", fg="#ECEFF1", selectmode=tk.SINGLE)
        self.lb_cultures.pack(fill=tk.BOTH, expand=True, pady=2)

        ttk.Button(f_cult, text="Remove Selected", command=self.remove_culture).pack(fill=tk.X)
        self.selected_cultures = []

        # Row 5: Religion
        f_rel = ttk.LabelFrame(f, text="Religion (Defaults to old tag's default religion)", padding=5)
        f_rel.grid(row=5, column=2, columnspan=2, sticky=tk.NSEW, pady=5, padx=5)

        canvas = tk.Canvas(f_rel, bg="#212121", height=100)
        scrollbar = ttk.Scrollbar(f_rel, orient="vertical", command=canvas.yview)
        self.scrollable_rel_frame = ttk.Frame(canvas)

        self.scrollable_rel_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=self.scrollable_rel_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.cr_religion = tk.StringVar()
        for r in all_religions:
            ttk.Radiobutton(self.scrollable_rel_frame, text=r, variable=self.cr_religion, value=r).pack(anchor=tk.W)

        # Row 6
        self.lbl_others = ttk.Label(f, text="Other States (Space sep.):\n(Must be states owned by the old tag)")
        self.lbl_others.grid(row=6, column=0, sticky=tk.NW, pady=5)
        self.cr_others = tk.Text(f, height=3, width=40, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat")
        self.cr_others.grid(row=6, column=1, columnspan=3, sticky=tk.W, pady=5)

        self.run_btn.config(text="Create & Transfer", command=self.start_create)

    def toggle_annex_ui(self):
        if self.cr_annex.get():
            self.lbl_others.grid_remove()
            self.cr_others.grid_remove()
        else:
            self.lbl_others.grid()
            self.cr_others.grid()

    def on_old_owner_change(self, event):
        # User requested to NOT populate the UI boxes automatically to keep them blank.
        # The background logic in start_create will handle defaults if these remain empty.
        pass
    
    def filter_culture_options(self, event):
        typed = self.cr_cult_search.get().strip().lower()
        if not typed:
            self.cb_cultures['values'] = self.all_cultures_data
        else:
            filtered = [c for c in self.all_cultures_data if c.lower().startswith(typed)]
            self.cb_cultures['values'] = filtered

            # Optional: Open the dropdown if there are matches (can be intrusive, but user requested 'visible')
            # if filtered:
            #     self.cb_cultures.event_generate('<Down>')

    def add_culture_from_combo(self, event):
        val = self.cr_cult_search.get()
        self.add_culture(val)
        self.cr_cult_search.set("")
        self.cb_cultures['values'] = self.all_cultures_data

    def add_culture(self, culture):
        if culture and culture not in self.selected_cultures:
            self.selected_cultures.append(culture)
            self.lb_cultures.insert(tk.END, culture)

    def remove_culture(self):
        sel = self.lb_cultures.curselection()
        if sel:
            idx = sel[0]
            val = self.lb_cultures.get(idx)
            self.selected_cultures.remove(val)
            self.lb_cultures.delete(idx)

    # --- MODE 3: CREATE ARMY ---
    def show_army_ui(self):
        self.clear_content()
        self.mode = "ARMY"
        f = ttk.LabelFrame(self.content_frame, text="Create Army Template", padding=15)
        f.pack(fill=tk.X)
        ttk.Label(f, text="Country Tag:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.arm_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.arm_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="Army Name:").grid(row=0, column=2, sticky=tk.W, pady=5)
        self.arm_name = tk.StringVar(value="First Army")
        ttk.Entry(f, textvariable=self.arm_name, width=20).grid(row=0, column=3, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="Target State (Opt):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.arm_state = tk.StringVar()
        ttk.Entry(f, textvariable=self.arm_state, width=20).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="(Defaults to Capital if empty/invalid)").grid(row=1, column=2, columnspan=2, sticky=tk.W)
        u_frame = ttk.LabelFrame(f, text="Composition", padding=10)
        u_frame.grid(row=2, column=0, columnspan=4, sticky=tk.W+tk.E, pady=10)
        ttk.Label(u_frame, text="Infantry:").grid(row=0, column=0, padx=5)
        self.arm_inf = tk.IntVar(value=10)
        ttk.Entry(u_frame, textvariable=self.arm_inf, width=5).grid(row=0, column=1, padx=5)
        ttk.Label(u_frame, text="Artillery:").grid(row=0, column=2, padx=5)
        self.arm_art = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.arm_art, width=5).grid(row=0, column=3, padx=5)
        ttk.Label(u_frame, text="Cavalry:").grid(row=0, column=4, padx=5)
        self.arm_cav = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.arm_cav, width=5).grid(row=0, column=5, padx=5)
        self.run_btn.config(text="Create Army", command=self.start_create_army)

    # --- MODE 4: CREATE NAVY ---
    def show_navy_ui(self):
        self.clear_content()
        self.mode = "NAVY"
        f = ttk.LabelFrame(self.content_frame, text="Create Navy Template", padding=15)
        f.pack(fill=tk.X)

        ttk.Label(f, text="Country Tag:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.nav_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.nav_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Navy Name:").grid(row=0, column=2, sticky=tk.W, pady=5)
        self.nav_name = tk.StringVar(value="First Fleet")
        ttk.Entry(f, textvariable=self.nav_name, width=20).grid(row=0, column=3, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Target State (Must be Coastal!):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.nav_state = tk.StringVar()
        ttk.Entry(f, textvariable=self.nav_state, width=20).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        
        warn_lbl = ttk.Label(f, text="(Warning: Game will crash if state is landlocked)", foreground="#EF5350")
        warn_lbl.grid(row=1, column=2, columnspan=2, sticky=tk.W)

        u_frame = ttk.LabelFrame(f, text="Composition", padding=10)
        u_frame.grid(row=2, column=0, columnspan=4, sticky=tk.W+tk.E, pady=10)

        ttk.Label(u_frame, text="Man-of-War:").grid(row=0, column=0, padx=5)
        self.nav_man = tk.IntVar(value=5)
        ttk.Entry(u_frame, textvariable=self.nav_man, width=5).grid(row=0, column=1, padx=5)

        ttk.Label(u_frame, text="Frigate:").grid(row=0, column=2, padx=5)
        self.nav_frig = tk.IntVar(value=10)
        ttk.Entry(u_frame, textvariable=self.nav_frig, width=5).grid(row=0, column=3, padx=5)

        ttk.Label(u_frame, text="Ironclad:").grid(row=0, column=4, padx=5)
        self.nav_iron = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.nav_iron, width=5).grid(row=0, column=5, padx=5)

        self.run_btn.config(text="Create Navy", command=self.start_create_navy)

    def _rgb_to_hex(self, rgb):
        return f'#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}'

    def pick_color(self):
        init_color = self._rgb_to_hex(self.cr_rgb)
        color = colorchooser.askcolor(color=init_color, title="Choose Country Color")
        if color[0]:
            self.cr_rgb = [int(x) for x in color[0]]
            self.color_preview.config(bg=color[1])

    # --- SHARED FUNCTIONS ---
    def browse_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.path_var.set(folder)
            self.logic.set_mod_path(folder)
            self.save_config()
            self.log_message(f"Selected Mod Path: {folder}")

    def log_message(self, message, level='info'):
        self.log_queue.put((message, level))

    def process_log_queue(self):
        while not self.log_queue.empty():
            msg, level = self.log_queue.get()
            self.log_area.config(state='normal')
            self.log_area.insert(tk.END, msg.strip() + "\n", level)
            self.log_area.see(tk.END)
            self.log_area.config(state='disabled')
        self.after(100, self.process_log_queue)

    def start_transfer(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        old = self.logic.format_tag_clean(self.tr_old_tag.get())
        new = self.logic.format_tag_clean(self.tr_new_tag.get())
        annex = self.tr_annex.get()
        raw_st = self.tr_states.get("1.0", tk.END)
        if not old or not new: return messagebox.showerror("Error", "Tags required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_transfer_logic, args=(old, new, annex, raw_st), daemon=True).start()

    def start_create(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.cr_tag.get())
        name = self.cr_name.get().strip()
        adj = self.cr_adj.get().strip()
        old_owner = self.logic.format_tag_clean(self.cr_old_owner.get())
        capital = self.logic.format_state_clean(self.cr_capital.get())
        others_raw = self.cr_others.get("1.0", tk.END)
        gov = self.cr_gov.get()
        rgb = self.cr_rgb
        is_annex = self.cr_annex.get()

        tier = self.cr_tier.get()
        country_type = self.cr_type.get()
        cultures = self.selected_cultures
        religion = self.cr_religion.get()

        if not tag or not name or not old_owner: return messagebox.showerror("Error", "Tag, Name, and Old Owner are required.")
        if not is_annex and not capital: return messagebox.showerror("Error", "Capital State ID required unless Full Annexation.")
        if len(tag) != 3: return messagebox.showerror("Error", "Tag must be exactly 3 characters.")

        # If not manually selected, default to old owner's data
        if not cultures:
            data = self.logic.get_country_data(old_owner)
            if data["cultures"]:
                cultures = data["cultures"].split()

        if not religion:
            data = self.logic.get_country_data(old_owner)
            if data["religion"]:
                religion = data["religion"]

        if not cultures: return messagebox.showerror("Error", "At least one culture required.")
        if not religion: return messagebox.showerror("Error", "Religion required.")

        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_create_logic, args=(tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type), daemon=True).start()

    def start_create_army(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.arm_tag.get())
        name = self.arm_name.get().strip() or "Army"
        state = self.logic.format_state_clean(self.arm_state.get())
        try:
            inf = int(self.arm_inf.get())
            art = int(self.arm_art.get())
            cav = int(self.arm_cav.get())
        except: return messagebox.showerror("Error", "Unit counts must be integers.")
        if not tag: return messagebox.showerror("Error", "Tag is required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_army_logic, args=(tag, name, state, inf, art, cav), daemon=True).start()

    def start_create_navy(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.nav_tag.get())
        name = self.nav_name.get().strip() or "Fleet"
        state = self.logic.format_state_clean(self.nav_state.get())
        try:
            man = int(self.nav_man.get())
            frig = int(self.nav_frig.get())
            iron = int(self.nav_iron.get())
        except: return messagebox.showerror("Error", "Unit counts must be integers.")
        if not tag: return messagebox.showerror("Error", "Tag is required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_navy_logic, args=(tag, name, state, man, frig, iron), daemon=True).start()

    # --- LOGIC THREADS ---
    def run_transfer_logic(self, old_tag, new_tag, is_annex, raw_states):
        try:
            self.log_message(f"--- Processing Transfer: {old_tag} -> {new_tag} ---", 'info')
            states_clean = []
            if is_annex:
                self.log_message(f"[INFO] Detecting states owned by {old_tag}...", 'info')
                states_clean = self.logic.get_all_owned_states(old_tag)
                if not states_clean:
                    self.log_message(f"[WARN] No states found for {old_tag}.", 'warn')
                    return
            else:
                states_clean = [self.logic.format_state_clean(s) for s in raw_states.split() if s.strip()]
                if not states_clean: return self.log_message("[ERROR] No states provided.", 'error')
            self.execute_transfer_core(states_clean, old_tag, new_tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_create_logic(self, tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type):
        try:
            self.log_message(f"--- Creating Country: {tag} ({name}) ---", 'info')
            if self.logic.tag_exists(tag):
                self.log_message(f"[ERROR] Tag {tag} already exists in common/country_definitions!", 'error')
                return

            # (Old owner data logic is now partly in UI for prepopulation, but we still need capital logic if annexing)
            data = self.logic.get_country_data(old_owner)
            
            all_states = []
            if is_annex:
                self.log_message(f"[INFO] Full Annexation selected. Detecting all states for {old_owner}...", 'info')
                found_states = self.logic.get_all_owned_states(old_owner)
                if not found_states:
                    self.log_message(f"[WARN] No states found for {old_owner} to annex.", 'warn')
                    return
                all_states = found_states
                
                # If capital input is blank, use old owner's capital
                if not capital:
                    if data["capital"]:
                        capital = data["capital"]
                        self.log_message(f"[INFO] Auto-detected capital: {capital}", 'info')
                    elif all_states:
                        capital = all_states[0] # Fallback to first found state
                        self.log_message(f"[WARN] Capital undefined in old owner. Using first state: {capital}", 'warn')
                    else:
                        self.log_message("[ERROR] Cannot determine capital state.", 'error')
                        return
            else:
                others = [self.logic.format_state_clean(s) for s in others_raw.split() if s.strip()]
                all_states = [capital] + others

            self.logic.create_country_files(tag, name, adj, capital, gov, rgb, cultures, religion, tier, country_type, old_owner)
            
            self.log_message("--- Transferring Land & Units ---", 'info')
            self.execute_transfer_core(all_states, old_owner, tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_army_logic(self, tag, name, state, inf, art, cav):
        try:
            self.log_message(f"--- Creating Army Template for {tag} ---", 'info')
            self.logic.create_army_file(tag, name, state, inf, art, cav)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_navy_logic(self, tag, name, state, man, frig, iron):
        try:
            self.log_message(f"--- Creating Navy Template for {tag} ---", 'info')
            self.logic.create_navy_file(tag, name, state, man, frig, iron)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def execute_transfer_core(self, states_clean, old_tag, new_tag):
        self.log_message("--- Processing Map Data ---")
        self.logic.transfer_ownership_batch(states_clean, old_tag, new_tag)
        regions_to_process = {}
        for state in states_clean:
            reg = self.logic.find_strategic_region(f"s:{state}")
            if reg:
                if reg not in regions_to_process: regions_to_process[reg] = []
                regions_to_process[reg].append(state)
        self.log_message("--- Processing Military Formations ---")
        for reg, states in regions_to_process.items():
            self.log_message(f" -> Scanning region: {reg}")
            self.logic.clean_military_smart(old_tag, new_tag, reg, states)
        self.log_message("--- Validating Character Links ---")
        valid_scopes = self.logic.collect_valid_scopes()
        self.logic.prune_orphaned_commanders(valid_scopes)
        self.log_message("Done.", 'success')

if __name__ == "__main__":
    app = App()
    app.mainloop()
