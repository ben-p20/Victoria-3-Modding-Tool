import os
import re
import traceback
import threading
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox, colorchooser
import sys
import queue
import json
import random

# =============================================================================
#  CORE LOGIC
# =============================================================================

class Vic3Logic:
    def __init__(self, log_callback):
        self.log = log_callback
        self.mod_path = ""
        self.stop_event = threading.Event()

    def set_mod_path(self, path):
        self.mod_path = path

    def format_tag_clean(self, user_input):
        return user_input.upper().strip()

    def format_state_clean(self, user_input):
        clean = user_input.upper().strip()
        if not clean: return ""
        if not clean.startswith("STATE_"):
            clean = f"STATE_{clean}"
        return clean

    # --- TAG VALIDATION & CREATION ---
    def tag_exists(self, tag):
        """Checks if a country tag already exists in common/country_definitions."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return False
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()
                
                if re.search(r"^\s*" + re.escape(tag) + r"\s*=", content, re.MULTILINE):
                    return True
        return False

    def scan_definitions_for_options(self):
        """Scans common/country_definitions for unique cultures, religions, tiers, and country types."""
        def_path = os.path.join(self.mod_path, "common/country_definitions")

        cultures = set()
        religions = set()
        tiers = set()
        types = set()

        if not os.path.exists(def_path):
            return [], [], [], []

        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                # Cultures
                cul_matches = re.finditer(r"cultures\s*=\s*\{([^}]+)\}", content)
                for m in cul_matches:
                    for c in m.group(1).split():
                        cultures.add(c.strip())

                # Religions
                rel_matches = re.finditer(r"religion\s*=\s*([A-Za-z0-9_]+)", content)
                for m in rel_matches:
                    r_val = m.group(1).strip()
                    if r_val.lower() != "technically":
                        religions.add(r_val)

                # Tiers
                tier_matches = re.finditer(r"tier\s*=\s*([A-Za-z0-9_]+)", content)
                for m in tier_matches:
                    tiers.add(m.group(1).strip())

                # Country Types
                type_matches = re.finditer(r"country_type\s*=\s*([A-Za-z0-9_]+)", content)
                for m in type_matches:
                    types.add(m.group(1).strip())

        return sorted(list(cultures)), sorted(list(religions)), sorted(list(tiers)), sorted(list(types))

    def get_country_data(self, tag):
        """Attempts to find culture, religion, and capital of a tag."""
        data = { "cultures": None, "religion": None, "capital": None }
        
        def_path = os.path.join(self.mod_path, "common/country_definitions")
        if not os.path.exists(def_path): return data

        clean_tag = tag.replace("c:", "").strip()
        
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                match = re.search(r"(^|\s)" + re.escape(clean_tag) + r"\s*=\s*\{", content, re.MULTILINE | re.IGNORECASE)
                if match:
                    start_brace = match.end() - 1
                    _, end_brace = self.find_block_content(content, start_brace)
                    
                    if end_brace:
                        block_content = content[start_brace:end_brace]
                        
                        cul_match = re.search(r"cultures\s*=\s*\{([^}]+)\}", block_content)
                        if cul_match: data["cultures"] = cul_match.group(1).strip()
                        
                        rel_match = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if rel_match: data["religion"] = rel_match.group(1).strip()

                        # Matches capital = ... or capital_state = ...
                        cap_match = re.search(r"(capital|capital_state)\s*=\s*([A-Za-z0-9_]+)", block_content)
                        if cap_match: data["capital"] = cap_match.group(2).strip()
                        return data
        return data

    def get_religion_by_culture(self, culture):
        """Scans common/cultures to find the default religion for a given culture."""
        cult_dir = os.path.join(self.mod_path, "common/cultures")
        if not os.path.exists(cult_dir): return None

        # Matches: start of line or whitespace + culture + whitespace + = + whitespace + {
        pat = re.compile(r"(?:^|\s)" + re.escape(culture) + r"\s*=\s*\{", re.MULTILINE)

        for root, _, files in os.walk(cult_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                match = pat.search(content)
                if match:
                    # Found start of culture block. Find the block content.
                    start_brace = match.end() - 1
                    _, end_brace = self.find_block_content(content, start_brace)
                    
                    if end_brace:
                        block = content[start_brace:end_brace]
                        rel_match = re.search(r"religion\s*=\s*([A-Za-z0-9_]+)", block)
                        if rel_match:
                            return rel_match.group(1).strip()
        return None

    def get_tech_tier_from_history(self, tag):
        """Scans history/countries for tech tier."""
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        if not os.path.exists(hist_dir): return None

        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Check for country block c:TAG
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                     match = re.search(r"effect_starting_technology_tier_\d+_tech\s*=\s*yes", content)
                     if match:
                         return match.group(0)
        return None

    def get_pop_history_data(self, tag):
        """Scans history/population for wealth and literacy effects."""
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        if not os.path.exists(pop_dir): return None

        clean_tag = tag.replace("c:", "").strip()
        effects = []

        for root, _, files in os.walk(pop_dir):
            for file in files:
                if not file.endswith(".txt"): continue

                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                current_idx = 0
                while True:
                    c_start, c_end = self.get_block_range_safe(content, f"c:{clean_tag}", current_idx)
                    if c_start is None: break

                    block = content[c_start:c_end]
                    wealth = re.search(r"effect_starting_pop_wealth_[a-z_]+\s*=\s*yes", block)
                    if wealth and wealth.group(0) not in effects: effects.append(wealth.group(0))

                    literacy = re.search(r"effect_starting_pop_literacy_[a-z_]+\s*=\s*yes", block)
                    if literacy and literacy.group(0) not in effects: effects.append(literacy.group(0))

                    current_idx = c_end

        if effects:
            return "\n\t\t".join(effects)
        return None

    def get_extended_history_data(self, tag):
        """Scans history/countries for extended data (tech, laws, politics, institutions)."""
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        if not os.path.exists(hist_dir): return None

        clean_tag = tag.replace("c:", "").strip()
        data = {
            "tech_tier": [],
            "techs_researched": [],
            "politics": [],
            "laws": [],
            "institutions": []
        }

        found_any = False

        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                current_idx = 0
                while True:
                    c_start, c_end = self.get_block_range_safe(content, f"c:{clean_tag}", current_idx)
                    if c_start is None: break
                    found_any = True

                    sb, _ = self.find_block_content(content, c_start)
                    if sb is not None:
                        block_inner = content[sb+1 : c_end-1]

                        data["tech_tier"].extend(re.findall(r"effect_starting_technology_tier_\d+_tech\s*=\s*yes", block_inner))
                        data["politics"].extend(re.findall(r"effect_starting_politics_[a-z_]+\s*=\s*yes", block_inner))
                        data["techs_researched"].extend(re.findall(r"add_technology_researched\s*=\s*[a-zA-Z0-9_]+", block_inner))
                        data["laws"].extend([l.strip() for l in re.findall(r"^\s*(activate_law\s*=\s*.*)$", block_inner, re.MULTILINE)])

                        inst_pattern = re.compile(r"(set_institution_[a-zA-Z0-9_]+)\s*=\s*", re.MULTILINE)
                        cursor = 0
                        while True:
                            match = inst_pattern.search(block_inner, cursor)
                            if not match: break

                            next_char_idx = match.end()
                            while next_char_idx < len(block_inner) and block_inner[next_char_idx].isspace():
                                next_char_idx += 1

                            if next_char_idx < len(block_inner) and block_inner[next_char_idx] == '{':
                                b_start, b_end = self.find_block_content(block_inner, next_char_idx)
                                if b_start is not None:
                                    data["institutions"].append(block_inner[match.start():b_end].strip())
                                    cursor = b_end
                                else:
                                    cursor = match.end()
                            else:
                                line_end = block_inner.find('\n', match.end())
                                if line_end == -1: line_end = len(block_inner)
                                data["institutions"].append(block_inner[match.start():line_end].strip())
                                cursor = line_end
                    current_idx = c_end

        if not found_any: return None
        return data

    def get_nearest_vic3_color(self, rgb):
        colors = {
            "white": (255, 255, 255), "black": (10, 10, 10), "red": (180, 0, 0),
            "green": (0, 180, 0), "blue": (0, 0, 180), "yellow": (255, 255, 0),
            "gold": (212, 175, 55), "orange": (255, 140, 0), "pink": (255, 105, 180),
            "purple": (128, 0, 128), "brown": (139, 69, 19), "grey": (128, 128, 128),
            "dark_red": (100, 0, 0), "dark_blue": (0, 0, 100), "dark_green": (0, 80, 0),
            "light_blue": (135, 206, 235)
        }
        r, g, b = rgb
        min_dist = float('inf')
        closest_name = "white"
        for name, c_rgb in colors.items():
            dist = (r - c_rgb[0])**2 + (g - c_rgb[1])**2 + (b - c_rgb[2])**2
            if dist < min_dist:
                min_dist = dist
                closest_name = name
        return closest_name

    def create_country_files(self, tag, name, adjective, capital, gov_type, color_rgb, cultures_list, religion, tier, country_type, old_tag):
        self.log(f"[GEN] Creating core files for {tag} ({name})...")
        r_i, g_i, b_i = int(color_rgb[0]), int(color_rgb[1]), int(color_rgb[2])
        flag_color_name = self.get_nearest_vic3_color((r_i, g_i, b_i))
        self.log(f"   [COLOR] Mapped selection {color_rgb} to flag color: '{flag_color_name}'")

        cultures_str = " ".join(cultures_list)

        # Definition
        def_dir = os.path.join(self.mod_path, "common/country_definitions")
        os.makedirs(def_dir, exist_ok=True)
        def_file = os.path.join(def_dir, f"99_auto_{tag.lower()}.txt")
        def_content = f"""{tag} = {{
    color = {{ {r_i} {g_i} {b_i} }}
    country_type = {country_type}
    tier = {tier}
    cultures = {{ {cultures_str} }}
    religion = {religion}
    capital = {capital}
}}
"""
        with open(def_file, 'w', encoding='utf-8-sig') as f: f.write(def_content)

        # Localization
        loc_dir = os.path.join(self.mod_path, "localization/english")
        os.makedirs(loc_dir, exist_ok=True)
        loc_file = os.path.join(loc_dir, f"auto_{tag.lower()}_l_english.yml")
        loc_content = f"""l_english:
 {tag}: "{name}"
 {tag}_ADJ: "{adjective}"
 {tag}_DEF: "{name}"
"""
        with open(loc_file, 'w', encoding='utf-8-sig') as f: f.write(loc_content)

        # History
        hist_dir = os.path.join(self.mod_path, "common/history/countries")
        os.makedirs(hist_dir, exist_ok=True)
        hist_file = os.path.join(hist_dir, f"{tag} - {name}.txt")

        # Extended Data Extraction
        ext_data = self.get_extended_history_data(old_tag)

        laws_block = ""
        tech_tier_str = ""
        techs_res_str = ""
        politics_str = ""
        inst_str = ""

        if ext_data:
            if ext_data["laws"]:
                laws_block = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["laws"])))
            if ext_data["tech_tier"]:
                tech_tier_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["tech_tier"])))
            if ext_data["techs_researched"]:
                techs_res_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["techs_researched"])))
            if ext_data["politics"]:
                politics_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["politics"])))
            if ext_data["institutions"]:
                inst_str = "\n\t" + "\n\t".join(list(dict.fromkeys(ext_data["institutions"])))

        if not laws_block:
            laws_block = """
    activate_law = law_type:law_monarchy
    activate_law = law_type:law_autocracy
    activate_law = law_type:law_peasant_levies
    activate_law = law_type:law_land_tax
""" if gov_type == "monarchy" else """
    activate_law = law_type:law_presidential_republic
    activate_law = law_type:law_census_voting
    activate_law = law_type:law_national_militia
    activate_law = law_type:law_per_capita_tax
    activate_law = law_type:law_appointed_bureaucrats
"""

        if not tech_tier_str:
             tech_tier_str = "effect_starting_technology_tier_1_tech = yes"

        ig_ruler = "ig_landowners" if gov_type == "monarchy" else "ig_intelligentsia"

        hist_content = f"""COUNTRIES = {{
    c:{tag} ?= {{
        {tech_tier_str}
        set_tax_level = medium
        {laws_block}
        {politics_str}
        {techs_res_str}
        {inst_str}

        create_character = {{
            first_name = "Alexander"
            last_name = "Modman"
            birth_date = 1800.1.1
            ruler = yes
            interest_group = {ig_ruler}
        }}
    }}
}}
"""
        with open(hist_file, 'w', encoding='utf-8-sig') as f: f.write(hist_content)

        # Population History
        pop_dir = os.path.join(self.mod_path, "common/history/population")
        os.makedirs(pop_dir, exist_ok=True)
        pop_file = os.path.join(pop_dir, f"{tag} - {name}.txt")

        pop_effects = self.get_pop_history_data(old_tag)
        if not pop_effects:
             pop_effects = "effect_starting_pop_wealth_medium = yes\n\t\teffect_starting_pop_literacy_medium = yes"

        pop_content = f"""POPULATION = {{
    c:{tag} = {{
        {pop_effects}
    }}
}}
"""
        with open(pop_file, 'w', encoding='utf-8-sig') as f: f.write(pop_content)

        # Flag
        flag_dir = os.path.join(self.mod_path, "common/coat_of_arms/coat_of_arms")
        os.makedirs(flag_dir, exist_ok=True)
        flag_file = os.path.join(flag_dir, f"99_auto_{tag.lower()}.txt")
        emblem_texture = "ce_crown.dds" if gov_type == "monarchy" else "ce_star.dds"
        flag_content = f"""{tag} = {{
    pattern = "pattern_solid.tga"
    color1 = "{flag_color_name}"
    colored_emblem = {{
        texture = "{emblem_texture}"
        color1 = "gold"
        instance = {{ position = {{ 0.5 0.5 }} scale = {{ 0.5 0.5 }} }}
    }}
}}
"""
        with open(flag_file, 'w', encoding='utf-8-sig') as f: f.write(flag_content)

    def _get_location_data(self, tag, target_state):
        owned_states = self.get_all_owned_states(tag)
        final_state = None
        if target_state and target_state in owned_states:
            final_state = target_state
            self.log(f"   [LOC] Validated location: {final_state}")
        else:
            if target_state: self.log(f"   [WARN] {tag} does not own {target_state}. Falling back to capital.", 'warn')
            data = self.get_country_data(tag)
            if data["capital"]:
                final_state = data["capital"]
                self.log(f"   [LOC] Using Capital: {final_state}")
            else:
                return None, None
        
        hq_region = self.find_strategic_region(f"s:{final_state}")
        if not hq_region:
            hq_region = "sr:region_europe"
            self.log(f"   [WARN] Could not find HQ region. Defaulting to Europe.", 'warn')
        else:
            if not hq_region.startswith("sr:"):
                hq_region = f"sr:{hq_region}"
                
        return final_state, hq_region

    def create_army_file(self, tag, army_name, target_state, inf, art, cav):
        """Creates a new army history file."""
        self.log(f"[GEN] Creating Army '{army_name}' for {tag}...")
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count per the Paradox example
        if inf > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_line_infantry
                    state_region = s:{final_state}
                    count = {inf}
                }}"""
        if art > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_cannon_artillery
                    state_region = s:{final_state}
                    count = {art}
                }}"""
        if cav > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_hussars
                    state_region = s:{final_state}
                    count = {cav}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = army_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_army_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{army_name}"
            type = army
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    def create_navy_file(self, tag, navy_name, target_state, manowar, frigate, ironclad):
        """Creates a new navy history file."""
        self.log(f"[GEN] Creating Navy '{navy_name}' for {tag}...")
        self.log(f"   [WARN] Ensure {target_state if target_state else 'Capital'} is a COASTAL state!", 'warn')
        
        final_state, hq_region = self._get_location_data(tag, target_state)
        if not final_state: return self.log("[ERROR] Aborting: Location unknown.", 'error')

        units_block = ""
        # Using state_region and count
        if manowar > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_man_o_war
                    state_region = s:{final_state}
                    count = {manowar}
                }}"""
        if frigate > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_frigate
                    state_region = s:{final_state}
                    count = {frigate}
                }}"""
        if ironclad > 0:
            units_block += f"""
                combat_unit = {{
                    type = unit_type:combat_unit_type_ironclad
                    state_region = s:{final_state}
                    count = {ironclad}
                }}"""

        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        os.makedirs(mil_dir, exist_ok=True)
        safe_name = navy_name.lower().replace(" ", "_")
        mil_file = os.path.join(mil_dir, f"99_auto_navy_{tag.lower()}_{safe_name}.txt")

        # Wrapper MILITARY_FORMATIONS added with ?=
        content = f"""MILITARY_FORMATIONS = {{
    c:{tag} ?= {{
        create_military_formation = {{
            name = "{navy_name}"
            type = fleet
            hq_region = {hq_region}
            {units_block}
        }}
    }}
}}
"""
        with open(mil_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"   [WRITE] {mil_file}", 'success')

    # --- EXISTING TRANSFER LOGIC ---
    def find_strategic_region(self, state_key):
        path = os.path.join(self.mod_path, "common/strategic_regions")
        if not os.path.exists(path): return None
        clean_key = state_key.replace("s:", "").upper()
        
        for root, _, files in os.walk(path):
            if self.stop_event.is_set(): return None
            for file in files:
                if not file.endswith(".txt"): continue
                try:
                    with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f:
                        content = f.read()
                    blocks = content.split("region_")
                    for block in blocks[1:]:
                        if clean_key in block.upper():
                            raw_name = block.split("=")[0].strip()
                            return f"region_{raw_name}"
                except: 
                    continue
        return None

    def find_block_content(self, text, start_index):
        n = len(text)
        i = start_index
        while i < n:
            if text[i] == '{': break
            i += 1
        if i >= n: return None, None
        
        start_brace = i
        i += 1
        depth = 1
        in_string = False
        in_comment = False
        
        while i < n and depth > 0:
            char = text[i]
            if in_comment:
                if char == '\n': in_comment = False
            elif in_string:
                if char == '"' and text[i-1] != '\\': in_string = False
            else:
                if char == '#': in_comment = True
                elif char == '"': in_string = True
                elif char == '{': depth += 1
                elif char == '}': depth -= 1
            i += 1
            
        if depth == 0: return start_brace, i
        return None, None

    def get_block_range_safe(self, content, start_pattern, start_search_idx=0):
        pattern = re.compile(re.escape(start_pattern) + r"\s*(=|[\?]=)\s*\{", re.IGNORECASE)
        match = pattern.search(content, start_search_idx)
        if not match: return None, None
        
        start_brace, end_brace = self.find_block_content(content, match.end() - 1)
        if start_brace is not None:
            return match.start(), end_brace
        return None, None

    def collect_valid_scopes(self):
        valid_scopes = set()
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if not os.path.exists(mil_dir): return valid_scopes
        scope_regex = re.compile(r"save_scope_as\s*=\s*([A-Za-z0-9_]+)", re.IGNORECASE)
        for root, _, files in os.walk(mil_dir):
            if self.stop_event.is_set(): return valid_scopes
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                valid_scopes.update(scope_regex.findall(content))
        return valid_scopes

    def prune_orphaned_commanders(self, valid_scopes):
        char_dir = os.path.join(self.mod_path, "common/history/characters")
        if not os.path.exists(char_dir): return
        link_regex = re.compile(r"(commander_formation\s*=\s*scope:)([A-Za-z0-9_]+)", re.IGNORECASE)
        orphans_removed = 0
        self.log("[FIX] Checking for orphaned generals...")
        for root, _, files in os.walk(char_dir):
            if self.stop_event.is_set(): return
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                new_lines = []
                file_changed = False
                for line in content.splitlines():
                    match = link_regex.search(line)
                    if match:
                        scope_id = match.group(2)
                        if scope_id not in valid_scopes:
                            new_lines.append(f"# {line.strip()} (FIXED: Orphaned link)")
                            orphans_removed += 1
                            file_changed = True
                        else:
                            new_lines.append(line)
                    else:
                        new_lines.append(line)
                if file_changed:
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write("\n".join(new_lines))
        if orphans_removed > 0: self.log(f"[SUCCESS] Removed {orphans_removed} orphaned commander links.", 'success')

    def get_all_owned_states(self, tag):
        states_found = []
        states_dir = os.path.join(self.mod_path, "common/history/states")
        if not os.path.exists(states_dir): return []
        clean_tag = tag.replace("c:", "").strip()
        for root, _, files in os.walk(states_dir):
            if self.stop_event.is_set(): return []
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                state_matches = re.finditer(r"s:(STATE_[A-Za-z0-9_]+)\s*=", content)
                for match in state_matches:
                    state_name = match.group(1)
                    s_start, s_end = self.get_block_range_safe(content, f"s:{state_name}")
                    if s_start is not None:
                        block_content = content[s_start:s_end]
                        owner_regex = re.compile(r"country\s*=\s*c:" + re.escape(clean_tag) + r"\b", re.IGNORECASE)
                        if owner_regex.search(block_content):
                            states_found.append(state_name)
        return list(set(states_found))

    def sanitize_block_content(self, content, state_str, old_tag, new_tag, is_building_file):
        content = re.sub(r"region_state:\s*(c:)?" + re.escape(old_tag), f"region_state:{new_tag}", content, flags=re.IGNORECASE)
        content = re.sub(f"c:{re.escape(old_tag)}", f"c:{new_tag}", content, flags=re.IGNORECASE)
        if is_building_file:
            target_region_str = f'region="{state_str}"'
            content = re.sub(r'region="STATE_[A-Za-z0-9_]+"', target_region_str, content, flags=re.IGNORECASE)
        return content

    def transfer_ownership_batch(self, state_list, old_tag, new_tag):
        folders = ["states", "pops", "buildings"]
        results = {s: [] for s in state_list}
        for folder in folders:
            target_dir = os.path.join(self.mod_path, "common/history", folder)
            if not os.path.exists(target_dir): continue
            for root, _, files in os.walk(target_dir):
                if self.stop_event.is_set(): return results
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    try:
                        with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
                    file_changed = False
                    for state in state_list:
                        s_start, s_end = self.get_block_range_safe(content, f"s:{state}")
                        if s_start is not None:
                            block_content = content[s_start:s_end]
                            new_block_content = self.sanitize_block_content(
                                block_content, state, old_tag, new_tag, is_building_file=(folder == "buildings")
                            )
                            if new_block_content != block_content:
                                content = content[:s_start] + new_block_content + content[s_end:]
                                file_changed = True
                                if folder not in results[state]: results[state].append(folder)
                    if file_changed:
                        self.log(f"   [UPDATED] {folder}/{file}")
                        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
        return results

    def clean_unit_string(self, unit_block):
        cleaned = re.sub(r"id\s*=\s*\d+", "", unit_block, flags=re.IGNORECASE)
        cleaned = "\n".join([line for line in cleaned.split('\n') if line.strip()])
        return cleaned

    def generate_immersive_name(self, region_raw, f_type):
        clean_name = region_raw.lower().replace("region_", "").replace("_", " ").title().strip()
        return f"\"{f_type.capitalize()} of {clean_name}\""

    def process_military_extraction_multi_pass(self, filepath, old_tag, new_tag, region, state_list):
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
        clean_states = [re.escape(s.replace("s:","")) for s in state_list]
        state_or_pattern = "|".join(clean_states)
        target_state_regex = re.compile(r"\b(" + state_or_pattern + r")\b", re.IGNORECASE)
        files_modified = False
        stolen_units_army = []
        stolen_units_fleet = []
        current_search_idx = 0
        processed_file_parts = []
        last_idx = 0
        while True:
            c_start, c_end = self.get_block_range_safe(content, f"c:{old_tag}", current_search_idx)
            if c_start is None:
                processed_file_parts.append(content[last_idx:])
                break
            processed_file_parts.append(content[last_idx:c_start])
            body_start_brace, body_end_brace = self.find_block_content(content, c_start)
            if body_start_brace is None:
                processed_file_parts.append(content[c_start:c_end])
                last_idx = c_end
                current_search_idx = c_end
                continue
            header = content[c_start:body_start_brace+1]
            inner_body = content[body_start_brace+1:body_end_brace-1]
            footer = "}"
            new_inner_parts = []
            cursor = 0
            while cursor < len(inner_body):
                match = re.search(r"create_military_formation\s*=\s*\{", inner_body[cursor:])
                if not match:
                    new_inner_parts.append(inner_body[cursor:])
                    break
                abs_match_start = cursor + match.start()
                new_inner_parts.append(inner_body[cursor:abs_match_start])
                brace_idx = abs_match_start + match.group().find('{')
                f_start, f_end = self.find_block_content(inner_body, brace_idx)
                if f_start is None:
                    new_inner_parts.append(inner_body[abs_match_start:])
                    break
                formation_full = inner_body[abs_match_start:f_end]
                is_army = "type" in formation_full and "army" in formation_full.lower()
                is_fleet = "type" in formation_full and "fleet" in formation_full.lower()
                if is_army or is_fleet:
                    f_header = formation_full[:f_start - abs_match_start + 1]
                    f_body = formation_full[f_start - abs_match_start + 1 : -1]
                    f_footer = "}"
                    new_f_body_parts = []
                    f_cursor = 0
                    while f_cursor < len(f_body):
                        u_match = re.search(r"combat_unit\s*=\s*\{", f_body[f_cursor:])
                        if not u_match:
                            new_f_body_parts.append(f_body[f_cursor:])
                            break
                        u_abs_start = f_cursor + u_match.start()
                        new_f_body_parts.append(f_body[f_cursor:u_abs_start])
                        u_brace_idx = u_abs_start + u_match.group().find('{')
                        u_start, u_end = self.find_block_content(f_body, u_brace_idx)
                        if u_start is None:
                            new_f_body_parts.append(f_body[u_abs_start:])
                            break
                        unit_block = f_body[u_abs_start:u_end]
                        if target_state_regex.search(unit_block):
                            self.log(f"      [PURGE] Found ghost unit in {old_tag}. Moving!")
                            clean_block = self.clean_unit_string(unit_block)
                            if is_army: stolen_units_army.append(clean_block)
                            elif is_fleet: stolen_units_fleet.append(clean_block)
                            files_modified = True
                        else:
                            new_f_body_parts.append(unit_block)
                        f_cursor = u_end
                    rebuilt_formation_body = "".join(new_f_body_parts)
                    if "combat_unit" not in rebuilt_formation_body:
                        self.log(f"      [DELETE] Formation became empty. Deleted.")
                        files_modified = True
                    else:
                        new_inner_parts.append(f_header + rebuilt_formation_body + f_footer)
                else:
                    new_inner_parts.append(formation_full)
                cursor = f_end
            processed_file_parts.append(header + "".join(new_inner_parts) + footer)
            last_idx = c_end
            current_search_idx = c_end 
        if not files_modified: return False
        new_file_content = "".join(processed_file_parts)

        def inject_new_formation(file_content, unit_buffer, f_type):
            if not unit_buffer: return file_content
            clean_region_str = region.strip()
            if not clean_region_str.startswith("sr:") and "region_" in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            elif not clean_region_str.startswith("sr:") and "region_" not in clean_region_str:
                hq_region_val = f"sr:{clean_region_str}"
            else:
                hq_region_val = clean_region_str
            immersive_name = self.generate_immersive_name(clean_region_str, f_type)
            block_str = f"""
\tcreate_military_formation = {{
\t\tname = {immersive_name}
\t\ttype = {f_type}
\t\thq_region = {hq_region_val}
\t\t# Transferred Units
\t\t{"\n\t\t".join(unit_buffer)}
\t}}
"""
            last_tag_pos = -1
            curr = 0
            while True:
                ns, ne = self.get_block_range_safe(file_content, f"c:{new_tag}", curr)
                if ns is None: break
                last_tag_pos = ns
                curr = ne
            if last_tag_pos != -1:
                _, end_brace = self.find_block_content(file_content, last_tag_pos)
                insert_pos = end_brace - 1
                return file_content[:insert_pos] + "\n" + block_str + "\n" + file_content[insert_pos:]
            else:
                # NEW LOGIC: Check for MILITARY_FORMATIONS wrapper to insert inside it
                mf_start, mf_end = self.get_block_range_safe(file_content, "MILITARY_FORMATIONS")
                if mf_start is not None:
                    # Insert before the last brace of the wrapper
                    insert_pos = mf_end - 1
                    return file_content[:insert_pos] + f"\n\tc:{new_tag} ?= {{\n{block_str}\n\t}}\n" + file_content[insert_pos:]
                else:
                    return file_content + f"\n\nc:{new_tag} ?= {{\n{block_str}\n}}\n"
        if stolen_units_army:
            self.log(f"      [CREATE] Creating Army for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_army, "army")
        if stolen_units_fleet:
            self.log(f"      [CREATE] Creating Fleet for {new_tag}")
            new_file_content = inject_new_formation(new_file_content, stolen_units_fleet, "fleet")
        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(new_file_content)
        return True

    def clean_military_smart(self, old_tag, new_tag, region, state_list):
        if not region: return
        mil_dir = os.path.join(self.mod_path, "common/history/military_formations")
        if os.path.exists(mil_dir):
            for root, _, files in os.walk(mil_dir):
                if self.stop_event.is_set(): return
                for file in files:
                    if not file.endswith(".txt"): continue
                    filepath = os.path.join(root, file)
                    self.process_military_extraction_multi_pass(filepath, old_tag, new_tag, region, state_list)

    # --- COUNTRY MODIFICATION LOGIC ---
    def load_country_localization(self, tag):
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        if not os.path.exists(loc_dir): return "", ""

        name = ""
        adj = ""

        def search_dir(directory):
            n, a = "", ""
            if not os.path.exists(directory): return "", ""
            for root, _, files in os.walk(directory):
                for file in files:
                    if not file.endswith(".yml"): continue
                    try:
                        with open(os.path.join(root, file), 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()

                    m_name = re.search(r'^\s*' + re.escape(tag) + r':\d?\s*"(.*)"', content, re.MULTILINE | re.IGNORECASE)
                    if m_name: n = m_name.group(1)

                    m_adj = re.search(r'^\s*' + re.escape(tag) + r'_ADJ:\d?\s*"(.*)"', content, re.MULTILINE | re.IGNORECASE)
                    if m_adj: a = m_adj.group(1)
            return n, a

        n1, a1 = search_dir(loc_dir)
        n2, a2 = search_dir(os.path.join(loc_dir, "replace"))
        return (n2 if n2 else n1), (a2 if a2 else a1)

    def save_country_localization(self, tag, name, adj):
        loc_dir = os.path.join(self.mod_path, "localization", "english")
        rep_dir = os.path.join(loc_dir, "replace")
        os.makedirs(rep_dir, exist_ok=True)

        # Check if a replace file for this tag already exists to append/modify
        target_file = None
        for root, _, files in os.walk(rep_dir):
            for file in files:
                if not file.endswith(".yml"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                if re.search(r"^\s*" + re.escape(tag) + r":", content, re.MULTILINE):
                    target_file = path
                    break
            if target_file: break

        if not target_file:
            target_file = os.path.join(rep_dir, f"{tag.lower()}_l_english.yml")
            if not os.path.exists(target_file):
                 with open(target_file, 'w', encoding='utf-8-sig') as f: f.write("l_english:\n")

        try:
            with open(target_file, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(target_file, 'r', encoding='utf-8') as f: content = f.read()

        # Update Name
        if re.search(r"^\s*" + re.escape(tag) + r":", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r':.*', f' {tag}: "{name}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}: "{name}"\n'

        # Update Adjective
        if re.search(r"^\s*" + re.escape(tag) + r"_ADJ:", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r'_ADJ:.*', f' {tag}_ADJ: "{adj}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}_ADJ: "{adj}"\n'

        # Update Def
        if re.search(r"^\s*" + re.escape(tag) + r"_DEF:", content, re.MULTILINE):
            content = re.sub(r'^\s*' + re.escape(tag) + r'_DEF:.*', f' {tag}_DEF: "{name}"', content, flags=re.MULTILINE)
        else:
            content += f' {tag}_DEF: "{name}"\n'

        with open(target_file, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[SAVE] Localization saved to {target_file}", 'success')

    def load_country_definition_data(self, tag):
        def_path = os.path.join(self.mod_path, "common", "country_definitions")
        if not os.path.exists(def_path): return None, None, None
        clean_tag = tag.strip()
        for root, _, files in os.walk(def_path):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                match = re.search(r"(^|\s)" + re.escape(clean_tag) + r"\s*=\s*\{", content, re.MULTILINE)
                if match:
                    start = match.end() - 1
                    _, end = self.find_block_content(content, start)
                    if end:
                        block = content[start:end]
                        c_match = re.search(r"color\s*=\s*\{\s*(\d+)\s+(\d+)\s+(\d+)\s*\}", block)
                        rgb = (0,0,0)
                        if c_match: rgb = (int(c_match.group(1)), int(c_match.group(2)), int(c_match.group(3)))
                        cap_match = re.search(r"(capital|capital_state)\s*=\s*([A-Za-z0-9_]+)", block)
                        capital = cap_match.group(2) if cap_match else ""
                        return rgb, capital, path
        return None, None, None

    def save_country_definition(self, tag, rgb, capital, filepath):
        if not filepath or not os.path.exists(filepath):
            self.log("[ERROR] Definition file not found to update.", 'error')
            return
        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()
        match = re.search(r"(^|\s)" + re.escape(tag) + r"\s*=\s*\{", content, re.MULTILINE)
        if match:
            start = match.end() - 1
            _, end = self.find_block_content(content, start)
            if end:
                block = content[start:end]
                new_block = block
                r, g, b = rgb
                if re.search(r"color\s*=", new_block):
                    new_block = re.sub(r"color\s*=\s*\{[^}]+\}", f"color = {{ {r} {g} {b} }}", new_block)
                else:
                    new_block = new_block[:new_block.rfind('}')] + f"\n\tcolor = {{ {r} {g} {b} }}\n}}"
                if capital:
                    if re.search(r"(capital|capital_state)\s*=", new_block):
                         new_block = re.sub(r"(capital|capital_state)\s*=\s*[A-Za-z0-9_]+", f"capital = {capital}", new_block)
                    else:
                         new_block = new_block[:new_block.rfind('}')] + f"\n\tcapital = {capital}\n}}"
                content = content[:start] + new_block + content[end:]
                with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
                self.log(f"[SAVE] Updated definitions in {filepath}", 'success')

    def load_character_template(self, template_name):
        tmpl_dir = os.path.join(self.mod_path, "common", "character_templates")
        if not os.path.exists(tmpl_dir): return None
        for root, _, files in os.walk(tmpl_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                # Search for template = { ... }
                # Using regex to find start, then block helper
                m = re.search(r"(^|\s)" + re.escape(template_name) + r"\s*=\s*\{", content, re.IGNORECASE)
                if m:
                    start = m.end() - 1
                    _, end = self.find_block_content(content, start)
                    if end:
                        block = content[start:end]
                        data = {"first": "", "last": "", "ig": "", "ideology": "", "is_ruler": False}
                        if re.search(r"ruler\s*=\s*yes", block, re.IGNORECASE): data["is_ruler"] = True

                        fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block)
                        if fn: data["first"] = fn.group(1) if fn.group(1) else fn.group(2)

                        ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block)
                        if ln: data["last"] = ln.group(1) if ln.group(1) else ln.group(2)

                        ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', block)
                        if ig: data["ig"] = ig.group(1)

                        ideo = re.search(r'(trait|ideology)\s*=\s*(ideology_[A-Za-z0-9_]+)', block)
                        if ideo: data["ideology"] = ideo.group(2)

                        return data
        return None

    def load_country_history_details(self, tag):
        info = { "gov_type": "monarchy", "laws": [], "ruler": {"first": "", "last": "", "ig": "", "ideology": ""} }
        clean_tag = tag.replace("c:", "").strip()

        # 1. Load Laws/Gov from history/countries
        hist_dir = os.path.join(self.mod_path, "common", "history", "countries")
        if os.path.exists(hist_dir):
            for root, _, files in os.walk(hist_dir):
                for file in files:
                    if not file.endswith(".txt"): continue
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(path, 'r', encoding='utf-8') as f: content = f.read()

                    idx = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                        if not s: break
                        block = content[s:e]
                        laws = re.findall(r"activate_law\s*=\s*([A-Za-z0-9_:]+)", block)
                        info["laws"].extend(laws)

                        # Also check for inline rulers here (legacy/simple mod support)
                        char_idx = 0
                        while True:
                            m = re.search(r"create_character\s*=\s*\{", block[char_idx:], re.IGNORECASE)
                            if not m: break
                            abs_start = char_idx + m.start()
                            bs, be = self.find_block_content(block, char_idx + m.end() - 1)
                            if bs:
                                char_block = block[bs:be]
                                if re.search(r"ruler\s*=\s*yes", char_block, re.IGNORECASE):
                                    fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', char_block)
                                    ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', char_block)
                                    ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', char_block)
                                    ideo = re.search(r'trait\s*=\s*(ideology_[A-Za-z0-9_]+)', char_block)
                                    if fn: info["ruler"]["first"] = fn.group(1) if fn.group(1) else fn.group(2)
                                    if ln: info["ruler"]["last"] = ln.group(1) if ln.group(1) else ln.group(2)
                                    if ig: info["ruler"]["ig"] = ig.group(1)
                                    if ideo: info["ruler"]["ideology"] = ideo.group(1)
                                char_idx = be
                            else: break
                        idx = e

        # 2. Check history/characters for templates (Overwrites inline if found)
        char_hist_dir = os.path.join(self.mod_path, "common", "history", "characters")
        if os.path.exists(char_hist_dir):
            for root, _, files in os.walk(char_hist_dir):
                for file in files:
                    if not file.endswith(".txt"): continue
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                    except:
                        with open(path, 'r', encoding='utf-8') as f: content = f.read()

                    idx = 0
                    while True:
                        s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                        if not s: break
                        block = content[s:e]

                        # Scan for create_character with templates
                        c_cursor = 0
                        while True:
                            m = re.search(r"create_character\s*=\s*\{", block[c_cursor:], re.IGNORECASE)
                            if not m: break
                            start = c_cursor + m.start()
                            bs, be = self.find_block_content(block, c_cursor + m.end() - 1)
                            if bs:
                                inner = block[bs:be]
                                tmpl_match = re.search(r"template\s*=\s*([A-Za-z0-9_.-]+)", inner, re.IGNORECASE)
                                if tmpl_match:
                                    template_name = tmpl_match.group(1)
                                    t_data = self.load_character_template(template_name)
                                    if t_data and t_data["is_ruler"]:
                                        info["ruler"]["first"] = t_data["first"]
                                        info["ruler"]["last"] = t_data["last"]
                                        info["ruler"]["ig"] = t_data["ig"]
                                        info["ruler"]["ideology"] = t_data["ideology"]
                                c_cursor = be
                            else: break
                        idx = e

        # Normalize laws
        info["laws"] = [l.replace("law_type:", "") for l in info["laws"]]

        # 3. Fallback: Check character_templates directly for "country_tag" file if no ruler found yet
        # (This handles cases where history files are hard to parse or missing, but templates exist)
        if not info["ruler"]["first"]:
            tmpl_dir = os.path.join(self.mod_path, "common", "character_templates")
            if os.path.exists(tmpl_dir):
                target_fname = f"country_{clean_tag}"
                for root, _, files in os.walk(tmpl_dir):
                    for file in files:
                        if not file.endswith(".txt"): continue
                        # loose match for filename
                        if target_fname.lower() in file.lower() or clean_tag.lower() in file.lower():
                            path = os.path.join(root, file)
                            try:
                                with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                            except:
                                with open(path, 'r', encoding='utf-8') as f: content = f.read()

                            # Scan all top-level blocks
                            cursor = 0
                            while cursor < len(content):
                                # Find start of a block: KEY = {
                                m = re.search(r"([A-Za-z0-9_.-]+)\s*=\s*\{", content[cursor:])
                                if not m: break
                                start = cursor + m.start()
                                bs, be = self.find_block_content(content, cursor + m.end() - 1)
                                if bs:
                                    block_inner = content[bs:be]
                                    if re.search(r"ruler\s*=\s*yes", block_inner, re.IGNORECASE):
                                        # Found a ruler definition!
                                        fn = re.search(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block_inner)
                                        if fn: info["ruler"]["first"] = fn.group(1) if fn.group(1) else fn.group(2)

                                        ln = re.search(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', block_inner)
                                        if ln: info["ruler"]["last"] = ln.group(1) if ln.group(1) else ln.group(2)

                                        ig = re.search(r'interest_group\s*=\s*([A-Za-z0-9_]+)', block_inner)
                                        if ig: info["ruler"]["ig"] = ig.group(1)

                                        ideo = re.search(r'(trait|ideology)\s*=\s*(ideology_[A-Za-z0-9_]+)', block_inner)
                                        if ideo: info["ruler"]["ideology"] = ideo.group(2)

                                        # Stop after finding the first ruler in the file
                                        break
                                    cursor = be
                                else:
                                    # Should not happen if well formed, but skip forward
                                    cursor = start + 1

                            if info["ruler"]["first"]: break
                    if info["ruler"]["first"]: break

        if "law_monarchy" in info["laws"]: info["gov_type"] = "monarchy"
        elif "law_presidential_republic" in info["laws"] or "law_parliamentary_republic" in info["laws"]: info["gov_type"] = "republic"
        elif "law_theocracy" in info["laws"]: info["gov_type"] = "theocracy"
        return info

    def save_country_history(self, tag, gov_type, laws, ruler_info):
        hist_dir = os.path.join(self.mod_path, "common", "history", "countries")
        clean_tag = tag.replace("c:", "").strip()
        target_path = None
        target_content = None
        for root, _, files in os.walk(hist_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()
                if re.search(r"c:" + re.escape(clean_tag) + r"\b", content):
                    target_path = path; target_content = content; break

        if not target_path: return self.log("[ERROR] No history file found.", 'error')
        s, e = self.get_block_range_safe(target_content, f"c:{clean_tag}")
        if not s: return
        block = target_content[s:e]
        new_block = block

        # Laws
        gov_law = "law_monarchy"
        if gov_type == "republic": gov_law = "law_presidential_republic"
        elif gov_type == "theocracy": gov_law = "law_theocracy"

        laws_to_set = [gov_law] + laws
        if gov_type == "republic": laws_to_set.append("law_appointed_bureaucrats")

        exclusive_laws = [
            ["law_monarchy", "law_presidential_republic", "law_parliamentary_republic", "law_theocracy", "law_council_republic"],
            ["law_interventionism", "law_laissez_faire", "law_command_economy", "law_traditionalism", "law_agrarianism"],
            ["law_free_trade", "law_protectionism", "law_isolationism", "law_mercantilism"],
            ["law_autocracy", "law_oligarchy", "law_landed_voting", "law_wealth_voting", "law_census_voting", "law_universal_suffrage", "law_anarchy", "law_single_party_state"]
        ]

        for law in laws_to_set:
            # Remove conflicting
            for group in exclusive_laws:
                if law in group:
                    for ex in group:
                        if ex != law:
                            new_block = re.sub(r"\s*activate_law\s*=\s*(law_type:)?" + re.escape(ex) + r"\b", "", new_block)

            # Add if missing
            if not re.search(r"activate_law\s*=\s*(law_type:)?" + re.escape(law), new_block):
                 new_block = new_block[:new_block.rfind('}')] + f"\n\t\tactivate_law = law_type:{law}\n\t}}"

        # Ruler
        char_idx = 0
        ruler_start = -1; ruler_end = -1
        while True:
            m = re.search(r"create_character\s*=\s*\{", new_block[char_idx:])
            if not m: break
            abs_start = char_idx + m.start()
            bs, be = self.find_block_content(new_block, char_idx + m.end() - 1)
            if bs:
                sub = new_block[bs:be]
                if "ruler = yes" in sub: ruler_start = abs_start; ruler_end = be; break
                char_idx = be
            else: break

        if ruler_start != -1:
            # Update existing inline ruler
            rb = new_block[ruler_start:ruler_end]
            if ruler_info["first"]: rb = re.sub(r'first_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', f'first_name = "{ruler_info["first"]}"', rb)
            if ruler_info["last"]: rb = re.sub(r'last_name\s*=\s*(?:"([^"]+)"|([^\s#]+))', f'last_name = "{ruler_info["last"]}"', rb)
            if ruler_info["ig"]: rb = re.sub(r'interest_group\s*=\s*[A-Za-z0-9_]+', f'interest_group = {ruler_info["ig"]}', rb)
            if ruler_info["ideology"]:
                rb = re.sub(r'\s*trait\s*=\s*ideology_[a-z_]+', '', rb)
                rb = rb[:rb.rfind('}')] + f"\n\t\ttrait = {ruler_info['ideology']}\n\t}}"
            new_block = new_block[:ruler_start] + rb + new_block[ruler_end:]
        else:
            # Create new ruler block if none found (overrides/adds to vanilla)
            # Default birth_date needed if creating fresh
            new_ruler_block = f"""
        create_character = {{
            first_name = "{ruler_info['first']}"
            last_name = "{ruler_info['last']}"
            birth_date = 1800.1.1
            ruler = yes
            interest_group = {ruler_info['ig']}
            trait = {ruler_info['ideology']}
        }}"""
            # Insert before closing brace of country block
            new_block = new_block[:new_block.rfind('}')] + new_ruler_block + "\n\t}"

        target_content = target_content[:s] + new_block + target_content[e:]
        with open(target_path, 'w', encoding='utf-8-sig') as f: f.write(target_content)
        self.log(f"[SAVE] History updated in {target_path}", 'success')

    # --- DIPLOMACY LOGIC ---
    # --- DIPLOMACY LOGIC ---
    SUBJECT_TYPES = ["colony", "puppet", "dominion", "protectorate", "tributary", "vassal", "personal_union"]

    def find_and_remove_subject_status(self, tag_to_free):
        """Scans all diplomacy files and removes any subject pact where tag_to_free is the target."""
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        if not os.path.exists(dip_dir): return
        clean_target = tag_to_free.replace("c:", "").strip()

        for root, _, files in os.walk(dip_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                original_content = content
                file_changed = False

                # We need to scan ALL country blocks, because any country could be the overlord
                idx = 0
                while True:
                    # Find next country block
                    match = re.search(r"c:([A-Za-z0-9_]+)\s*\??=\s*\{", content[idx:])
                    if not match: break

                    overlord_tag = match.group(1)
                    abs_start = idx + match.start()
                    s, e = self.find_block_content(content, idx + match.end() - 1)

                    if s:
                        block_body = content[s:e]

                        # Check for subject pacts targeting our tag
                        # create_diplomatic_pact = { country = c:TARGET type = TYPE }
                        new_body_parts = []
                        cursor = 0
                        block_changed = False

                        while cursor < len(block_body):
                            m = re.search(r"create_diplomatic_pact\s*=\s*\{", block_body[cursor:])
                            if not m:
                                new_body_parts.append(block_body[cursor:])
                                break

                            pact_start = cursor + m.start()
                            new_body_parts.append(block_body[cursor:pact_start])

                            bs, be = self.find_block_content(block_body, cursor + m.end() - 1)
                            if bs:
                                pact_inner = block_body[bs:be]
                                is_target = re.search(r"country\s*=\s*c:" + re.escape(clean_target) + r"\b", pact_inner)

                                type_match = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", pact_inner)
                                pact_type = type_match.group(1) if type_match else ""

                                if is_target and pact_type in self.SUBJECT_TYPES:
                                    # This is the pact to remove!
                                    self.log(f"[DIP] Freed {clean_target} from being a {pact_type} of {overlord_tag}", 'warn')
                                    block_changed = True
                                else:
                                    new_body_parts.append(block_body[pact_start:be])
                                cursor = be
                            else:
                                new_body_parts.append(block_body[pact_start:])
                                break

                        if block_changed:
                            # Reconstruct the country block
                            new_block_body = "".join(new_body_parts)
                            # Replace in content (careful with indices, content hasn't changed length yet in loop but we are rebuilding)
                            # To handle this safely in a loop, we usually do one pass or complex offset tracking.
                            # Simpler: If changed, update 'content' and restart loop or adjust offsets?
                            # Since we are iterating top-level blocks, replacing 'content' invalidates 'idx'.

                            # Strategy: Reconstruct the whole file content after processing all blocks?
                            # Or just update this block and update 'e'.

                            # Let's splice it in now
                            prefix = content[:s]
                            suffix = content[e:]
                            content = prefix + new_block_body + suffix
                            file_changed = True

                            # Update e to reflect new length
                            diff = len(new_block_body) - len(block_body)
                            e += diff

                        idx = e
                    else:
                        idx = abs_start + 1 # Should not happen if regex matched

                if file_changed:
                    with open(path, 'w', encoding='utf-8-sig') as f: f.write(content)

    def load_diplomacy_data(self, tag):
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        info = { "subjects": [], "rivals": [], "embargos": [], "truces": [], "relations": [] }
        if not os.path.exists(dip_dir): return info
        clean_tag = tag.replace("c:", "").strip()

        for root, _, files in os.walk(dip_dir):
            for file in files:
                if not file.endswith(".txt"): continue
                path = os.path.join(root, file)
                try:
                    with open(path, 'r', encoding='utf-8-sig') as f: content = f.read()
                except:
                    with open(path, 'r', encoding='utf-8') as f: content = f.read()

                idx = 0
                while True:
                    s, e = self.get_block_range_safe(content, f"c:{clean_tag}", idx)
                    if not s: break
                    block = content[s:e]

                    # Subjects
                    for m in re.finditer(r"create_diplomatic_pact\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        typ = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", inner)
                        if cty and typ:
                            if typ.group(1) in ["rivalry", "embargo"]: continue # Handled elsewhere usually, but check file
                            info["subjects"].append({"target": cty.group(1), "type": typ.group(1)})

                    # Rivals/Embargos (often same structure as pact)
                    # Check filename or explicit types if they are pacts
                    if "rival" in file or "embargo" in file:
                         for m in re.finditer(r"create_diplomatic_pact\s*=\s*\{([^}]+)\}", block):
                            inner = m.group(1)
                            cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                            typ = re.search(r"type\s*=\s*([A-Za-z0-9_]+)", inner)
                            if cty and typ:
                                if typ.group(1) == "rivalry": info["rivals"].append(cty.group(1))
                                elif typ.group(1) == "embargo": info["embargos"].append(cty.group(1))

                    # Truces
                    for m in re.finditer(r"create_bidirectional_truce\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        dur = re.search(r"months\s*=\s*(\d+)", inner)
                        if cty:
                            info["truces"].append({"target": cty.group(1), "months": dur.group(1) if dur else "12"})

                    # Relations
                    for m in re.finditer(r"set_relations\s*=\s*\{([^}]+)\}", block):
                        inner = m.group(1)
                        cty = re.search(r"country\s*=\s*c:([A-Za-z0-9_]+)", inner)
                        val = re.search(r"value\s*=\s*(-?\d+)", inner)
                        if cty and val:
                            info["relations"].append({"target": cty.group(1), "value": val.group(1)})

                    idx = e
        return info

    def add_diplomatic_pact(self, tag, target, pact_type, category):
        # category: subject, rival, embargo, truce
        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        # VALIDATION: If creating a subject, ensure no conflicts
        if category == "subject":
            # 1. Target cannot already be a subject
            self.find_and_remove_subject_status(clean_target)
            # 2. Actor (Overlord) cannot be a subject themselves
            self.find_and_remove_subject_status(clean_tag)

        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        os.makedirs(dip_dir, exist_ok=True)
        filename = "00_subject_relationships.txt"
        if category == "rival": filename = "00_rivalries.txt"
        elif category == "embargo": filename = "00_embargos.txt"
        elif category == "truce": filename = "00_truces.txt"

        filepath = os.path.join(dip_dir, filename)
        if not os.path.exists(filepath):
             with open(filepath, 'w', encoding='utf-8-sig') as f: f.write("DIPLOMACY = {\n}")

        try:
            with open(filepath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(filepath, 'r', encoding='utf-8') as f: content = f.read()

        # Build entry
        entry = ""
        if category == "truce":
             entry = f"\t\tcreate_bidirectional_truce = {{ country = c:{clean_target} months = 60 }}"
        else:
             entry = f"\t\tcreate_diplomatic_pact = {{ country = c:{clean_target} type = {pact_type} }}"

        # Insert
        s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
        if s:
            # Append to existing block
            block = content[s:e]
            new_block = block[:block.rfind('}')] + "\n" + entry + "\n\t}"
            content = content[:s] + new_block + content[e:]
        else:
            # Create new block
            # Find DIPLOMACY block
            d_s, d_e = self.get_block_range_safe(content, "DIPLOMACY")
            if d_s:
                new_block = f"\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}"
                content = content[:d_e-1] + new_block + "\n}" + content[d_e:]
            else:
                content += f"\nDIPLOMACY = {{\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}\n}}"

        with open(filepath, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[DIP] Added {pact_type} with {clean_target} in {filename}", 'success')

    def remove_diplomatic_pact(self, tag, target, pact_type):
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        files_to_check = ["00_subject_relationships.txt", "00_rivalries.txt", "00_embargos.txt", "00_truces.txt"]

        for fname in files_to_check:
            fpath = os.path.join(dip_dir, fname)
            if not os.path.exists(fpath): continue

            try:
                with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
            except:
                with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

            s, e = self.get_block_range_safe(content, f"c:{clean_tag}")
            if not s: continue

            block = content[s:e]

            # Regex to match the specific pact
            # Need to match { ... country = c:TARGET ... type = TYPE } across lines
            # This is hard with regex alone.

            # Simple approach: Find block start, verify content, remove.
            # Using block finder again inside.

            new_inner_parts = []
            cursor = 0
            # Skip header "c:TAG ?= {"
            header_len = content[s:].find('{') + 1
            inner_body = block[header_len:-1]

            change_made = False

            while cursor < len(inner_body):
                m = re.search(r"(create_diplomatic_pact|create_bidirectional_truce)\s*=\s*\{", inner_body[cursor:])
                if not m:
                    new_inner_parts.append(inner_body[cursor:])
                    break

                abs_start = cursor + m.start()
                new_inner_parts.append(inner_body[cursor:abs_start])

                bs, be = self.find_block_content(inner_body, cursor + m.end() - 1)
                if bs:
                    pact_block = inner_body[bs:be]

                    # Check if this is the one to delete
                    is_target = f"c:{clean_target}" in pact_block
                    is_type = (pact_type in pact_block) if pact_type != "truce" else True # Truce doesn't have type field usually

                    if is_target and is_type:
                        change_made = True
                        # Skip this block (don't append)
                    else:
                        new_inner_parts.append(inner_body[abs_start:be])
                    cursor = be
                else:
                    new_inner_parts.append(inner_body[abs_start:])
                    break

            if change_made:
                new_block = block[:header_len] + "".join(new_inner_parts) + "}"
                content = content[:s] + new_block + content[e:]
                with open(fpath, 'w', encoding='utf-8-sig') as f: f.write(content)
                self.log(f"[DIP] Removed {pact_type} with {clean_target} from {fname}", 'success')

    def set_relations(self, tag, target, value):
        dip_dir = os.path.join(self.mod_path, "common", "history", "diplomacy")
        os.makedirs(dip_dir, exist_ok=True)
        fpath = os.path.join(dip_dir, "00_relations.txt")
        if not os.path.exists(fpath):
             with open(fpath, 'w', encoding='utf-8-sig') as f: f.write("DIPLOMACY = {\n}")

        try:
            with open(fpath, 'r', encoding='utf-8-sig') as f: content = f.read()
        except:
            with open(fpath, 'r', encoding='utf-8') as f: content = f.read()

        clean_tag = tag.replace("c:", "").strip()
        clean_target = target.replace("c:", "").strip()

        # We need to remove existing set_relations for this target first
        s, e = self.get_block_range_safe(content, f"c:{clean_tag}")

        entry = f"\t\tset_relations = {{ country = c:{clean_target} value = {value} }}"

        if s:
            block = content[s:e]
            # Remove existing relation to target
            # Regex: set_relations = { country = c:TARGET value = ... }
            block = re.sub(r"set_relations\s*=\s*\{[^}]*c:" + re.escape(clean_target) + r"\b[^}]*\}", "", block)
            # Append new
            new_block = block[:block.rfind('}')] + "\n" + entry + "\n\t}"
            content = content[:s] + new_block + content[e:]
        else:
             # Create new block
            d_s, d_e = self.get_block_range_safe(content, "DIPLOMACY")
            if d_s:
                new_block = f"\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}"
                content = content[:d_e-1] + new_block + "\n}" + content[d_e:]
            else:
                content += f"\nDIPLOMACY = {{\n\tc:{clean_tag} ?= {{\n{entry}\n\t}}\n}}"

        with open(fpath, 'w', encoding='utf-8-sig') as f: f.write(content)
        self.log(f"[DIP] Relations set to {value} with {clean_target}", 'success')

# =============================================================================
#  GUI IMPLEMENTATION
# =============================================================================

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Victoria 3 Modding Tool")
        self.geometry("850x700")
        self.configure(bg="#212121")
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self._configure_dark_theme()

        self.logic = Vic3Logic(self.log_message)
        self.log_queue = queue.Queue()
        self.is_processing = False
        self.cr_rgb = [random.randint(0,255), random.randint(0,255), random.randint(0,255)]

        self._build_ui()
        self.load_config()
        self.after(100, self.process_log_queue)

    def _configure_dark_theme(self):
        BG_COLOR = "#212121"
        FG_COLOR = "#ECEFF1"
        ACCENT_COLOR = "#00ACC1"
        SECONDARY_BG = "#323232"
        ENTRY_BG = "#424242"
        self.style.configure('.', background=BG_COLOR, foreground=FG_COLOR, font=('Segoe UI', 10))
        self.style.configure('TLabel', background=BG_COLOR, foreground=FG_COLOR)
        self.style.configure('TFrame', background=BG_COLOR)
        self.style.configure('TLabelframe', background=BG_COLOR, foreground=FG_COLOR, bordercolor=SECONDARY_BG)
        self.style.configure('TLabelframe.Label', background=BG_COLOR, foreground=ACCENT_COLOR, font=('Segoe UI', 10, 'bold'))
        self.style.configure('TButton', background=SECONDARY_BG, foreground=FG_COLOR, borderwidth=1, focuscolor=SECONDARY_BG)
        self.style.map('TButton', background=[('active', ACCENT_COLOR), ('disabled', '#2a2a2a')], foreground=[('disabled', '#666666')])
        self.style.configure('TEntry', fieldbackground=ENTRY_BG, foreground=FG_COLOR, bordercolor=SECONDARY_BG, lightcolor=SECONDARY_BG, darkcolor=SECONDARY_BG)
        self.style.configure('TCheckbutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TCheckbutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])
        self.style.configure('TRadiobutton', background=BG_COLOR, foreground=FG_COLOR)
        self.style.map('TRadiobutton', background=[('active', BG_COLOR)], indicatorcolor=[('selected', ACCENT_COLOR)])

        # Combobox colors - Force black text for readability
        self.option_add('*TCombobox*Listbox.foreground', 'black')
        self.option_add('*TCombobox*Listbox.background', 'white')
        self.style.configure('TCombobox', foreground='black', fieldbackground='white', background='white')

    def load_config(self):
        try:
            if os.path.exists("config.json"):
                with open("config.json", "r") as f:
                    data = json.load(f)
                    path = data.get("mod_path", "")
                    if os.path.exists(path):
                        self.path_var.set(path)
                        self.logic.set_mod_path(path)
                        self.log_message(f"Loaded Mod Path: {path}")
        except: pass

    def save_config(self):
        try:
            with open("config.json", "w") as f:
                json.dump({"mod_path": self.path_var.get()}, f)
        except: pass

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Mod Path
        path_frame = ttk.LabelFrame(main_frame, text="Global Configuration", padding=15)
        path_frame.pack(fill=tk.X, pady=(0, 10))
        self.path_var = tk.StringVar()
        ttk.Label(path_frame, text="Mod Directory:").pack(side=tk.LEFT, padx=(0, 5))
        ttk.Entry(path_frame, textvariable=self.path_var, width=60).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(path_frame, text="Browse...", command=self.browse_folder).pack(side=tk.LEFT, padx=5)

        # 2. Navigation
        nav_frame = ttk.Frame(main_frame)
        nav_frame.pack(fill=tk.X, pady=(0, 10))
        ttk.Button(nav_frame, text="Transfer States", command=self.show_transfer_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Country", command=self.show_create_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Army", command=self.show_army_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Create Navy", command=self.show_navy_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Modify Country", command=self.show_country_mod_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        ttk.Button(nav_frame, text="Diplomacy", command=self.show_diplomacy_ui).pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        # 3. Dynamic Content
        self.content_frame = ttk.Frame(main_frame)
        self.content_frame.pack(fill=tk.BOTH, expand=False, pady=5)

        # 4. Action & Log
        self.action_frame = ttk.Frame(main_frame, padding=(0, 10))
        self.action_frame.pack(fill=tk.X)
        self.run_btn = ttk.Button(self.action_frame, text="Execute", command=lambda: None)
        self.run_btn.pack(side=tk.RIGHT, padx=5)
        
        log_frame = ttk.LabelFrame(main_frame, text="Execution Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        self.log_area = scrolledtext.ScrolledText(log_frame, state='disabled', height=10, bg="#1e1e1e", fg="#d4d4d4", insertbackground="white", relief="flat")
        self.log_area.pack(fill=tk.BOTH, expand=True)
        self.log_area.tag_config('info', foreground='#d4d4d4')
        self.log_area.tag_config('warn', foreground='#FFA726')
        self.log_area.tag_config('error', foreground='#EF5350')
        self.log_area.tag_config('success', foreground='#66BB6A')

        self.show_transfer_ui()

    def clear_content(self):
        for widget in self.content_frame.winfo_children():
            widget.destroy()

    # --- MODE 1: TRANSFER STATES ---
    def show_transfer_ui(self):
        self.clear_content()
        self.mode = "TRANSFER"
        f = ttk.LabelFrame(self.content_frame, text="Transfer States Mode", padding=15)
        f.pack(fill=tk.X)
        ttk.Label(f, text="Old Owner Tag (e.g. fra):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.tr_old_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_old_tag, width=15).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="New Owner Tag (e.g. gbr):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.tr_new_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.tr_new_tag, width=15).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="States (Space separated):").grid(row=2, column=0, sticky=tk.NW, pady=8)
        self.tr_states = tk.Text(f, height=4, width=50, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat", padx=5, pady=5)
        self.tr_states.grid(row=2, column=1, columnspan=2, sticky=tk.W, pady=8, padx=5)
        self.tr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation (Auto-detect all states)", variable=self.tr_annex).grid(row=4, column=1, sticky=tk.W, pady=5)
        self.run_btn.config(text="Execute Transfer", command=self.start_transfer)

    # --- MODE 2: CREATE COUNTRY ---
    def show_create_ui(self):
        self.clear_content()
        self.mode = "CREATE"

        all_cultures, all_religions, all_tiers, all_types = self.logic.scan_definitions_for_options()

        if not all_tiers: all_tiers = ["empire", "kingdom", "grand_principality", "principality", "city_state"]
        if not all_types: all_types = ["recognized", "unrecognized", "colonial"]

        f = ttk.LabelFrame(self.content_frame, text="Create Country Mode", padding=15)
        f.pack(fill=tk.X)

        # Row 0
        ttk.Label(f, text="New Country Tag (3 chars):").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.cr_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Country Name:").grid(row=0, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_name = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_name, width=25).grid(row=0, column=3, sticky=tk.W, pady=5)

        # Row 1
        ttk.Label(f, text="Adjective:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.cr_adj = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_adj, width=25).grid(row=1, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Taken From (Old Tag):").grid(row=1, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_old_owner = tk.StringVar()
        e_old = ttk.Entry(f, textvariable=self.cr_old_owner, width=10)
        e_old.grid(row=1, column=3, sticky=tk.W, pady=5)
        e_old.bind("<FocusOut>", self.on_old_owner_change)
        
        # Row 2
        ttk.Label(f, text="Capital State (e.g. aquitaine):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.cr_capital = tk.StringVar()
        ttk.Entry(f, textvariable=self.cr_capital, width=25).grid(row=2, column=1, sticky=tk.W, pady=5)
        
        self.cr_annex = tk.BooleanVar()
        ttk.Checkbutton(f, text="Full Annexation", variable=self.cr_annex, command=self.toggle_annex_ui).grid(row=2, column=2, columnspan=2, sticky=tk.W, padx=10)

        # Row 3
        ttk.Label(f, text="Tier:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.cr_tier = tk.StringVar(value="principality")
        ttk.Combobox(f, textvariable=self.cr_tier, values=all_tiers, state="readonly").grid(row=3, column=1, sticky=tk.W, pady=5)

        ttk.Label(f, text="Type:").grid(row=3, column=2, sticky=tk.W, pady=5, padx=10)
        self.cr_type = tk.StringVar(value="recognized")
        ttk.Combobox(f, textvariable=self.cr_type, values=all_types, state="readonly").grid(row=3, column=3, sticky=tk.W, pady=5)

        # Row 4
        ttk.Label(f, text="Gov Type:").grid(row=4, column=0, sticky=tk.W, pady=5)
        self.cr_gov = tk.StringVar(value="monarchy")
        f_gov = ttk.Frame(f); f_gov.grid(row=4, column=1, sticky=tk.W)
        ttk.Radiobutton(f_gov, text="Monarchy", variable=self.cr_gov, value="monarchy").pack(side=tk.LEFT)
        ttk.Radiobutton(f_gov, text="Republic", variable=self.cr_gov, value="republic").pack(side=tk.LEFT)

        ttk.Button(f, text="Pick Color", command=self.pick_color).grid(row=4, column=2, sticky=tk.W, padx=10)
        self.color_preview = tk.Label(f, text="     ", bg=self._rgb_to_hex(self.cr_rgb), relief="solid", borderwidth=1)
        self.color_preview.grid(row=4, column=3, sticky=tk.W)

        # Row 5: Cultures
        self.all_cultures_data = all_cultures
        f_cult = ttk.LabelFrame(f, text="Cultures (Defaults to old tag's default culture)", padding=5)
        f_cult.grid(row=5, column=0, columnspan=2, sticky=tk.NSEW, pady=5)

        self.cr_cult_search = tk.StringVar()
        self.cb_cultures = ttk.Combobox(f_cult, textvariable=self.cr_cult_search, values=all_cultures)
        self.cb_cultures.pack(fill=tk.X)
        self.cb_cultures.bind("<<ComboboxSelected>>", self.add_culture_from_combo)
        self.cb_cultures.bind("<KeyRelease>", self.filter_culture_options)

        self.lb_cultures = tk.Listbox(f_cult, height=4, bg="#424242", fg="#ECEFF1", selectmode=tk.SINGLE)
        self.lb_cultures.pack(fill=tk.BOTH, expand=True, pady=2)

        ttk.Button(f_cult, text="Remove Selected", command=self.remove_culture).pack(fill=tk.X)
        self.selected_cultures = []

        # Row 5: Religion
        f_rel = ttk.LabelFrame(f, text="Religion (Defaults to old tag's default religion)", padding=5)
        f_rel.grid(row=5, column=2, columnspan=2, sticky=tk.NSEW, pady=5, padx=5)

        canvas = tk.Canvas(f_rel, bg="#212121", height=100)
        scrollbar = ttk.Scrollbar(f_rel, orient="vertical", command=canvas.yview)
        self.scrollable_rel_frame = ttk.Frame(canvas)

        self.scrollable_rel_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=self.scrollable_rel_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.cr_religion = tk.StringVar()
        for r in all_religions:
            ttk.Radiobutton(self.scrollable_rel_frame, text=r, variable=self.cr_religion, value=r).pack(anchor=tk.W)

        # Row 6
        self.lbl_others = ttk.Label(f, text="Other States (Space sep.):\n(Must be states owned by the old tag)")
        self.lbl_others.grid(row=6, column=0, sticky=tk.NW, pady=5)
        self.cr_others = tk.Text(f, height=3, width=40, bg="#424242", fg="#ECEFF1", insertbackground="white", relief="flat")
        self.cr_others.grid(row=6, column=1, columnspan=3, sticky=tk.W, pady=5)

        self.run_btn.config(text="Create & Transfer", command=self.start_create)

    def toggle_annex_ui(self):
        if self.cr_annex.get():
            self.lbl_others.grid_remove()
            self.cr_others.grid_remove()
        else:
            self.lbl_others.grid()
            self.cr_others.grid()

    def on_old_owner_change(self, event):
        # User requested to NOT populate the UI boxes automatically to keep them blank.
        # The background logic in start_create will handle defaults if these remain empty.
        pass
    
    def filter_culture_options(self, event):
        typed = self.cr_cult_search.get().strip().lower()
        if not typed:
            self.cb_cultures['values'] = self.all_cultures_data
        else:
            filtered = [c for c in self.all_cultures_data if c.lower().startswith(typed)]
            self.cb_cultures['values'] = filtered

            # Optional: Open the dropdown if there are matches (can be intrusive, but user requested 'visible')
            # if filtered:
            #     self.cb_cultures.event_generate('<Down>')

    def add_culture_from_combo(self, event):
        val = self.cr_cult_search.get()
        self.add_culture(val)
        self.cr_cult_search.set("")
        self.cb_cultures['values'] = self.all_cultures_data

    def add_culture(self, culture):
        if culture and culture not in self.selected_cultures:
            self.selected_cultures.append(culture)
            self.lb_cultures.insert(tk.END, culture)

    def remove_culture(self):
        sel = self.lb_cultures.curselection()
        if sel:
            idx = sel[0]
            val = self.lb_cultures.get(idx)
            self.selected_cultures.remove(val)
            self.lb_cultures.delete(idx)

    # --- MODE 3: CREATE ARMY ---
    def show_army_ui(self):
        self.clear_content()
        self.mode = "ARMY"
        f = ttk.LabelFrame(self.content_frame, text="Create Army Template", padding=15)
        f.pack(fill=tk.X)
        ttk.Label(f, text="Country Tag:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.arm_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.arm_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="Army Name:").grid(row=0, column=2, sticky=tk.W, pady=5)
        self.arm_name = tk.StringVar(value="First Army")
        ttk.Entry(f, textvariable=self.arm_name, width=20).grid(row=0, column=3, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="Target State (Opt):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.arm_state = tk.StringVar()
        ttk.Entry(f, textvariable=self.arm_state, width=20).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        ttk.Label(f, text="(Defaults to Capital if empty/invalid)").grid(row=1, column=2, columnspan=2, sticky=tk.W)
        u_frame = ttk.LabelFrame(f, text="Composition", padding=10)
        u_frame.grid(row=2, column=0, columnspan=4, sticky=tk.W+tk.E, pady=10)
        ttk.Label(u_frame, text="Infantry:").grid(row=0, column=0, padx=5)
        self.arm_inf = tk.IntVar(value=10)
        ttk.Entry(u_frame, textvariable=self.arm_inf, width=5).grid(row=0, column=1, padx=5)
        ttk.Label(u_frame, text="Artillery:").grid(row=0, column=2, padx=5)
        self.arm_art = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.arm_art, width=5).grid(row=0, column=3, padx=5)
        ttk.Label(u_frame, text="Cavalry:").grid(row=0, column=4, padx=5)
        self.arm_cav = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.arm_cav, width=5).grid(row=0, column=5, padx=5)
        self.run_btn.config(text="Create Army", command=self.start_create_army)

    # --- MODE 4: CREATE NAVY ---
    def show_navy_ui(self):
        self.clear_content()
        self.mode = "NAVY"
        f = ttk.LabelFrame(self.content_frame, text="Create Navy Template", padding=15)
        f.pack(fill=tk.X)

        ttk.Label(f, text="Country Tag:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.nav_tag = tk.StringVar()
        ttk.Entry(f, textvariable=self.nav_tag, width=10).grid(row=0, column=1, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Navy Name:").grid(row=0, column=2, sticky=tk.W, pady=5)
        self.nav_name = tk.StringVar(value="First Fleet")
        ttk.Entry(f, textvariable=self.nav_name, width=20).grid(row=0, column=3, sticky=tk.W, pady=5, padx=5)

        ttk.Label(f, text="Target State (Must be Coastal!):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.nav_state = tk.StringVar()
        ttk.Entry(f, textvariable=self.nav_state, width=20).grid(row=1, column=1, sticky=tk.W, pady=5, padx=5)
        
        warn_lbl = ttk.Label(f, text="(Warning: Game will crash if state is landlocked)", foreground="#EF5350")
        warn_lbl.grid(row=1, column=2, columnspan=2, sticky=tk.W)

        u_frame = ttk.LabelFrame(f, text="Composition", padding=10)
        u_frame.grid(row=2, column=0, columnspan=4, sticky=tk.W+tk.E, pady=10)

        ttk.Label(u_frame, text="Man-of-War:").grid(row=0, column=0, padx=5)
        self.nav_man = tk.IntVar(value=5)
        ttk.Entry(u_frame, textvariable=self.nav_man, width=5).grid(row=0, column=1, padx=5)

        ttk.Label(u_frame, text="Frigate:").grid(row=0, column=2, padx=5)
        self.nav_frig = tk.IntVar(value=10)
        ttk.Entry(u_frame, textvariable=self.nav_frig, width=5).grid(row=0, column=3, padx=5)

        ttk.Label(u_frame, text="Ironclad:").grid(row=0, column=4, padx=5)
        self.nav_iron = tk.IntVar(value=0)
        ttk.Entry(u_frame, textvariable=self.nav_iron, width=5).grid(row=0, column=5, padx=5)

        self.run_btn.config(text="Create Navy", command=self.start_create_navy)

    def _rgb_to_hex(self, rgb):
        return f'#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}'

    def pick_color(self):
        init_color = self._rgb_to_hex(self.cr_rgb)
        color = colorchooser.askcolor(color=init_color, title="Choose Country Color")
        if color[0]:
            self.cr_rgb = [int(x) for x in color[0]]
            self.color_preview.config(bg=color[1])

    # --- MODE 5: COUNTRY MODIFICATION ---
    def show_country_mod_ui(self):
        self.clear_content()
        self.mode = "MOD_COUNTRY"
        f = ttk.LabelFrame(self.content_frame, text="Modify Country", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # Tag Input & Load
        top_frame = ttk.Frame(f)
        top_frame.pack(fill=tk.X, pady=5)
        ttk.Label(top_frame, text="Country Tag:").pack(side=tk.LEFT)
        self.mc_tag = tk.StringVar()
        ttk.Entry(top_frame, textvariable=self.mc_tag, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(top_frame, text="Load Data", command=self.load_country_mod_data).pack(side=tk.LEFT, padx=5)

        # Identity
        id_frame = ttk.LabelFrame(f, text="Country Identity", padding=5)
        id_frame.pack(fill=tk.X, pady=5)

        ttk.Label(id_frame, text="Name:").grid(row=0, column=0, sticky=tk.W)
        self.mc_name = tk.StringVar()
        ttk.Entry(id_frame, textvariable=self.mc_name, width=30).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Label(id_frame, text="Adjective:").grid(row=0, column=2, sticky=tk.W)
        self.mc_adj = tk.StringVar()
        ttk.Entry(id_frame, textvariable=self.mc_adj, width=30).grid(row=0, column=3, sticky=tk.W, padx=5)

        ttk.Button(id_frame, text="Color Picker", command=self.pick_color_mod).grid(row=0, column=4, padx=5)
        self.mc_rgb = [255, 255, 255]
        self.mc_color_prev = tk.Label(id_frame, text="     ", bg="#FFFFFF", relief="solid", borderwidth=1)
        self.mc_color_prev.grid(row=0, column=5)

        # Internal Politics
        pol_frame = ttk.LabelFrame(f, text="Internal Politics", padding=5)
        pol_frame.pack(fill=tk.X, pady=5)

        ttk.Label(pol_frame, text="Government:").grid(row=0, column=0, sticky=tk.W)
        self.mc_gov = tk.StringVar(value="monarchy")
        gf = ttk.Frame(pol_frame)
        gf.grid(row=0, column=1, columnspan=3, sticky=tk.W)
        ttk.Radiobutton(gf, text="Monarchy", variable=self.mc_gov, value="monarchy").pack(side=tk.LEFT)
        ttk.Radiobutton(gf, text="Republic", variable=self.mc_gov, value="republic").pack(side=tk.LEFT)
        ttk.Radiobutton(gf, text="Theocracy", variable=self.mc_gov, value="theocracy").pack(side=tk.LEFT)

        ttk.Label(pol_frame, text="Economic System:").grid(row=1, column=0, sticky=tk.W)
        self.mc_law_eco = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_eco, values=["law_interventionism", "law_laissez_faire", "law_command_economy", "law_traditionalism", "law_agrarianism"], state="readonly").grid(row=1, column=1, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Trade Policy:").grid(row=1, column=2, sticky=tk.W)
        self.mc_law_trade = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_trade, values=["law_free_trade", "law_protectionism", "law_isolationism", "law_mercantilism"], state="readonly").grid(row=1, column=3, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Power Structure:").grid(row=2, column=0, sticky=tk.W)
        self.mc_law_power = tk.StringVar()
        ttk.Combobox(pol_frame, textvariable=self.mc_law_power, values=["law_autocracy", "law_oligarchy", "law_landed_voting", "law_wealth_voting", "law_census_voting", "law_universal_suffrage", "law_anarchy", "law_single_party_state"], state="readonly").grid(row=2, column=1, sticky=tk.W, padx=5)

        ttk.Label(pol_frame, text="Capital State:").grid(row=2, column=2, sticky=tk.W)
        self.mc_capital = tk.StringVar()
        ttk.Entry(pol_frame, textvariable=self.mc_capital, width=20).grid(row=2, column=3, sticky=tk.W, padx=5)

        # Ruler Designer
        rul_frame = ttk.LabelFrame(f, text="Ruler Designer", padding=5)
        rul_frame.pack(fill=tk.X, pady=5)

        ttk.Label(rul_frame, text="First Name:").grid(row=0, column=0, sticky=tk.W)
        self.mc_r_first = tk.StringVar()
        ttk.Entry(rul_frame, textvariable=self.mc_r_first).grid(row=0, column=1, padx=5)

        ttk.Label(rul_frame, text="Last Name:").grid(row=0, column=2, sticky=tk.W)
        self.mc_r_last = tk.StringVar()
        ttk.Entry(rul_frame, textvariable=self.mc_r_last).grid(row=0, column=3, padx=5)

        ttk.Label(rul_frame, text="Interest Group:").grid(row=1, column=0, sticky=tk.W)
        self.mc_r_ig = tk.StringVar()
        igs = ["ig_landowners", "ig_industrialists", "ig_intelligentsia", "ig_armed_forces", "ig_devout", "ig_petty_bourgeoisie", "ig_trade_unions", "ig_rural_folk"]
        ttk.Combobox(rul_frame, textvariable=self.mc_r_ig, values=igs, state="readonly").grid(row=1, column=1, padx=5)

        ttk.Label(rul_frame, text="Ideology:").grid(row=1, column=2, sticky=tk.W)
        self.mc_r_ideo = tk.StringVar()
        ideos = ["ideology_traditionalist", "ideology_slaver", "ideology_royalist", "ideology_theocrat", "ideology_liberal", "ideology_market_liberal", "ideology_protectionist", "ideology_abolitionist", "ideology_radical", "ideology_republican", "ideology_democrat", "ideology_jingoist", "ideology_pacifist", "ideology_moderate"]
        ttk.Combobox(rul_frame, textvariable=self.mc_r_ideo, values=ideos, state="readonly").grid(row=1, column=3, padx=5)

        self.run_btn.config(text="Save Changes", command=self.save_country_mod_changes)

    def load_country_mod_data(self):
        tag = self.logic.format_tag_clean(self.mc_tag.get())
        if not tag: return messagebox.showerror("Error", "Enter a tag.")

        # Identity
        name, adj = self.logic.load_country_localization(tag)
        self.mc_name.set(name)
        self.mc_adj.set(adj)

        rgb, cap, _ = self.logic.load_country_definition_data(tag)
        if rgb:
            self.mc_rgb = list(rgb)
            self.mc_color_prev.config(bg=self._rgb_to_hex(rgb))
        if cap:
            self.mc_capital.set(cap)

        # History
        hist = self.logic.load_country_history_details(tag)
        self.mc_gov.set(hist["gov_type"])

        # Populate laws if found
        for l in hist["laws"]:
            if "interventionism" in l or "laissez" in l or "command" in l or "traditionalism" in l or "agrarianism" in l: self.mc_law_eco.set("law_" + l if not l.startswith("law_") else l)
            if "free_trade" in l or "protectionism" in l or "isolationism" in l or "mercantilism" in l: self.mc_law_trade.set("law_" + l if not l.startswith("law_") else l)
            if "autocracy" in l or "voting" in l or "anarchy" in l or "oligarchy" in l or "party" in l: self.mc_law_power.set("law_" + l if not l.startswith("law_") else l)

        self.mc_r_first.set(hist["ruler"]["first"])
        self.mc_r_last.set(hist["ruler"]["last"])
        self.mc_r_ig.set(hist["ruler"]["ig"])
        self.mc_r_ideo.set(hist["ruler"]["ideology"])

        self.log_message(f"Loaded data for {tag}", 'success')

    def save_country_mod_changes(self):
        tag = self.logic.format_tag_clean(self.mc_tag.get())
        if not tag: return

        # Save Loc
        self.logic.save_country_localization(tag, self.mc_name.get(), self.mc_adj.get())

        # Save Def
        _, _, path = self.logic.load_country_definition_data(tag) # Get path
        clean_cap = self.logic.format_state_clean(self.mc_capital.get())
        self.logic.save_country_definition(tag, self.mc_rgb, clean_cap, path)

        # Save History
        laws = []
        if self.mc_law_eco.get(): laws.append(self.mc_law_eco.get())
        if self.mc_law_trade.get(): laws.append(self.mc_law_trade.get())
        if self.mc_law_power.get(): laws.append(self.mc_law_power.get())

        ruler = {
            "first": self.mc_r_first.get(),
            "last": self.mc_r_last.get(),
            "ig": self.mc_r_ig.get(),
            "ideology": self.mc_r_ideo.get()
        }

        self.logic.save_country_history(tag, self.mc_gov.get(), laws, ruler)
        messagebox.showinfo("Success", "Country modifications saved.")

    def pick_color_mod(self):
        init_color = self._rgb_to_hex(self.mc_rgb)
        color = colorchooser.askcolor(color=init_color, title="Choose Country Color")
        if color[0]:
            self.mc_rgb = [int(x) for x in color[0]]
            self.mc_color_prev.config(bg=color[1])

    # --- MODE 6: DIPLOMACY MANAGER ---
    def show_diplomacy_ui(self):
        self.clear_content()
        self.mode = "DIPLOMACY"
        f = ttk.LabelFrame(self.content_frame, text="Diplomacy Manager", padding=15)
        f.pack(fill=tk.BOTH, expand=True)

        # Tag & Load
        top_frame = ttk.Frame(f)
        top_frame.pack(fill=tk.X, pady=5)
        ttk.Label(top_frame, text="Country Tag:").pack(side=tk.LEFT)
        self.dip_tag = tk.StringVar()
        ttk.Entry(top_frame, textvariable=self.dip_tag, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(top_frame, text="Load Data", command=self.load_diplomacy_ui_data).pack(side=tk.LEFT, padx=5)

        # Lists
        list_frame = ttk.Frame(f)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # Subjects
        sf = ttk.LabelFrame(list_frame, text="Subject Relationships", padding=5)
        sf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0,5))
        self.lb_subjects = tk.Listbox(sf, height=8, bg="#424242", fg="#ECEFF1")
        self.lb_subjects.pack(fill=tk.BOTH, expand=True)
        ttk.Button(sf, text="Remove Selected", command=lambda: self.remove_dip_item("subject")).pack(fill=tk.X)

        # Hostiles
        hf = ttk.LabelFrame(list_frame, text="Hostile / Truces", padding=5)
        hf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5,0))
        self.lb_hostiles = tk.Listbox(hf, height=8, bg="#424242", fg="#ECEFF1")
        self.lb_hostiles.pack(fill=tk.BOTH, expand=True)
        ttk.Button(hf, text="Remove Selected", command=lambda: self.remove_dip_item("hostile")).pack(fill=tk.X)

        # Add New
        add_frame = ttk.LabelFrame(f, text="Add New Relationship", padding=5)
        add_frame.pack(fill=tk.X, pady=5)

        ttk.Label(add_frame, text="Target Tag:").grid(row=0, column=0, sticky=tk.W)
        self.dip_target = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.dip_target, width=10).grid(row=0, column=1, sticky=tk.W, padx=5)

        self.dip_cat = tk.StringVar(value="subject")
        ttk.Radiobutton(add_frame, text="Subject", variable=self.dip_cat, value="subject", command=self.update_dip_type_options).grid(row=0, column=2)
        ttk.Radiobutton(add_frame, text="Hostile/Truce", variable=self.dip_cat, value="hostile", command=self.update_dip_type_options).grid(row=0, column=3)

        self.dip_type_opts = self.logic.SUBJECT_TYPES
        self.dip_type = tk.StringVar()
        self.cb_dip_type = ttk.Combobox(add_frame, textvariable=self.dip_type, values=self.dip_type_opts, state="readonly")
        self.cb_dip_type.grid(row=0, column=4, padx=5)
        self.cb_dip_type.current(0)

        ttk.Button(add_frame, text="Create", command=self.create_diplomacy_pact).grid(row=0, column=5, padx=5)

        # Relations Value
        rel_frame = ttk.LabelFrame(f, text="Set Relations", padding=5)
        rel_frame.pack(fill=tk.X, pady=5)

        ttk.Label(rel_frame, text="Target Tag:").grid(row=0, column=0)
        self.dip_rel_target = tk.StringVar()
        ttk.Entry(rel_frame, textvariable=self.dip_rel_target, width=10).grid(row=0, column=1, padx=5)

        ttk.Label(rel_frame, text="Value (-100 to 100):").grid(row=0, column=2)
        self.dip_rel_val = tk.IntVar(value=0)
        ttk.Entry(rel_frame, textvariable=self.dip_rel_val, width=5).grid(row=0, column=3, padx=5)

        ttk.Button(rel_frame, text="Set Relation", command=self.set_relation_val).grid(row=0, column=4, padx=5)

        self.run_btn.config(text="Refresh Data", command=self.load_diplomacy_ui_data)

    def update_dip_type_options(self):
        cat = self.dip_cat.get()
        if cat == "subject":
            self.dip_type_opts = self.logic.SUBJECT_TYPES
        else:
            self.dip_type_opts = ["rivalry", "embargo", "truce"]
        self.cb_dip_type['values'] = self.dip_type_opts
        self.cb_dip_type.current(0)

    def load_diplomacy_ui_data(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        if not tag: return messagebox.showerror("Error", "Enter a tag.")

        data = self.logic.load_diplomacy_data(tag)

        self.lb_subjects.delete(0, tk.END)
        for s in data["subjects"]:
            self.lb_subjects.insert(tk.END, f"{s['target']} ({s['type']})")

        self.lb_hostiles.delete(0, tk.END)
        for r in data["rivals"]: self.lb_hostiles.insert(tk.END, f"{r} (Rival)")
        for e in data["embargos"]: self.lb_hostiles.insert(tk.END, f"{e} (Embargo)")
        for t in data["truces"]: self.lb_hostiles.insert(tk.END, f"{t['target']} (Truce: {t['months']}m)")

        self.log_message(f"Loaded diplomacy for {tag}", 'success')

    def create_diplomacy_pact(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        target = self.logic.format_tag_clean(self.dip_target.get())
        dtype = self.dip_type.get()
        cat = self.dip_cat.get() # subject or hostile

        if not tag or not target: return messagebox.showerror("Error", "Tags required.")

        real_cat = "subject"
        if cat == "hostile":
            if dtype == "rivalry": real_cat = "rival"
            elif dtype == "embargo": real_cat = "embargo"
            elif dtype == "truce": real_cat = "truce"

        self.logic.add_diplomatic_pact(tag, target, dtype, real_cat)
        self.load_diplomacy_ui_data()

    def remove_dip_item(self, list_type):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        if not tag: return

        sel = None
        if list_type == "subject":
            sel = self.lb_subjects.curselection()
        else:
            sel = self.lb_hostiles.curselection()

        if not sel: return

        text = self.lb_subjects.get(sel[0]) if list_type == "subject" else self.lb_hostiles.get(sel[0])
        # Parse text: "TARGET (TYPE)" or "TARGET (Truce: 12m)"
        target = text.split()[0]
        dtype = ""
        if "Rival" in text: dtype = "rivalry"
        elif "Embargo" in text: dtype = "embargo"
        elif "Truce" in text: dtype = "truce"
        else:
            # Subject type
            dtype = text.split('(')[1].replace(')', '')

        self.logic.remove_diplomatic_pact(tag, target, dtype)
        self.load_diplomacy_ui_data()

    def set_relation_val(self):
        tag = self.logic.format_tag_clean(self.dip_tag.get())
        target = self.logic.format_tag_clean(self.dip_rel_target.get())
        try:
            val = self.dip_rel_val.get()
        except: return

        if not tag or not target: return

        self.logic.set_relations(tag, target, val)
        self.log_message(f"Set relations {tag}<->{target} to {val}")

    # --- SHARED FUNCTIONS ---
    def browse_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.path_var.set(folder)
            self.logic.set_mod_path(folder)
            self.save_config()
            self.log_message(f"Selected Mod Path: {folder}")

    def log_message(self, message, level='info'):
        self.log_queue.put((message, level))

    def process_log_queue(self):
        while not self.log_queue.empty():
            msg, level = self.log_queue.get()
            self.log_area.config(state='normal')
            self.log_area.insert(tk.END, msg.strip() + "\n", level)
            self.log_area.see(tk.END)
            self.log_area.config(state='disabled')
        self.after(100, self.process_log_queue)

    def start_transfer(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        old = self.logic.format_tag_clean(self.tr_old_tag.get())
        new = self.logic.format_tag_clean(self.tr_new_tag.get())
        annex = self.tr_annex.get()
        raw_st = self.tr_states.get("1.0", tk.END)
        if not old or not new: return messagebox.showerror("Error", "Tags required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_transfer_logic, args=(old, new, annex, raw_st), daemon=True).start()

    def start_create(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.cr_tag.get())
        name = self.cr_name.get().strip()
        adj = self.cr_adj.get().strip()
        old_owner = self.logic.format_tag_clean(self.cr_old_owner.get())
        capital = self.logic.format_state_clean(self.cr_capital.get())
        others_raw = self.cr_others.get("1.0", tk.END)
        gov = self.cr_gov.get()
        rgb = self.cr_rgb
        is_annex = self.cr_annex.get()

        tier = self.cr_tier.get()
        country_type = self.cr_type.get()
        cultures = self.selected_cultures
        religion = self.cr_religion.get()

        if not tag or not name or not old_owner: return messagebox.showerror("Error", "Tag, Name, and Old Owner are required.")
        if not is_annex and not capital: return messagebox.showerror("Error", "Capital State ID required unless Full Annexation.")
        if len(tag) != 3: return messagebox.showerror("Error", "Tag must be exactly 3 characters.")

        # Pre-fetch old owner data to minimize redundant calls
        data = self.logic.get_country_data(old_owner)

        # If cultures were not manually selected, default to old owner's data
        if not cultures:
            if data["cultures"]:
                cultures = data["cultures"].split()

        # If religion is not manually selected, check old owner, then check culture
        if not religion:
            if data["religion"]:
                religion = data["religion"]
            else:
                # Attempt to find religion from the primary culture
                found_rel = None
                if cultures:
                    prim_culture = cultures[0]
                    self.log_message(f"[INFO] Religion missing. searching in culture '{prim_culture}'...", 'info')
                    found_rel = self.logic.get_religion_by_culture(prim_culture)
                
                if found_rel:
                    religion = found_rel
                    self.log_message(f"[INFO] Found religion '{religion}' from culture '{prim_culture}'.", 'success')
                else:
                    self.log_message(f"[WARN] Religion not found for {old_owner} or culture. Defaulting to 'catholic'.", 'warn')
                    religion = "catholic"

        if not cultures: return messagebox.showerror("Error", "At least one culture required.")
        # Religion check removed, effectively allowing the process to continue even if religion wasn't found (defaulted to catholic)

        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_create_logic, args=(tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type), daemon=True).start()

    def start_create_army(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.arm_tag.get())
        name = self.arm_name.get().strip() or "Army"
        state = self.logic.format_state_clean(self.arm_state.get())
        try:
            inf = int(self.arm_inf.get())
            art = int(self.arm_art.get())
            cav = int(self.arm_cav.get())
        except: return messagebox.showerror("Error", "Unit counts must be integers.")
        if not tag: return messagebox.showerror("Error", "Tag is required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_army_logic, args=(tag, name, state, inf, art, cav), daemon=True).start()

    def start_create_navy(self):
        if self.is_processing: return
        mod_path = self.path_var.get()
        if not mod_path: return messagebox.showerror("Error", "Select mod path first.")
        tag = self.logic.format_tag_clean(self.nav_tag.get())
        name = self.nav_name.get().strip() or "Fleet"
        state = self.logic.format_state_clean(self.nav_state.get())
        try:
            man = int(self.nav_man.get())
            frig = int(self.nav_frig.get())
            iron = int(self.nav_iron.get())
        except: return messagebox.showerror("Error", "Unit counts must be integers.")
        if not tag: return messagebox.showerror("Error", "Tag is required.")
        self.is_processing = True
        self.run_btn.config(state='disabled')
        self.log_area.config(state='normal'); self.log_area.delete('1.0', tk.END); self.log_area.config(state='disabled')
        threading.Thread(target=self.run_navy_logic, args=(tag, name, state, man, frig, iron), daemon=True).start()

    # --- LOGIC THREADS ---
    def run_transfer_logic(self, old_tag, new_tag, is_annex, raw_states):
        try:
            self.log_message(f"--- Processing Transfer: {old_tag} -> {new_tag} ---", 'info')
            states_clean = []
            if is_annex:
                self.log_message(f"[INFO] Detecting states owned by {old_tag}...", 'info')
                states_clean = self.logic.get_all_owned_states(old_tag)
                if not states_clean:
                    self.log_message(f"[WARN] No states found for {old_tag}.", 'warn')
                    return
            else:
                states_clean = [self.logic.format_state_clean(s) for s in raw_states.split() if s.strip()]
                if not states_clean: return self.log_message("[ERROR] No states provided.", 'error')
            self.execute_transfer_core(states_clean, old_tag, new_tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_create_logic(self, tag, name, adj, old_owner, capital, others_raw, gov, rgb, is_annex, cultures, religion, tier, country_type):
        try:
            self.log_message(f"--- Creating Country: {tag} ({name}) ---", 'info')
            if self.logic.tag_exists(tag):
                self.log_message(f"[ERROR] Tag {tag} already exists in common/country_definitions!", 'error')
                return

            # (Old owner data logic is now partly in UI for prepopulation, but we still need capital logic if annexing)
            data = self.logic.get_country_data(old_owner)
            
            all_states = []
            if is_annex:
                self.log_message(f"[INFO] Full Annexation selected. Detecting all states for {old_owner}...", 'info')
                found_states = self.logic.get_all_owned_states(old_owner)
                if not found_states:
                    self.log_message(f"[WARN] No states found for {old_owner} to annex.", 'warn')
                    return
                all_states = found_states
                
                # If capital input is blank, use old owner's capital
                if not capital:
                    if data["capital"]:
                        capital = data["capital"]
                        self.log_message(f"[INFO] Auto-detected capital: {capital}", 'info')
                    elif all_states:
                        capital = all_states[0] # Fallback to first found state
                        self.log_message(f"[WARN] Capital undefined in old owner. Using first state: {capital}", 'warn')
                    else:
                        self.log_message("[ERROR] Cannot determine capital state.", 'error')
                        return
            else:
                others = [self.logic.format_state_clean(s) for s in others_raw.split() if s.strip()]
                all_states = [capital] + others

            self.logic.create_country_files(tag, name, adj, capital, gov, rgb, cultures, religion, tier, country_type, old_owner)
            
            self.log_message("--- Transferring Land & Units ---", 'info')
            self.execute_transfer_core(all_states, old_owner, tag)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_army_logic(self, tag, name, state, inf, art, cav):
        try:
            self.log_message(f"--- Creating Army Template for {tag} ---", 'info')
            self.logic.create_army_file(tag, name, state, inf, art, cav)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def run_navy_logic(self, tag, name, state, man, frig, iron):
        try:
            self.log_message(f"--- Creating Navy Template for {tag} ---", 'info')
            self.logic.create_navy_file(tag, name, state, man, frig, iron)
        except Exception as e:
            self.log_message(f"CRITICAL ERROR: {str(e)}", 'error')
            traceback.print_exc()
        finally:
            self.is_processing = False
            self.after(0, lambda: self.run_btn.config(state='normal'))

    def execute_transfer_core(self, states_clean, old_tag, new_tag):
        self.log_message("--- Processing Map Data ---")
        self.logic.transfer_ownership_batch(states_clean, old_tag, new_tag)
        regions_to_process = {}
        for state in states_clean:
            reg = self.logic.find_strategic_region(f"s:{state}")
            if reg:
                if reg not in regions_to_process: regions_to_process[reg] = []
                regions_to_process[reg].append(state)
        self.log_message("--- Processing Military Formations ---")
        for reg, states in regions_to_process.items():
            self.log_message(f" -> Scanning region: {reg}")
            self.logic.clean_military_smart(old_tag, new_tag, reg, states)
        self.log_message("--- Validating Character Links ---")
        valid_scopes = self.logic.collect_valid_scopes()
        self.logic.prune_orphaned_commanders(valid_scopes)
        self.log_message("Done.", 'success')

if __name__ == "__main__":
    app = App()
    app.mainloop()
